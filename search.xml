<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>JavaScript</title>
      <link href="/2025/04/14/javaWeb/2.0%20JS/"/>
      <url>/2025/04/14/javaWeb/2.0%20JS/</url>
      
        <content type="html"><![CDATA[<h2 id="一、JavaScript-简介"><a href="#一、JavaScript-简介" class="headerlink" title="一、JavaScript 简介"></a>一、JavaScript 简介</h2><p>JavaScript 是网页的编程语言，主要用于：</p><ul><li>控制网页中的 HTML 元素</li><li>响应用户操作（按钮、键盘、鼠标等）</li><li>动态加载数据（AJAX、Fetch）</li><li>控制多媒体、动画、游戏等</li></ul><p>运行环境：</p><ul><li><strong>浏览器</strong>（如 Chrome、Firefox、Edge）</li><li><strong>Node.js</strong>（运行在服务器端）</li></ul><hr><h2 id="二、基础语法"><a href="#二、基础语法" class="headerlink" title="二、基础语法"></a>二、基础语法</h2><h3 id="1-变量声明"><a href="#1-变量声明" class="headerlink" title="1. 变量声明"></a>1. 变量声明</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> name = <span class="hljs-string">&quot;张三&quot;</span>;     <span class="hljs-comment">// 可变变量</span><br><span class="hljs-keyword">const</span> age = <span class="hljs-number">18</span>;        <span class="hljs-comment">// 常量，不能修改</span><br><span class="hljs-keyword">var</span> city = <span class="hljs-string">&quot;北京&quot;</span>;     <span class="hljs-comment">// 不推荐使用（有作用域问题）</span><br></code></pre></td></tr></table></figure><h3 id="2-数据类型"><a href="#2-数据类型" class="headerlink" title="2. 数据类型"></a>2. 数据类型</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;你好&quot;</span>;        <span class="hljs-comment">// 字符串</span><br><span class="hljs-keyword">let</span> num = <span class="hljs-number">123</span>;           <span class="hljs-comment">// 数字</span><br><span class="hljs-keyword">let</span> bool = <span class="hljs-literal">true</span>;         <span class="hljs-comment">// 布尔值</span><br><span class="hljs-keyword">let</span> obj = &#123;<span class="hljs-attr">x</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">2</span>&#125;;  <span class="hljs-comment">// 对象</span><br><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];     <span class="hljs-comment">// 数组</span><br><span class="hljs-keyword">let</span> nil = <span class="hljs-literal">null</span>;          <span class="hljs-comment">// 空值</span><br><span class="hljs-keyword">let</span> undef = <span class="hljs-literal">undefined</span>;   <span class="hljs-comment">// 未定义</span><br></code></pre></td></tr></table></figure><h3 id="3-运算符"><a href="#3-运算符" class="headerlink" title="3. 运算符"></a>3. 运算符</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">+ - * <span class="hljs-regexp">/ % **      /</span>/ 数学运算<br>== === != !==     <span class="hljs-comment">// 相等比较（=== 更安全）</span><br>&amp;&amp; || !           <span class="hljs-comment">// 逻辑运算</span><br>+= -= *= <span class="hljs-regexp">/=       /</span>/ 赋值运算<br></code></pre></td></tr></table></figure><h3 id="4-条件语句"><a href="#4-条件语句" class="headerlink" title="4. 条件语句"></a>4. 条件语句</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (age &gt;= <span class="hljs-number">18</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;成年人&quot;</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;未成年&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-循环"><a href="#5-循环" class="headerlink" title="5. 循环"></a>5. 循环</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i);<br>&#125;<br><br><span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (i &lt; <span class="hljs-number">5</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i);<br>  i++;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="三、函数与作用域"><a href="#三、函数与作用域" class="headerlink" title="三、函数与作用域"></a>三、函数与作用域</h2><h3 id="1-函数定义"><a href="#1-函数定义" class="headerlink" title="1. 函数定义"></a>1. 函数定义</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">greet</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;你好, &quot;</span> + name;<br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">greet2</span> = (<span class="hljs-params">name</span>) =&gt; <span class="hljs-string">&quot;你好, &quot;</span> + name;<br></code></pre></td></tr></table></figure><h3 id="2-作用域（Scope）"><a href="#2-作用域（Scope）" class="headerlink" title="2. 作用域（Scope）"></a>2. 作用域（Scope）</h3><ul><li>全局作用域（global）</li><li>函数作用域（function）</li><li>块级作用域（let&#x2F;const）</li></ul><hr><h2 id="四、常用对象和API"><a href="#四、常用对象和API" class="headerlink" title="四、常用对象和API"></a>四、常用对象和API</h2><h3 id="1-数组方法"><a href="#1-数组方法" class="headerlink" title="1. 数组方法"></a>1. 数组方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>arr.<span class="hljs-title function_">push</span>(<span class="hljs-number">4</span>);          <span class="hljs-comment">// 添加</span><br>arr.<span class="hljs-title function_">pop</span>();            <span class="hljs-comment">// 移除末尾</span><br>arr.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x * <span class="hljs-number">2</span>);  <span class="hljs-comment">// 映射</span><br>arr.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x &gt; <span class="hljs-number">1</span>); <span class="hljs-comment">// 过滤</span><br></code></pre></td></tr></table></figure><h3 id="2-字符串方法"><a href="#2-字符串方法" class="headerlink" title="2. 字符串方法"></a>2. 字符串方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;Hello JS&quot;</span>;<br>str.<span class="hljs-property">length</span>;         <span class="hljs-comment">// 长度</span><br>str.<span class="hljs-title function_">toUpperCase</span>();  <span class="hljs-comment">// 全大写</span><br>str.<span class="hljs-title function_">includes</span>(<span class="hljs-string">&quot;JS&quot;</span>); <span class="hljs-comment">// 是否包含</span><br></code></pre></td></tr></table></figure><h3 id="3-日期对象"><a href="#3-日期对象" class="headerlink" title="3. 日期对象"></a>3. 日期对象</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> now = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br>now.<span class="hljs-title function_">getFullYear</span>(); <span class="hljs-comment">// 当前年份</span><br>now.<span class="hljs-title function_">getMonth</span>();    <span class="hljs-comment">// 当前月份（0~11）</span><br></code></pre></td></tr></table></figure><hr><h2 id="五、DOM-操作（网页交互）"><a href="#五、DOM-操作（网页交互）" class="headerlink" title="五、DOM 操作（网页交互）"></a>五、DOM 操作（网页交互）</h2><h3 id="1-获取元素"><a href="#1-获取元素" class="headerlink" title="1. 获取元素"></a>1. 获取元素</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> btn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;btn&quot;</span>);<br><span class="hljs-keyword">let</span> items = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">&quot;.item&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="2-修改内容与属性"><a href="#2-修改内容与属性" class="headerlink" title="2. 修改内容与属性"></a>2. 修改内容与属性</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;text&quot;</span>).<span class="hljs-property">innerText</span> = <span class="hljs-string">&quot;新的内容&quot;</span>;<br>btn.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">&quot;disabled&quot;</span>, <span class="hljs-literal">true</span>);<br></code></pre></td></tr></table></figure><h3 id="3-事件绑定"><a href="#3-事件绑定" class="headerlink" title="3. 事件绑定"></a>3. 事件绑定</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">btn.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;按钮被点击！&quot;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><hr><h2 id="六、异步编程与网络请求"><a href="#六、异步编程与网络请求" class="headerlink" title="六、异步编程与网络请求"></a>六、异步编程与网络请求</h2><h3 id="1-setTimeout-setInterval"><a href="#1-setTimeout-setInterval" class="headerlink" title="1. setTimeout &#x2F; setInterval"></a>1. setTimeout &#x2F; setInterval</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;3秒后执行&quot;</span>), <span class="hljs-number">3000</span>);<br><span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;每2秒执行&quot;</span>), <span class="hljs-number">2000</span>);<br></code></pre></td></tr></table></figure><h3 id="2-fetch-请求"><a href="#2-fetch-请求" class="headerlink" title="2. fetch 请求"></a>2. fetch 请求</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">fetch</span>(<span class="hljs-string">&quot;https://api.example.com/data&quot;</span>)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> response.<span class="hljs-title function_">json</span>())<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data));<br></code></pre></td></tr></table></figure><h3 id="3-async-await"><a href="#3-async-await" class="headerlink" title="3. async &#x2F; await"></a>3. async &#x2F; await</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getData</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> res = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&quot;https://api.example.com/data&quot;</span>);<br>  <span class="hljs-keyword">let</span> data = <span class="hljs-keyword">await</span> res.<span class="hljs-title function_">json</span>();<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="七、浏览器交互进阶"><a href="#七、浏览器交互进阶" class="headerlink" title="七、浏览器交互进阶"></a>七、浏览器交互进阶</h2><h3 id="1-控制样式"><a href="#1-控制样式" class="headerlink" title="1. 控制样式"></a>1. 控制样式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;box&quot;</span>).<span class="hljs-property">style</span>.<span class="hljs-property">backgroundColor</span> = <span class="hljs-string">&quot;red&quot;</span>;<br></code></pre></td></tr></table></figure><h3 id="2-表单处理"><a href="#2-表单处理" class="headerlink" title="2. 表单处理"></a>2. 表单处理</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;submitName()&quot;</span>&gt;</span>提交<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">function</span> <span class="hljs-title function_">submitName</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">let</span> name = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;name&quot;</span>).<span class="hljs-property">value</span>;</span><br><span class="language-javascript">    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;你输入的是：&quot;</span> + name);</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><h2 id="八、其他进阶内容（简要概览）"><a href="#八、其他进阶内容（简要概览）" class="headerlink" title="八、其他进阶内容（简要概览）"></a>八、其他进阶内容（简要概览）</h2><ul><li><strong>本地存储</strong>（localStorage &#x2F; sessionStorage）</li><li><strong>面向对象编程（OOP）</strong></li><li><strong>模块化（import &#x2F; export）</strong></li><li><strong>事件冒泡 &#x2F; 捕获</strong></li><li><strong>Canvas 图形绘制</strong></li><li><strong>前端框架（如 Vue、React）</strong></li><li><strong>与 HTML&#x2F;CSS 的整合应用</strong></li></ul><hr><h2 id="九、综合小案例（点击换颜色）"><a href="#九、综合小案例（点击换颜色）" class="headerlink" title="九、综合小案例（点击换颜色）"></a>九、综合小案例（点击换颜色）</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;changeColor()&quot;</span>&gt;</span>变色<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;box&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;width:100px; height:100px; background:lightblue;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">changeColor</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">  <span class="hljs-keyword">let</span> box = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;box&quot;</span>);</span><br><span class="language-javascript">  box.<span class="hljs-property">style</span>.<span class="hljs-property">backgroundColor</span> = </span><br><span class="language-javascript">    box.<span class="hljs-property">style</span>.<span class="hljs-property">backgroundColor</span> === <span class="hljs-string">&quot;lightblue&quot;</span> ? <span class="hljs-string">&quot;orange&quot;</span> : <span class="hljs-string">&quot;lightblue&quot;</span>;</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML-CSS</title>
      <link href="/2025/04/08/javaWeb/1.0%20HTML-CSS/"/>
      <url>/2025/04/08/javaWeb/1.0%20HTML-CSS/</url>
      
        <content type="html"><![CDATA[<h2 id="一、HTML-基础详解"><a href="#一、HTML-基础详解" class="headerlink" title="一、HTML 基础详解"></a>一、HTML 基础详解</h2><h3 id="1-1-HTML-是什么？"><a href="#1-1-HTML-是什么？" class="headerlink" title="1.1 HTML 是什么？"></a>1.1 HTML 是什么？</h3><p>HTML（HyperText Markup Language，超文本标记语言）是网页的结构语言，用来描述网页的内容，如文本、图片、视频、链接等。</p><h3 id="1-2-HTML-文档结构"><a href="#1-2-HTML-文档结构" class="headerlink" title="1.2 HTML 文档结构"></a>1.2 HTML 文档结构</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>网页标题<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>主标题<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>段落内容<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="1-3-常用标签分类"><a href="#1-3-常用标签分类" class="headerlink" title="1.3 常用标签分类"></a>1.3 常用标签分类</h3><h4 id="（1）标题与段落"><a href="#（1）标题与段落" class="headerlink" title="（1）标题与段落"></a>（1）标题与段落</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>标题1<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>标题2<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>这是一个段落。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="（2）链接与图片"><a href="#（2）链接与图片" class="headerlink" title="（2）链接与图片"></a>（2）链接与图片</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://example.com&quot;</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;_blank&quot;</span>&gt;</span>访问链接<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;image.jpg&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;描述文字&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;300&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="（3）音频与视频"><a href="#（3）音频与视频" class="headerlink" title="（3）音频与视频"></a>（3）音频与视频</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">audio</span> <span class="hljs-attr">controls</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;music.mp3&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;audio/mpeg&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">audio</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">video</span> <span class="hljs-attr">controls</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;400&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;video.mp4&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;video/mp4&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">video</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="（4）列表"><a href="#（4）列表" class="headerlink" title="（4）列表"></a>（4）列表</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>无序列表项<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">ol</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>有序列表项<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="（5）表格"><a href="#（5）表格" class="headerlink" title="（5）表格"></a>（5）表格</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">border</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>姓名<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>年龄<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>张三<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>18<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="（6）表单"><a href="#（6）表单" class="headerlink" title="（6）表单"></a>（6）表单</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;/submit&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span>姓名：<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>性别：<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;gender&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;male&quot;</span>&gt;</span> 男<br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;gender&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;female&quot;</span>&gt;</span> 女<br>  <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;提交&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><h2 id="二、CSS-基础与常用样式"><a href="#二、CSS-基础与常用样式" class="headerlink" title="二、CSS 基础与常用样式"></a>二、CSS 基础与常用样式</h2><h3 id="2-1-CSS-是什么？"><a href="#2-1-CSS-是什么？" class="headerlink" title="2.1 CSS 是什么？"></a>2.1 CSS 是什么？</h3><p>CSS（Cascading Style Sheets）用于设置网页样式（字体、颜色、布局、动画等），让页面更美观。</p><h3 id="2-2-CSS-三种写法"><a href="#2-2-CSS-三种写法" class="headerlink" title="2.2 CSS 三种写法"></a>2.2 CSS 三种写法</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 内联样式 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color: red;&quot;</span>&gt;</span>红色文字<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 内部样式 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">  <span class="hljs-selector-tag">h1</span> &#123; <span class="hljs-attribute">color</span>: blue; &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 外部样式 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;style.css&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="2-3-常见属性分类"><a href="#2-3-常见属性分类" class="headerlink" title="2.3 常见属性分类"></a>2.3 常见属性分类</h3><h4 id="字体与文字"><a href="#字体与文字" class="headerlink" title="字体与文字"></a>字体与文字</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">font-size</span>: <span class="hljs-number">16px</span>;<br><span class="hljs-attribute">color</span>: <span class="hljs-number">#333</span>;<br><span class="hljs-attribute">text-align</span>: center;<br><span class="hljs-attribute">font-weight</span>: bold;<br><span class="hljs-attribute">line-height</span>: <span class="hljs-number">1.5</span>;<br></code></pre></td></tr></table></figure><h4 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;<br><span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;<br><span class="hljs-attribute">margin</span>: <span class="hljs-number">10px</span>;<br><span class="hljs-attribute">padding</span>: <span class="hljs-number">20px</span>;<br><span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#000</span>;<br><span class="hljs-attribute">box-sizing</span>: border-box;<br></code></pre></td></tr></table></figure><h4 id="背景与边框"><a href="#背景与边框" class="headerlink" title="背景与边框"></a>背景与边框</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">background-color</span>: <span class="hljs-number">#f0f0f0</span>;<br><span class="hljs-attribute">border-radius</span>: <span class="hljs-number">10px</span>;<br><span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">10px</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0.1</span>);<br></code></pre></td></tr></table></figure><h4 id="鼠标与动画"><a href="#鼠标与动画" class="headerlink" title="鼠标与动画"></a>鼠标与动画</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">cursor</span>: pointer;<br><span class="hljs-attribute">transition</span>: all <span class="hljs-number">0.3s</span> ease;<br></code></pre></td></tr></table></figure><hr><h2 id="三、CSS-布局体系"><a href="#三、CSS-布局体系" class="headerlink" title="三、CSS 布局体系"></a>三、CSS 布局体系</h2><h3 id="3-1-传统布局方式：float-和-position"><a href="#3-1-传统布局方式：float-和-position" class="headerlink" title="3.1 传统布局方式：float 和 position"></a>3.1 传统布局方式：<code>float</code> 和 <code>position</code></h3><ul><li><code>float</code>: 浮动布局（现在多用于兼容旧浏览器）</li><li><code>position</code>: 绝对定位与相对定位</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">position</span>: relative; <span class="hljs-comment">/* 相对当前位置 */</span><br><span class="hljs-attribute">position</span>: absolute; <span class="hljs-comment">/* 相对最近的定位祖先 */</span><br></code></pre></td></tr></table></figure><h3 id="3-2-弹性布局（Flexbox）"><a href="#3-2-弹性布局（Flexbox）" class="headerlink" title="3.2 弹性布局（Flexbox）"></a>3.2 弹性布局（Flexbox）</h3><p><strong>Flexbox</strong> 是现代主流的布局方式，用于水平&#x2F;垂直排列、自动间距、对齐等。</p><h4 id="父容器属性"><a href="#父容器属性" class="headerlink" title="父容器属性"></a>父容器属性</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">display</span>: flex;<br><span class="hljs-attribute">flex-direction</span>: row;     <span class="hljs-comment">/* 水平排列 */</span><br><span class="hljs-attribute">justify-content</span>: space-between; <span class="hljs-comment">/* 水平对齐 */</span><br><span class="hljs-attribute">align-items</span>: center;     <span class="hljs-comment">/* 垂直对齐 */</span><br></code></pre></td></tr></table></figure><h4 id="子项属性"><a href="#子项属性" class="headerlink" title="子项属性"></a>子项属性</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>;             <span class="hljs-comment">/* 自动占据剩余空间 */</span><br><span class="hljs-attribute">order</span>: <span class="hljs-number">2</span>;            <span class="hljs-comment">/* 排序 */</span><br><span class="hljs-attribute">align-self</span>: flex-end; <span class="hljs-comment">/* 单独对齐 */</span><br></code></pre></td></tr></table></figure><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;display: flex;&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;flex: 1; background: red;&quot;</span>&gt;</span>左边<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;flex: 2; background: blue;&quot;</span>&gt;</span>右边<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><h2 id="四、补充内容（推荐了解）"><a href="#四、补充内容（推荐了解）" class="headerlink" title="四、补充内容（推荐了解）"></a>四、补充内容（推荐了解）</h2><h3 id="4-1-常用-HTML5-新标签"><a href="#4-1-常用-HTML5-新标签" class="headerlink" title="4.1 常用 HTML5 新标签"></a>4.1 常用 HTML5 新标签</h3><table><thead><tr><th>标签</th><th>作用</th></tr></thead><tbody><tr><td><code>&lt;header&gt;</code></td><td>页眉</td></tr><tr><td><code>&lt;nav&gt;</code></td><td>导航</td></tr><tr><td><code>&lt;section&gt;</code></td><td>区块</td></tr><tr><td><code>&lt;article&gt;</code></td><td>文章内容</td></tr><tr><td><code>&lt;footer&gt;</code></td><td>页脚</td></tr></tbody></table><h3 id="4-2-响应式设计基础"><a href="#4-2-响应式设计基础" class="headerlink" title="4.2 响应式设计基础"></a>4.2 响应式设计基础</h3><p>使用媒体查询：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@media</span> (<span class="hljs-attribute">max-width</span>: <span class="hljs-number">600px</span>) &#123;<br>  <span class="hljs-selector-tag">body</span> &#123;<br>    <span class="hljs-attribute">background-color</span>: lightgray;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-3-常见选择器总结"><a href="#4-3-常见选择器总结" class="headerlink" title="4.3 常见选择器总结"></a>4.3 常见选择器总结</h3><table><thead><tr><th>选择器</th><th>作用</th></tr></thead><tbody><tr><td><code>*</code></td><td>选择所有元素</td></tr><tr><td><code>.class</code></td><td>选择类名</td></tr><tr><td><code>#id</code></td><td>选择 ID</td></tr><tr><td><code>div p</code></td><td>后代选择器</td></tr><tr><td><code>div &gt; p</code></td><td>子选择器</td></tr><tr><td><code>a:hover</code></td><td>伪类选择器</td></tr></tbody></table><hr><h2 id="五、综合实例"><a href="#五、综合实例" class="headerlink" title="五、综合实例"></a>五、综合实例</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>个人信息页<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">    <span class="hljs-selector-tag">body</span> &#123;</span><br><span class="language-css">      <span class="hljs-attribute">font-family</span>: sans-serif;</span><br><span class="language-css">      <span class="hljs-attribute">background</span>: <span class="hljs-number">#f0f2f5</span>;</span><br><span class="language-css">      <span class="hljs-attribute">padding</span>: <span class="hljs-number">20px</span>;</span><br><span class="language-css">    &#125;</span><br><span class="language-css">    <span class="hljs-selector-class">.card</span> &#123;</span><br><span class="language-css">      <span class="hljs-attribute">max-width</span>: <span class="hljs-number">600px</span>;</span><br><span class="language-css">      <span class="hljs-attribute">margin</span>: auto;</span><br><span class="language-css">      <span class="hljs-attribute">background</span>: white;</span><br><span class="language-css">      <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">10px</span>;</span><br><span class="language-css">      <span class="hljs-attribute">padding</span>: <span class="hljs-number">20px</span>;</span><br><span class="language-css">      <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">10px</span> <span class="hljs-number">#ccc</span>;</span><br><span class="language-css">    &#125;</span><br><span class="language-css">    <span class="hljs-selector-class">.card</span> <span class="hljs-selector-tag">img</span> &#123;</span><br><span class="language-css">      <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;</span><br><span class="language-css">      <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">10px</span>;</span><br><span class="language-css">    &#125;</span><br><span class="language-css">    <span class="hljs-selector-class">.card</span> <span class="hljs-selector-tag">h2</span> &#123;</span><br><span class="language-css">      <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">10px</span>;</span><br><span class="language-css">    &#125;</span><br><span class="language-css">    <span class="hljs-selector-class">.card</span> <span class="hljs-selector-tag">form</span> <span class="hljs-selector-tag">input</span>, <span class="hljs-selector-class">.card</span> <span class="hljs-selector-tag">form</span> <span class="hljs-selector-tag">textarea</span> &#123;</span><br><span class="language-css">      <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;</span><br><span class="language-css">      <span class="hljs-attribute">padding</span>: <span class="hljs-number">8px</span>;</span><br><span class="language-css">      <span class="hljs-attribute">margin</span>: <span class="hljs-number">5px</span> <span class="hljs-number">0</span>;</span><br><span class="language-css">      <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#ccc</span>;</span><br><span class="language-css">      <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">5px</span>;</span><br><span class="language-css">    &#125;</span><br><span class="language-css">    <span class="hljs-selector-class">.card</span> <span class="hljs-selector-tag">form</span> <span class="hljs-selector-tag">button</span> &#123;</span><br><span class="language-css">      <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span> <span class="hljs-number">20px</span>;</span><br><span class="language-css">      <span class="hljs-attribute">background</span>: <span class="hljs-number">#007bff</span>;</span><br><span class="language-css">      <span class="hljs-attribute">color</span>: white;</span><br><span class="language-css">      <span class="hljs-attribute">border</span>: none;</span><br><span class="language-css">      <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">5px</span>;</span><br><span class="language-css">    &#125;</span><br><span class="language-css">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;card&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;profile.jpg&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;个人头像&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>张三<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>前端开发爱好者<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">form</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>留言：<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">textarea</span> <span class="hljs-attr">rows</span>=<span class="hljs-string">&quot;4&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">textarea</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span>提交<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><h2 id="六、学习建议与工具"><a href="#六、学习建议与工具" class="headerlink" title="六、学习建议与工具"></a>六、学习建议与工具</h2><h3 id="推荐工具"><a href="#推荐工具" class="headerlink" title="推荐工具"></a>推荐工具</h3><ul><li>编码工具：VS Code</li><li>在线预览：CodePen、JSFiddle</li><li>图标库：Font Awesome</li><li>布局参考：Flexbox Froggy（游戏学弹性布局）</li></ul><hr><h2 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h2><table><thead><tr><th>项目</th><th>内容</th></tr></thead><tbody><tr><td>HTML</td><td>构建网页结构</td></tr><tr><td>CSS</td><td>美化网页样式</td></tr><tr><td>盒子模型</td><td>理解网页元素占据的空间</td></tr><tr><td>Flex 布局</td><td>实现灵活排列、居中等</td></tr><tr><td>表单、表格、多媒体</td><td>丰富网页内容类型</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>32位汇编的一些例题</title>
      <link href="/2025/04/07/32wei/03example/"/>
      <url>/2025/04/07/32wei/03example/</url>
      
        <content type="html"><![CDATA[<h3 id="1-输出-Hello-World"><a href="#1-输出-Hello-World" class="headerlink" title="1. 输出 Hello World"></a>1. <strong>输出 Hello World</strong></h3><p>这是最基础的字符串输出。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs asm">include Irvine32.inc<br><br>.data<br>hello db &quot;Hello World&quot;, 0<br><br>.code<br>main PROC<br>    mov edx, offset hello<br>    call WriteString<br>    call Crlf    ; 换行<br>    exit<br>main ENDP<br><br>end main<br></code></pre></td></tr></table></figure><h3 id="2-比较-3-个数找最大值"><a href="#2-比较-3-个数找最大值" class="headerlink" title="2. 比较 3 个数找最大值"></a>2. <strong>比较 3 个数找最大值</strong></h3><p>利用 <code>cmp</code> 指令和条件跳转来比较三个数的大小。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs asm">include Irvine32.inc<br><br>.data<br>num1 dd 10<br>num2 dd 20<br>num3 dd 30<br><br>msgMax db &quot;最大值是: &quot;, 0<br><br>.code<br>main PROC<br>    mov eax, [num1]<br>    mov ebx, [num2]<br>    cmp eax, ebx<br>    jge check_num3   ; 如果 num1 &gt;= num2 跳到检查 num3<br><br>    mov eax, ebx     ; 否则 num2 是更大值<br>check_num3:<br>    mov ebx, [num3]<br>    cmp eax, ebx<br>    jge done<br>    mov eax, ebx     ; 如果 num3 大，则更新 eax<br><br>done:<br>    mov edx, offset msgMax<br>    call WriteString<br>    call WriteInt<br>    call Crlf<br>    exit<br>main ENDP<br><br>end main<br></code></pre></td></tr></table></figure><h3 id="3-数组求和"><a href="#3-数组求和" class="headerlink" title="3. 数组求和"></a>3. <strong>数组求和</strong></h3><p>循环遍历数组并累加求和。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs asm">include Irvine32.inc<br><br>.data<br>arr dd 1, 2, 3, 4, 5<br>arrSize dd 5<br>msgSum db &quot;数组和是: &quot;, 0<br><br>.code<br>main PROC<br>    mov esi, offset arr<br>    mov ecx, [arrSize]<br>    xor eax, eax       ; 清空 eax 用于存储和<br><br>sum_loop:<br>    cmp ecx, 0<br>    je sum_done<br>    add eax, [esi]     ; 累加数组元素<br>    add esi, 4         ; 移动到下一个元素<br>    dec ecx<br>    jmp sum_loop<br><br>sum_done:<br>    mov edx, offset msgSum<br>    call WriteString<br>    call WriteInt<br>    call Crlf<br>    exit<br>main ENDP<br><br>end main<br></code></pre></td></tr></table></figure><h3 id="4-判断偶数或奇数"><a href="#4-判断偶数或奇数" class="headerlink" title="4. 判断偶数或奇数"></a>4. <strong>判断偶数或奇数</strong></h3><p>使用 <code>and</code> 或 <code>test</code> 指令判断一个数是偶数还是奇数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs asm">include Irvine32.inc<br><br>.data<br>num dd 42          ; 输入数字<br>msgEven db &quot;是偶数&quot;, 0<br>msgOdd db &quot;是奇数&quot;, 0<br><br>.code<br>main PROC<br>    mov eax, num<br>    test eax, 1         ; 判断最低位是否为 1<br>    jz eve             ; 如果为 0 是偶数<br><br>    mov edx, offset msgOdd<br>    call WriteString<br>    call Crlf<br>    jmp done<br><br>eve:<br>    mov edx, offset msgEven<br>    call WriteString<br>    call Crlf<br><br>done:<br>    exit<br>main ENDP<br><br>end main<br></code></pre></td></tr></table></figure><h3 id="5-输入-3-个整数并找出最小值"><a href="#5-输入-3-个整数并找出最小值" class="headerlink" title="5. 输入 3 个整数并找出最小值"></a>5. <strong>输入 3 个整数并找出最小值</strong></h3><p>使用 <code>ReadInt</code> 读取输入并比较找出最小值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs asm">include Irvine32.inc<br><br>.data<br>prompt1 db &quot;请输入第一个整数: &quot;, 0<br>prompt2 db &quot;请输入第二个整数: &quot;, 0<br>prompt3 db &quot;请输入第三个整数: &quot;, 0<br>msgMin db &quot;最小值是: &quot;, 0<br><br>num1 dd 0         ; 存储第一个整数<br>num2 dd 0         ; 存储第二个整数<br>num3 dd 0         ; 存储第三个整数<br><br>.code<br><br>main PROC<br>    ; 提示输入第一个整数<br>    mov edx, offset prompt1<br>    call WriteString<br>    call ReadInt<br>    mov num1, eax  ; 存储第一个整数<br><br>    ; 提示输入第二个整数<br>    mov edx, offset prompt2<br>    call WriteString<br>    call ReadInt<br>    mov num2, eax  ; 存储第二个整数<br><br>    ; 提示输入第三个整数<br>    mov edx, offset prompt3<br>    call WriteString<br>    call ReadInt<br>    mov num3, eax  ; 存储第三个整数<br><br>    ; 比较并找出最小值<br>    mov eax, num1  ; 将第一个整数加载到 eax<br>    mov ebx, num2  ; 将第二个整数加载到 ebx<br>    cmp eax, ebx     ; 比较 num1 和 num2<br>    jle next1        ; 如果 num1 &lt;= num2，跳到 next1<br>    mov eax, ebx     ; 否则，eax = num2<br><br>next1:<br>    mov ecx, num3  ; 将第三个整数加载到 ecx<br>    cmp eax, ecx     ; 比较当前的最小值和 num3<br>    jle done         ; 如果当前最小值 &lt;= num3，跳到 done<br>    mov eax, ecx     ; 否则，eax = num3<br><br>done:<br>    ; 输出最小值<br>    mov edx, offset msgMin<br>    call WriteString<br>    call WriteInt    ; 输出最小值<br>    call Crlf<br>    exit<br>main ENDP<br><br>end main<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 32位汇编语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 32位汇编语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>32位汇编指令速查表(MASM / x86)</title>
      <link href="/2025/04/07/32wei/02basics/"/>
      <url>/2025/04/07/32wei/02basics/</url>
      
        <content type="html"><![CDATA[<h3 id="📦-一、数据传送指令（MOV、XCHG-等）"><a href="#📦-一、数据传送指令（MOV、XCHG-等）" class="headerlink" title="📦 一、数据传送指令（MOV、XCHG 等）"></a>📦 一、数据传送指令（MOV、XCHG 等）</h3><table><thead><tr><th>指令</th><th>功能说明</th><th>示例</th></tr></thead><tbody><tr><td><code>mov</code></td><td>数据传送</td><td><code>mov eax, 100</code></td></tr><tr><td><code>movzx</code></td><td>零扩展传送（无符号）</td><td><code>movzx eax, byte ptr [esi]</code></td></tr><tr><td><code>movsx</code></td><td>符号扩展传送（有符号）</td><td><code>movsx eax, byte ptr [esi]</code></td></tr><tr><td><code>xchg</code></td><td>交换两个操作数的值</td><td><code>xchg eax, ebx</code></td></tr><tr><td><code>lea</code></td><td>取有效地址（地址计算）</td><td><code>lea eax, [ebx+4*esi]</code></td></tr><tr><td><code>offset</code></td><td>获取变量地址</td><td><code>mov edx, offset msg</code></td></tr></tbody></table><hr><h3 id="➕-二、算术运算指令"><a href="#➕-二、算术运算指令" class="headerlink" title="➕ 二、算术运算指令"></a>➕ 二、算术运算指令</h3><table><thead><tr><th>指令</th><th>功能说明</th><th>示例</th></tr></thead><tbody><tr><td><code>add</code></td><td>加法</td><td><code>add eax, 5</code></td></tr><tr><td><code>sub</code></td><td>减法</td><td><code>sub ebx, 2</code></td></tr><tr><td><code>inc</code></td><td>加 1</td><td><code>inc ecx</code></td></tr><tr><td><code>dec</code></td><td>减 1</td><td><code>dec ecx</code></td></tr><tr><td><code>imul</code></td><td>整数乘法</td><td><code>imul eax, ebx</code></td></tr><tr><td><code>idiv</code></td><td>有符号除法（注意 edx）</td><td><code>idiv ebx</code></td></tr><tr><td><code>neg</code></td><td>取负数（0 - eax）</td><td><code>neg eax</code></td></tr><tr><td><code>cdq</code></td><td>eax 扩展到 edx:eax</td><td><code>cdq</code>（除法前）</td></tr></tbody></table><hr><h3 id="🧮-三、逻辑与位运算"><a href="#🧮-三、逻辑与位运算" class="headerlink" title="🧮 三、逻辑与位运算"></a>🧮 三、逻辑与位运算</h3><table><thead><tr><th>指令</th><th>功能说明</th><th>示例</th></tr></thead><tbody><tr><td><code>and</code></td><td>按位与</td><td><code>and eax, 0Fh</code></td></tr><tr><td><code>or</code></td><td>按位或</td><td><code>or eax, 10h</code></td></tr><tr><td><code>xor</code></td><td>按位异或</td><td><code>xor eax, eax</code></td></tr><tr><td><code>not</code></td><td>按位取反</td><td><code>not eax</code></td></tr><tr><td><code>shl</code></td><td>左移（×2）</td><td><code>shl eax, 1</code></td></tr><tr><td><code>shr</code></td><td>右移（÷2）</td><td><code>shr eax, 1</code></td></tr><tr><td><code>sar</code></td><td>算术右移</td><td><code>sar eax, 1</code></td></tr></tbody></table><hr><h3 id="🔁-四、比较与跳转"><a href="#🔁-四、比较与跳转" class="headerlink" title="🔁 四、比较与跳转"></a>🔁 四、比较与跳转</h3><table><thead><tr><th>比较+跳转指令</th><th>功能说明</th><th>示例</th></tr></thead><tbody><tr><td><code>cmp</code></td><td>比较两个数</td><td><code>cmp eax, ebx</code></td></tr><tr><td><code>je</code> &#x2F; <code>jz</code></td><td>相等（等于0）跳转</td><td><code>je label</code></td></tr><tr><td><code>jne</code> &#x2F; <code>jnz</code></td><td>不等</td><td><code>jne label</code></td></tr><tr><td><code>jg</code> &#x2F; <code>jge</code></td><td>大于&#x2F;大于等于</td><td><code>jg label</code></td></tr><tr><td><code>jl</code> &#x2F; <code>jle</code></td><td>小于&#x2F;小于等于</td><td><code>jl label</code></td></tr><tr><td><code>ja</code></td><td>无符号大于</td><td><code>ja label</code></td></tr><tr><td><code>jb</code></td><td>无符号小于</td><td><code>jb label</code></td></tr><tr><td><code>jmp</code></td><td>无条件跳转</td><td><code>jmp label</code></td></tr><tr><td><code>loop</code></td><td>ecx–，不为 0 跳</td><td><code>loop label</code></td></tr></tbody></table><hr><h3 id="⏬-五、堆栈操作与子程序"><a href="#⏬-五、堆栈操作与子程序" class="headerlink" title="⏬ 五、堆栈操作与子程序"></a>⏬ 五、堆栈操作与子程序</h3><table><thead><tr><th>指令</th><th>功能说明</th><th>示例</th></tr></thead><tbody><tr><td><code>push</code></td><td>压栈</td><td><code>push eax</code></td></tr><tr><td><code>pop</code></td><td>出栈</td><td><code>pop eax</code></td></tr><tr><td><code>call</code></td><td>调用子程序</td><td><code>call printInt</code></td></tr><tr><td><code>ret</code></td><td>返回</td><td><code>ret 4</code></td></tr><tr><td><code>leave</code></td><td>恢复 ebp、esp 栈帧</td><td><code>leave</code></td></tr></tbody></table><hr><h3 id="📚-六、字符串处理指令（高阶用法）"><a href="#📚-六、字符串处理指令（高阶用法）" class="headerlink" title="📚 六、字符串处理指令（高阶用法）"></a>📚 六、字符串处理指令（高阶用法）</h3><table><thead><tr><th>指令</th><th>功能</th><th>要求设置寄存器</th></tr></thead><tbody><tr><td><code>movsb</code></td><td>拷贝字符串（字节）</td><td>esi, edi</td></tr><tr><td><code>stosd</code></td><td>存字符串到目的地</td><td>edi</td></tr><tr><td><code>lodsb</code></td><td>加载字符串到 al</td><td>esi</td></tr><tr><td><code>scasb</code></td><td>比较字符串字节</td><td>edi, al</td></tr></tbody></table><hr><h3 id="💻-七、Irvine32-特殊指令（宏-函数）"><a href="#💻-七、Irvine32-特殊指令（宏-函数）" class="headerlink" title="💻 七、Irvine32 特殊指令（宏&#x2F;函数）"></a>💻 七、Irvine32 特殊指令（宏&#x2F;函数）</h3><table><thead><tr><th>指令</th><th>功能</th></tr></thead><tbody><tr><td><code>call writeint</code></td><td>输出整数</td></tr><tr><td><code>call writestring</code></td><td>输出字符串</td></tr><tr><td><code>call readint</code></td><td>读取整数到 eax</td></tr><tr><td><code>call crlf</code></td><td>输出换行符</td></tr><tr><td><code>exit</code></td><td>程序退出（不能用 call）</td></tr></tbody></table><hr><h3 id="👀-八、常用伪指令"><a href="#👀-八、常用伪指令" class="headerlink" title="👀 八、常用伪指令"></a>👀 八、常用伪指令</h3><table><thead><tr><th>伪指令</th><th>功能</th></tr></thead><tbody><tr><td><code>include</code></td><td>包含其他文件（如 Irvine32）</td></tr><tr><td><code>.data</code></td><td>数据段开始</td></tr><tr><td><code>.code</code></td><td>代码段开始</td></tr><tr><td><code>proc</code></td><td>开始一个过程（函数）</td></tr><tr><td><code>endp</code></td><td>结束一个过程</td></tr><tr><td><code>end main</code></td><td>程序入口</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 32位汇编语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 32位汇编语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>32位汇编语言程序设计基础知识</title>
      <link href="/2025/04/07/32wei/01basics/"/>
      <url>/2025/04/07/32wei/01basics/</url>
      
        <content type="html"><![CDATA[<h2 id="🔰-第一章：汇编语言是什么？"><a href="#🔰-第一章：汇编语言是什么？" class="headerlink" title="🔰 第一章：汇编语言是什么？"></a>🔰 第一章：汇编语言是什么？</h2><h3 id="✅-汇编语言是："><a href="#✅-汇编语言是：" class="headerlink" title="✅ 汇编语言是："></a>✅ 汇编语言是：</h3><ul><li><strong>靠近计算机底层</strong>的语言</li><li>每一条汇编指令对应一个机器指令</li><li>更容易控制硬件，效率高，但书写复杂</li></ul><h3 id="✅-编写汇编程序需要："><a href="#✅-编写汇编程序需要：" class="headerlink" title="✅ 编写汇编程序需要："></a>✅ 编写汇编程序需要：</h3><ul><li><strong>汇编器</strong>：MASM（微软宏汇编器）</li><li><strong>Irvine32 库</strong>：老师常用的教学库（简化输入输出等操作）</li></ul><hr><h2 id="📁-第二章：汇编程序结构"><a href="#📁-第二章：汇编程序结构" class="headerlink" title="📁 第二章：汇编程序结构"></a>📁 第二章：汇编程序结构</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs asm">include irvine32.inc      ; 包含 Irvine32 的函数库<br><br>.data                     ; 数据段，定义变量<br>msg byte &quot;hello&quot;, 0<br><br>.code                     ; 代码段，写程序的地方<br>main proc                 ; main 是主过程入口<br>    mov edx, offset msg   ; 把字符串地址放入 edx<br>    call writestring      ; 调用写字符串的函数<br>    call crlf             ; 换行<br>    exit                  ; 正确退出程序（注意不是 call exit）<br>main endp<br><br>end main                  ; 程序结束，入口为 main<br></code></pre></td></tr></table></figure><hr><h2 id="🧱-第三章：常用寄存器解释（32-位）"><a href="#🧱-第三章：常用寄存器解释（32-位）" class="headerlink" title="🧱 第三章：常用寄存器解释（32 位）"></a>🧱 第三章：常用寄存器解释（32 位）</h2><table><thead><tr><th>寄存器</th><th>全名</th><th>作用</th></tr></thead><tbody><tr><td>eax</td><td>Accumulator</td><td>通用计算、返回值、常用</td></tr><tr><td>ebx</td><td>Base</td><td>通用变量寄存器</td></tr><tr><td>ecx</td><td>Counter</td><td>常用作计数器（循环）</td></tr><tr><td>edx</td><td>Data</td><td>数据相关、乘除法使用</td></tr><tr><td>esi</td><td>Source Index</td><td>源地址，数组遍历常用</td></tr><tr><td>edi</td><td>Destination</td><td>目标地址</td></tr><tr><td>ebp</td><td>Base Pointer</td><td>基址指针，访问参数使用</td></tr><tr><td>esp</td><td>Stack Pointer</td><td>栈顶指针</td></tr></tbody></table><hr><h2 id="🧾-第四章：变量定义和数据段"><a href="#🧾-第四章：变量定义和数据段" class="headerlink" title="🧾 第四章：变量定义和数据段"></a>🧾 第四章：变量定义和数据段</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asm">.data<br>num1   dword 100           ; 32位整数，初值100<br>arr    dword 10, 20, 30    ; 定义数组<br>msg    byte &quot;Hello&quot;, 0     ; 定义字符串（0表示结束）<br></code></pre></td></tr></table></figure><ul><li><code>dword</code>：定义一个 32 位整数</li><li><code>byte</code>：定义一个字节数据</li><li><code>offset</code>：用来获取变量的地址</li></ul><hr><h2 id="🔧-第五章：基本指令详解"><a href="#🔧-第五章：基本指令详解" class="headerlink" title="🔧 第五章：基本指令详解"></a>🔧 第五章：基本指令详解</h2><h3 id="✅-数据传送类"><a href="#✅-数据传送类" class="headerlink" title="✅ 数据传送类"></a>✅ 数据传送类</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asm">mov eax, 100           ; 把100送入 eax<br>mov ebx, eax           ; 把 eax 的值复制到 ebx<br>mov eax, [arr]         ; 读取 arr[0] 的值<br>mov [arr+4], ebx       ; 把 ebx 存入 arr[1]<br></code></pre></td></tr></table></figure><h3 id="✅-算术运算"><a href="#✅-算术运算" class="headerlink" title="✅ 算术运算"></a>✅ 算术运算</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asm">add eax, 5             ; eax = eax + 5<br>sub ebx, 1             ; ebx = ebx - 1<br>inc ecx                ; ecx++<br>dec ecx                ; ecx--<br>imul eax, ebx          ; eax = eax * ebx<br></code></pre></td></tr></table></figure><h3 id="✅-比较与跳转"><a href="#✅-比较与跳转" class="headerlink" title="✅ 比较与跳转"></a>✅ 比较与跳转</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asm">cmp eax, ebx           ; 比较 eax 和 ebx<br>je label               ; 如果相等跳转<br>jne label              ; 如果不等跳转<br>jl / jg / jle / jge    ; 小于/大于/小于等于/大于等于<br></code></pre></td></tr></table></figure><hr><h2 id="🔁-第六章：循环结构"><a href="#🔁-第六章：循环结构" class="headerlink" title="🔁 第六章：循环结构"></a>🔁 第六章：循环结构</h2><h3 id="示例：输出-1-到-5"><a href="#示例：输出-1-到-5" class="headerlink" title="示例：输出 1 到 5"></a>示例：输出 1 到 5</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs asm">mov ecx, 5<br>mov eax, 1<br>L1:<br>    call writeint<br>    call crlf<br>    inc eax<br>    loop L1            ; ecx = ecx - 1，如果不为0跳回<br></code></pre></td></tr></table></figure><hr><h2 id="📞-第七章：过程调用（函数）"><a href="#📞-第七章：过程调用（函数）" class="headerlink" title="📞 第七章：过程调用（函数）"></a>📞 第七章：过程调用（函数）</h2><h3 id="写法："><a href="#写法：" class="headerlink" title="写法："></a>写法：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs asm">main proc<br>    push 5<br>    call printNumber<br>    exit<br>main endp<br><br>printNumber proc<br>    push ebp<br>    mov ebp, esp<br>    mov eax, [ebp+8]    ; 取参数<br>    call writeint<br>    call crlf<br>    pop ebp<br>    ret 4               ; 参数一个，占 4 字节<br>printNumber endp<br></code></pre></td></tr></table></figure><hr><h2 id="📌-第八章：数组操作基础"><a href="#📌-第八章：数组操作基础" class="headerlink" title="📌 第八章：数组操作基础"></a>📌 第八章：数组操作基础</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs asm">.data<br>arr dword 5, 10, 15, 20<br><br>.code<br>mov esi, offset arr      ; esi = arr 地址<br>mov ecx, 4               ; 循环次数 = 元素个数<br>mov ebx, 0<br>loop_start:<br>    mov eax, [esi+ebx*4] ; eax = arr[ebx]<br>    call writeint<br>    call crlf<br>    inc ebx<br>    loop loop_start<br></code></pre></td></tr></table></figure><hr><h2 id="🔚-第九章：正确退出程序"><a href="#🔚-第九章：正确退出程序" class="headerlink" title="🔚 第九章：正确退出程序"></a>🔚 第九章：正确退出程序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asm">exit         ; 这是宏，写在 main 的最后<br></code></pre></td></tr></table></figure><p>🚫 <strong>不要写</strong> <code>call exit</code>，那是错误用法！</p><hr><h2 id="✅-第十章：用-Irvine32-输入输出"><a href="#✅-第十章：用-Irvine32-输入输出" class="headerlink" title="✅ 第十章：用 Irvine32 输入输出"></a>✅ 第十章：用 Irvine32 输入输出</h2><table><thead><tr><th>功能</th><th>使用方法</th></tr></thead><tbody><tr><td>输出整数</td><td><code>mov eax, num</code> + <code>call writeint</code></td></tr><tr><td>输入整数</td><td><code>call readint</code> → <code>eax</code>中返回值</td></tr><tr><td>输出字符串</td><td><code>mov edx, offset msg</code> + <code>call writestring</code></td></tr><tr><td>换行</td><td><code>call crlf</code></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 32位汇编语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 32位汇编语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态代理</title>
      <link href="/2025/04/05/javaBasics/7.4%20%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
      <url>/2025/04/05/javaBasics/7.4%20%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="✅-动态代理"><a href="#✅-动态代理" class="headerlink" title="✅ 动态代理"></a>✅ 动态代理</h2><p><strong>动态代理</strong> 是在程序运行时创建代理对象，不需要提前写好代理类代码。</p><blockquote><p>✅ 本质：用反射机制，在运行时生成代理对象，代理目标对象的方法调用。</p></blockquote><hr><h2 id="✅-动态代理-vs-静态代理"><a href="#✅-动态代理-vs-静态代理" class="headerlink" title="✅ 动态代理 vs 静态代理"></a>✅ 动态代理 vs 静态代理</h2><table><thead><tr><th>特性</th><th>静态代理</th><th>动态代理</th></tr></thead><tbody><tr><td>编写方式</td><td>手动编写代理类</td><td>运行时自动生成代理类</td></tr><tr><td>灵活性</td><td>不够灵活，一个接口一个代理类</td><td>很灵活，只需一套代理逻辑</td></tr><tr><td>使用场景</td><td>小项目、学习</td><td>Spring AOP、事务、权限校验等</td></tr><tr><td>性能</td><td>性能好</td><td>性能略低（但可接受）</td></tr></tbody></table><hr><h2 id="✅-动态代理的使用前提"><a href="#✅-动态代理的使用前提" class="headerlink" title="✅ 动态代理的使用前提"></a>✅ 动态代理的使用前提</h2><blockquote><p><strong>必须基于接口编程！</strong></p></blockquote><p>目标对象要实现一个或多个接口，代理对象也实现这些接口。</p><hr><h2 id="✅-动态代理的基本结构（JDK-实现）"><a href="#✅-动态代理的基本结构（JDK-实现）" class="headerlink" title="✅ 动态代理的基本结构（JDK 实现）"></a>✅ 动态代理的基本结构（JDK 实现）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1. 定义接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserService</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">login</span><span class="hljs-params">(String username)</span>;<br>&#125;<br><br><span class="hljs-comment">// 2. 实现类（目标对象）</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserService</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">login</span><span class="hljs-params">(String username)</span> &#123;<br>        System.out.println(username + <span class="hljs-string">&quot; 登录成功！&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="✅-创建动态代理对象"><a href="#✅-创建动态代理对象" class="headerlink" title="✅ 创建动态代理对象"></a>✅ 创建动态代理对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.reflect.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProxyFactory</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">getProxy</span><span class="hljs-params">(Object target)</span> &#123;<br>        <span class="hljs-keyword">return</span> Proxy.newProxyInstance(<br>            target.getClass().getClassLoader(),    <span class="hljs-comment">// 类加载器</span><br>            target.getClass().getInterfaces(),     <span class="hljs-comment">// 接口数组</span><br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvocationHandler</span>() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>                    <span class="hljs-comment">// 前置增强</span><br>                    System.out.println(<span class="hljs-string">&quot;日志：方法开始执行...&quot;</span>);<br>                    <br>                    <span class="hljs-comment">// 调用目标方法</span><br>                    <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> method.invoke(target, args);<br>                    <br>                    <span class="hljs-comment">// 后置增强</span><br>                    System.out.println(<span class="hljs-string">&quot;日志：方法执行完毕。&quot;</span>);<br>                    <span class="hljs-keyword">return</span> result;<br>                &#125;<br>            &#125;<br>        );<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="✅-测试使用动态代理"><a href="#✅-测试使用动态代理" class="headerlink" title="✅ 测试使用动态代理"></a>✅ 测试使用动态代理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">UserService</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserServiceImpl</span>(); <span class="hljs-comment">// 目标对象</span><br>        <span class="hljs-type">UserService</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> (UserService) ProxyFactory.getProxy(target); <span class="hljs-comment">// 获取代理对象</span><br><br>        proxy.login(<span class="hljs-string">&quot;张三&quot;</span>); <span class="hljs-comment">// 实际调用的是代理对象的方法</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="✅-输出结果"><a href="#✅-输出结果" class="headerlink" title="✅ 输出结果"></a>✅ 输出结果</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">日志：方法开始执行...<br>张三 登录成功！<br>日志：方法执行完毕。<br></code></pre></td></tr></table></figure><hr><h2 id="✅-总结动态代理核心知识点"><a href="#✅-总结动态代理核心知识点" class="headerlink" title="✅ 总结动态代理核心知识点"></a>✅ 总结动态代理核心知识点</h2><table><thead><tr><th>内容</th><th>说明</th></tr></thead><tbody><tr><td>关键类</td><td><code>java.lang.reflect.Proxy</code></td></tr><tr><td>接口</td><td>目标对象必须实现接口</td></tr><tr><td>回调</td><td>使用 <code>InvocationHandler</code> 实现调用逻辑</td></tr><tr><td>方法</td><td><code>invoke()</code> 拦截所有接口方法调用</td></tr></tbody></table><hr><h2 id="✅-动态代理常见应用场景"><a href="#✅-动态代理常见应用场景" class="headerlink" title="✅ 动态代理常见应用场景"></a>✅ 动态代理常见应用场景</h2><ul><li>Spring AOP 切面（如：事务、日志、安全控制）</li><li>RPC 框架远程方法调用</li><li>JDK 和 MyBatis 的代理机制</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高级技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>注解</title>
      <link href="/2025/04/05/javaBasics/7.3%20%E6%B3%A8%E8%A7%A3/"/>
      <url>/2025/04/05/javaBasics/7.3%20%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="✅-注解（Annotation）"><a href="#✅-注解（Annotation）" class="headerlink" title="✅ 注解（Annotation）"></a>✅ 注解（Annotation）</h2><p><strong>注解</strong> 是 Java 5 引入的一种语法，用来为程序中的元素（类、方法、变量等）添加元信息（描述信息），不会影响程序逻辑。</p><blockquote><p>✅ 本质：注解是代码的“说明标签”，可以被编译器或框架读取并处理。</p></blockquote><hr><h2 id="✅-注解的作用"><a href="#✅-注解的作用" class="headerlink" title="✅ 注解的作用"></a>✅ 注解的作用</h2><table><thead><tr><th>作用</th><th>举例</th></tr></thead><tbody><tr><td>编译检查</td><td>如 <code>@Override</code> 提醒方法是重写父类方法</td></tr><tr><td>文档生成</td><td><code>@author</code>、<code>@version</code></td></tr><tr><td>运行时反射处理</td><td>如 <code>@Test</code>、<code>@Controller</code> 等</td></tr><tr><td>配合框架使用</td><td>Spring、Junit、MyBatis 广泛使用注解</td></tr></tbody></table><hr><h2 id="✅-常用内置注解（Java-自带）"><a href="#✅-常用内置注解（Java-自带）" class="headerlink" title="✅ 常用内置注解（Java 自带）"></a>✅ 常用内置注解（Java 自带）</h2><table><thead><tr><th>注解名</th><th>说明</th></tr></thead><tbody><tr><td><code>@Override</code></td><td>重写父类方法</td></tr><tr><td><code>@Deprecated</code></td><td>标记方法已过时</td></tr><tr><td><code>@SuppressWarnings</code></td><td>忽略警告，例如泛型警告</td></tr></tbody></table><h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;重写了 Object 的 toString 方法&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="✅-自定义注解"><a href="#✅-自定义注解" class="headerlink" title="✅ 自定义注解"></a>✅ 自定义注解</h2><h3 id="✨-语法格式："><a href="#✨-语法格式：" class="headerlink" title="✨ 语法格式："></a>✨ 语法格式：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> 注解名 &#123;<br>    数据类型 属性名() <span class="hljs-keyword">default</span> 默认值;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="示例：定义一个注解-MyAnnotation"><a href="#示例：定义一个注解-MyAnnotation" class="headerlink" title="示例：定义一个注解 @MyAnnotation"></a>示例：定义一个注解 <code>@MyAnnotation</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> MyAnnotation &#123;<br>    String <span class="hljs-title function_">value</span><span class="hljs-params">()</span>; <span class="hljs-comment">// 属性</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">age</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-number">18</span>; <span class="hljs-comment">// 有默认值</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="使用注解："><a href="#使用注解：" class="headerlink" title="使用注解："></a>使用注解：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@MyAnnotation(value = &quot;张三&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="✅-注解的元注解（给注解加注解）"><a href="#✅-注解的元注解（给注解加注解）" class="headerlink" title="✅ 注解的元注解（给注解加注解）"></a>✅ 注解的元注解（给注解加注解）</h2><table><thead><tr><th>注解名</th><th>作用</th></tr></thead><tbody><tr><td><code>@Target</code></td><td>限定注解能用在哪（类、方法、属性等）</td></tr><tr><td><code>@Retention</code></td><td>限定注解的生命周期（源码 &#x2F; 编译 &#x2F; 运行）</td></tr><tr><td><code>@Documented</code></td><td>是否生成到 JavaDoc</td></tr><tr><td><code>@Inherited</code></td><td>子类是否能继承父类的注解</td></tr></tbody></table><h3 id="示例：常见组合"><a href="#示例：常见组合" class="headerlink" title="示例：常见组合"></a>示例：常见组合</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.annotation.*;<br><br><span class="hljs-meta">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span> <span class="hljs-comment">// 用于类和方法</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span>             <span class="hljs-comment">// 运行时保留，支持反射读取</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> MyAnnotation &#123;<br>    String <span class="hljs-title function_">value</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="✅-结合反射读取注解（常考）"><a href="#✅-结合反射读取注解（常考）" class="headerlink" title="✅ 结合反射读取注解（常考）"></a>✅ 结合反射读取注解（常考）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@MyAnnotation(value = &quot;测试注解&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        Class&lt;?&gt; cls = Class.forName(<span class="hljs-string">&quot;Demo&quot;</span>);<br>        <span class="hljs-keyword">if</span> (cls.isAnnotationPresent(MyAnnotation.class)) &#123;<br>            <span class="hljs-type">MyAnnotation</span> <span class="hljs-variable">an</span> <span class="hljs-operator">=</span> cls.getAnnotation(MyAnnotation.class);<br>            System.out.println(<span class="hljs-string">&quot;注解的值：&quot;</span> + an.value());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="✅-注解-vs-接口-vs-配置文件"><a href="#✅-注解-vs-接口-vs-配置文件" class="headerlink" title="✅ 注解 vs 接口 vs 配置文件"></a>✅ 注解 vs 接口 vs 配置文件</h2><table><thead><tr><th>特性</th><th>注解</th><th>接口</th><th>配置文件</th></tr></thead><tbody><tr><td>编译检查</td><td>✅</td><td>✅</td><td>❌</td></tr><tr><td>可读性强</td><td>✅</td><td>✅</td><td>✅</td></tr><tr><td>动态灵活</td><td>✅</td><td>❌</td><td>✅</td></tr><tr><td>易维护</td><td>✅</td><td>❌</td><td>✅</td></tr></tbody></table><hr><h2 id="✅-注解使用场景"><a href="#✅-注解使用场景" class="headerlink" title="✅ 注解使用场景"></a>✅ 注解使用场景</h2><ul><li>✅ 框架开发（Spring、MyBatis、JPA）</li><li>✅ 编写测试（JUnit）</li><li>✅ 权限控制、日志记录（AOP）</li><li>✅ 注解处理器生成代码（如 Lombok）</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高级技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反射</title>
      <link href="/2025/04/05/javaBasics/7.2%20%E5%8F%8D%E5%B0%84/"/>
      <url>/2025/04/05/javaBasics/7.2%20%E5%8F%8D%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<h2 id="✅-反射（Reflection）"><a href="#✅-反射（Reflection）" class="headerlink" title="✅ 反射（Reflection）"></a>✅ 反射（Reflection）</h2><p><strong>反射</strong> 是 Java 提供的一种机制，可以在运行时动态获取类的信息、构造对象、调用方法、访问字段等。</p><blockquote><p>✅ 通俗理解：反射就像“开外挂”，让你在运行时访问类的结构（包括私有的），甚至可以动态操作！</p></blockquote><hr><h2 id="✅-反射能干什么？"><a href="#✅-反射能干什么？" class="headerlink" title="✅ 反射能干什么？"></a>✅ 反射能干什么？</h2><table><thead><tr><th>功能</th><th>举例说明</th></tr></thead><tbody><tr><td>获取类的对象</td><td><code>Class cls = Class.forName(&quot;类的全路径&quot;);</code></td></tr><tr><td>创建对象</td><td><code>Object obj = cls.newInstance();</code></td></tr><tr><td>获取字段&#x2F;方法&#x2F;构造器</td><td><code>Field</code>、<code>Method</code>、<code>Constructor</code></td></tr><tr><td>访问私有成员</td><td>通过 <code>setAccessible(true)</code> 绕过访问控制</td></tr><tr><td>调用方法</td><td><code>method.invoke(obj, 参数);</code></td></tr></tbody></table><hr><h2 id="✅-获取-Class-对象的三种方式"><a href="#✅-获取-Class-对象的三种方式" class="headerlink" title="✅ 获取 Class 对象的三种方式"></a>✅ 获取 Class 对象的三种方式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1. 类名.class</span><br>Class&lt;?&gt; cls1 = String.class;<br><br><span class="hljs-comment">// 2. 对象.getClass()</span><br><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello&quot;</span>;<br>Class&lt;?&gt; cls2 = str.getClass();<br><br><span class="hljs-comment">// 3. Class.forName(&quot;全类名&quot;)</span><br>Class&lt;?&gt; cls3 = Class.forName(<span class="hljs-string">&quot;java.lang.String&quot;</span>);<br></code></pre></td></tr></table></figure><hr><h2 id="✅-示例：使用反射调用方法"><a href="#✅-示例：使用反射调用方法" class="headerlink" title="✅ 示例：使用反射调用方法"></a>✅ 示例：使用反射调用方法</h2><h3 id="目标类："><a href="#目标类：" class="headerlink" title="目标类："></a>目标类：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;张三&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHello</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Hello, I am &quot;</span> + name);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="反射调用："><a href="#反射调用：" class="headerlink" title="反射调用："></a>反射调用：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReflectTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 1. 获取 Class 对象</span><br>        Class&lt;?&gt; cls = Class.forName(<span class="hljs-string">&quot;Person&quot;</span>);<br><br>        <span class="hljs-comment">// 2. 创建对象</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> cls.newInstance(); <span class="hljs-comment">// 等价于 new Person()</span><br><br>        <span class="hljs-comment">// 3. 获取方法</span><br>        <span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> cls.getMethod(<span class="hljs-string">&quot;sayHello&quot;</span>);<br><br>        <span class="hljs-comment">// 4. 调用方法</span><br>        method.invoke(obj);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="✅-访问私有属性"><a href="#✅-访问私有属性" class="headerlink" title="✅ 访问私有属性"></a>✅ 访问私有属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReflectFieldTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        Class&lt;?&gt; cls = Class.forName(<span class="hljs-string">&quot;Person&quot;</span>);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> cls.newInstance();<br><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">nameField</span> <span class="hljs-operator">=</span> cls.getDeclaredField(<span class="hljs-string">&quot;name&quot;</span>);<br>        nameField.setAccessible(<span class="hljs-literal">true</span>); <span class="hljs-comment">// 打破私有访问限制</span><br>        nameField.set(obj, <span class="hljs-string">&quot;李四&quot;</span>);<br><br>        <span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> cls.getMethod(<span class="hljs-string">&quot;sayHello&quot;</span>);<br>        method.invoke(obj); <span class="hljs-comment">// 输出：Hello, I am 李四</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="✅-常用类"><a href="#✅-常用类" class="headerlink" title="✅ 常用类"></a>✅ 常用类</h2><table><thead><tr><th>类名</th><th>功能</th></tr></thead><tbody><tr><td><code>Class</code></td><td>表示类的字节码</td></tr><tr><td><code>Field</code></td><td>表示成员变量</td></tr><tr><td><code>Method</code></td><td>表示成员方法</td></tr><tr><td><code>Constructor</code></td><td>表示构造方法</td></tr></tbody></table><hr><h2 id="✅-反射的优缺点"><a href="#✅-反射的优缺点" class="headerlink" title="✅ 反射的优缺点"></a>✅ 反射的优缺点</h2><table><thead><tr><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>灵活、动态</td><td>效率低（反射开销大）</td></tr><tr><td>可以访问私有成员</td><td>安全性较差</td></tr><tr><td>常用于框架、工具开发</td><td>不建议频繁使用</td></tr></tbody></table><hr><h2 id="✅-应用场景"><a href="#✅-应用场景" class="headerlink" title="✅ 应用场景"></a>✅ 应用场景</h2><ul><li>Java 框架（Spring、Hibernate 等）</li><li>工具类（如 BeanUtils）</li><li>动态加载类、插件系统</li><li>序列化、反序列化</li><li>注解处理器</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高级技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Junit单元测试</title>
      <link href="/2025/04/05/javaBasics/7.1%20Junit%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
      <url>/2025/04/05/javaBasics/7.1%20Junit%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h2 id="✅-JUnit-单元测试（Java）"><a href="#✅-JUnit-单元测试（Java）" class="headerlink" title="✅ JUnit 单元测试（Java）"></a>✅ JUnit 单元测试（Java）</h2><p><strong>JUnit</strong> 是 Java 中最常用的单元测试框架，用于对 Java 方法的功能进行自动化测试，提高开发效率和代码质量。</p><hr><h2 id="✅-基本概念"><a href="#✅-基本概念" class="headerlink" title="✅ 基本概念"></a>✅ 基本概念</h2><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>单元测试（Unit Test）</td><td>针对程序中最小功能单元（如方法）进行的测试</td></tr><tr><td>JUnit</td><td>Java 编程语言的单元测试框架，目前主流版本为 JUnit 4 和 JUnit 5</td></tr><tr><td>测试用例</td><td>编写好的测试方法，用来验证业务方法是否正确</td></tr><tr><td>断言（assert）</td><td>检查预期结果和实际结果是否一致，决定测试是否通过</td></tr></tbody></table><hr><h2 id="✅-JUnit-测试的基本步骤"><a href="#✅-JUnit-测试的基本步骤" class="headerlink" title="✅ JUnit 测试的基本步骤"></a>✅ JUnit 测试的基本步骤</h2><h3 id="1️⃣-添加-JUnit-依赖（以-JUnit-4-为例）"><a href="#1️⃣-添加-JUnit-依赖（以-JUnit-4-为例）" class="headerlink" title="1️⃣ 添加 JUnit 依赖（以 JUnit 4 为例）"></a>1️⃣ 添加 JUnit 依赖（以 JUnit 4 为例）</h3><h4 id="👉-如果你是使用-Maven-的项目："><a href="#👉-如果你是使用-Maven-的项目：" class="headerlink" title="👉 如果你是使用 Maven 的项目："></a>👉 如果你是使用 Maven 的项目：</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.13.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><h3 id="2️⃣-编写待测试的代码（业务类）"><a href="#2️⃣-编写待测试的代码（业务类）" class="headerlink" title="2️⃣ 编写待测试的代码（业务类）"></a>2️⃣ 编写待测试的代码（业务类）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Calculator</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>        <span class="hljs-keyword">return</span> a + b;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sub</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>        <span class="hljs-keyword">return</span> a - b;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="3️⃣-编写测试类（测试用例）"><a href="#3️⃣-编写测试类（测试用例）" class="headerlink" title="3️⃣ 编写测试类（测试用例）"></a>3️⃣ 编写测试类（测试用例）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.junit.Test;<br><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> org.junit.Assert.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CalculatorTest</span> &#123;<br><br>    <span class="hljs-meta">@Test</span> <span class="hljs-comment">// 标记这是一个测试方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testAdd</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Calculator</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Calculator</span>();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> c.add(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>);<br>        assertEquals(<span class="hljs-number">30</span>, result); <span class="hljs-comment">// 断言判断：预期值 vs 实际值</span><br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSub</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Calculator</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Calculator</span>();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> c.sub(<span class="hljs-number">10</span>, <span class="hljs-number">5</span>);<br>        assertEquals(<span class="hljs-number">5</span>, result);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="✅-常用断言方法（assert）"><a href="#✅-常用断言方法（assert）" class="headerlink" title="✅ 常用断言方法（assert）"></a>✅ 常用断言方法（assert）</h2><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td><code>assertEquals(a, b)</code></td><td>判断两个值是否相等</td></tr><tr><td><code>assertTrue(condition)</code></td><td>判断条件为 <code>true</code></td></tr><tr><td><code>assertFalse(condition)</code></td><td>判断条件为 <code>false</code></td></tr><tr><td><code>assertNull(obj)</code></td><td>判断对象为 <code>null</code></td></tr><tr><td><code>assertNotNull(obj)</code></td><td>判断对象不为 <code>null</code></td></tr></tbody></table><hr><h2 id="✅-测试运行结果说明"><a href="#✅-测试运行结果说明" class="headerlink" title="✅ 测试运行结果说明"></a>✅ 测试运行结果说明</h2><ul><li>✅ <strong>绿色条</strong>：测试通过</li><li>❌ <strong>红色条</strong>：测试失败，断言不成立或抛出异常</li><li>报错信息会指出是哪个测试方法失败，并显示期望值和实际值</li></ul><hr><h2 id="✅-小贴士"><a href="#✅-小贴士" class="headerlink" title="✅ 小贴士"></a>✅ 小贴士</h2><ul><li>JUnit 测试类通常和被测试类放在不同的目录中（如 <code>src/main/java</code> 和 <code>src/test/java</code>）</li><li>每个测试方法都应该是 <code>public void</code>，并用 <code>@Test</code> 注解标记</li><li>测试方法名最好有描述性，如 <code>testAddWithPositiveNumbers</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高级技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP详解</title>
      <link href="/2025/04/04/javaBasics/6.2.3%20TCP%E8%AF%A6%E8%A7%A3/"/>
      <url>/2025/04/04/javaBasics/6.2.3%20TCP%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="✅-什么是-TCP-协议？"><a href="#✅-什么是-TCP-协议？" class="headerlink" title="✅ 什么是 TCP 协议？"></a>✅ 什么是 TCP 协议？</h2><p><strong>TCP（传输控制协议）</strong> 是一种<strong>面向连接、可靠传输、基于字节流</strong>的通信协议。</p><blockquote><p>📦 简单理解：打电话前要先拨号（建立连接），通话中对方要回应（确认），最后挂电话（断开连接），这就是 TCP 的行为风格！</p></blockquote><hr><h2 id="✅-TCP-的特点"><a href="#✅-TCP-的特点" class="headerlink" title="✅ TCP 的特点"></a>✅ TCP 的特点</h2><table><thead><tr><th>特点</th><th>说明</th></tr></thead><tbody><tr><td>面向连接</td><td>通信前必须建立连接（三次握手）</td></tr><tr><td>可靠传输</td><td>保证数据正确、无误、无重复地到达</td></tr><tr><td>有序传输</td><td>按照发送顺序到达（使用序号）</td></tr><tr><td>双向通信</td><td>全双工，双方都可以发送&#x2F;接收</td></tr><tr><td>基于字节流</td><td>传输是连续的字节流，而非分包发送</td></tr></tbody></table><hr><h2 id="✅-TCP-工作流程"><a href="#✅-TCP-工作流程" class="headerlink" title="✅ TCP 工作流程"></a>✅ TCP 工作流程</h2><h3 id="1️⃣-建立连接（三次握手）"><a href="#1️⃣-建立连接（三次握手）" class="headerlink" title="1️⃣ 建立连接（三次握手）"></a>1️⃣ 建立连接（三次握手）</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">客户端       服务端<br>  |  ---SYN---&gt;   |   第一次握手：客户端发起连接请求<br>  |  &lt;---SYN+ACK |   第二次握手：服务端响应连接请求<br>  |  ---ACK----&gt;  |   第三次握手：客户端确认，连接建立成功<br></code></pre></td></tr></table></figure><p>✅ 建立完连接后，客户端和服务端就可以开始数据传输了。</p><hr><h3 id="2️⃣-数据传输"><a href="#2️⃣-数据传输" class="headerlink" title="2️⃣ 数据传输"></a>2️⃣ 数据传输</h3><ul><li>使用 <strong>序列号（Sequence Number）</strong> 和 <strong>确认号（ACK）</strong> 来保证数据可靠和有序。</li><li>如果数据丢失或出错，会自动 <strong>重传</strong>。</li><li>每次发送的数据都有编号，接收方必须回 ACK。</li></ul><hr><h3 id="3️⃣-断开连接（四次挥手）"><a href="#3️⃣-断开连接（四次挥手）" class="headerlink" title="3️⃣ 断开连接（四次挥手）"></a>3️⃣ 断开连接（四次挥手）</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">客户端       服务端<br>  | ---FIN----&gt;   | 第一次挥手：客户端请求断开连接<br>  | &lt;---ACK-----  | 第二次挥手：服务端确认<br>  | &lt;---FIN-----  | 第三次挥手：服务端也请求断开<br>  | ---ACK----&gt;   | 第四次挥手：客户端确认，断开成功<br></code></pre></td></tr></table></figure><hr><h2 id="✅-Java-中使用-TCP-通信（Socket）"><a href="#✅-Java-中使用-TCP-通信（Socket）" class="headerlink" title="✅ Java 中使用 TCP 通信（Socket）"></a>✅ Java 中使用 TCP 通信（Socket）</h2><h3 id="☑️-服务端代码"><a href="#☑️-服务端代码" class="headerlink" title="☑️ 服务端代码"></a>☑️ 服务端代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> java.net.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TCPServer</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">ServerSocket</span> <span class="hljs-variable">serverSocket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(<span class="hljs-number">8888</span>);<br>        System.out.println(<span class="hljs-string">&quot;服务器启动，等待连接...&quot;</span>);<br><br>        <span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> serverSocket.accept(); <span class="hljs-comment">// 等待客户端连接</span><br>        System.out.println(<span class="hljs-string">&quot;客户端已连接！&quot;</span>);<br><br>        <span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> socket.getInputStream();<br>        <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(is));<br>        <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> reader.readLine();<br>        System.out.println(<span class="hljs-string">&quot;收到客户端消息：&quot;</span> + msg);<br><br>        socket.close();<br>        serverSocket.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="☑️-客户端代码"><a href="#☑️-客户端代码" class="headerlink" title="☑️ 客户端代码"></a>☑️ 客户端代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> java.net.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TCPClient</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Socket</span>(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8888</span>);<br><br>        <span class="hljs-type">OutputStream</span> <span class="hljs-variable">os</span> <span class="hljs-operator">=</span> socket.getOutputStream();<br>        <span class="hljs-type">PrintWriter</span> <span class="hljs-variable">writer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintWriter</span>(os);<br>        writer.println(<span class="hljs-string">&quot;Hello, TCP Server!&quot;</span>);<br>        writer.flush();<br><br>        socket.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="✅-TCP-vs-UDP-对比"><a href="#✅-TCP-vs-UDP-对比" class="headerlink" title="✅ TCP vs UDP 对比"></a>✅ TCP vs UDP 对比</h2><table><thead><tr><th>特性</th><th>TCP</th><th>UDP</th></tr></thead><tbody><tr><td>连接方式</td><td>面向连接（三次握手）</td><td>无连接</td></tr><tr><td>可靠性</td><td>可靠（丢包会重传）</td><td>不可靠（可能丢包）</td></tr><tr><td>传输顺序</td><td>保证顺序</td><td>不保证顺序</td></tr><tr><td>速度</td><td>慢（需要握手确认）</td><td>快（无需连接）</td></tr><tr><td>使用场景</td><td>文件传输、HTTP、邮件等</td><td>视频直播、语音通话、游戏等</td></tr></tbody></table><hr><h2 id="✅-总结"><a href="#✅-总结" class="headerlink" title="✅ 总结"></a>✅ 总结</h2><table><thead><tr><th>点</th><th>描述</th></tr></thead><tbody><tr><td>是否可靠</td><td>✅ 是（确认 + 重传 + 编号）</td></tr><tr><td>是否连接</td><td>✅ 是（通过三次握手）</td></tr><tr><td>使用方式</td><td>使用 <code>Socket</code> 和 <code>ServerSocket</code> 实现</td></tr><tr><td>应用场景</td><td>文件传输、Web 通信、数据库连接等</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UDP详解</title>
      <link href="/2025/04/04/javaBasics/6.2.2%20UDP%E8%AF%A6%E8%A7%A3/"/>
      <url>/2025/04/04/javaBasics/6.2.2%20UDP%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="✅什么是UDP协议"><a href="#✅什么是UDP协议" class="headerlink" title="✅什么是UDP协议"></a>✅什么是UDP协议</h2><p><strong>UDP（用户数据报协议）</strong> 是一种简单、高效的无连接传输协议，位于 <strong>OSI 模型的第四层（传输层）</strong>。与 <strong>TCP</strong> 相比，它不提供复杂的可靠机制，因此速度更快，延迟更低，常用于音视频、游戏等对时效性要求较高的场景。</p><hr><h2 id="✅-1️⃣-UDP-的基本特点"><a href="#✅-1️⃣-UDP-的基本特点" class="headerlink" title="✅ 1️⃣ UDP 的基本特点"></a>✅ <strong>1️⃣ UDP 的基本特点</strong></h2><table><thead><tr><th>特性</th><th>描述</th></tr></thead><tbody><tr><td><strong>无连接</strong></td><td>发送数据前不建立连接，直接发送数据</td></tr><tr><td><strong>不可靠性</strong></td><td>不保证数据是否成功送达，也不保证顺序和完整性</td></tr><tr><td><strong>数据报协议</strong></td><td>将数据封装为数据报（Datagram）独立发送，每个报文独立处理</td></tr><tr><td><strong>速度快</strong></td><td>无需建立连接和确认应答，效率高，适用于高实时性场景</td></tr><tr><td><strong>轻量协议</strong></td><td>协议头开销小（仅 8 字节），不做流量控制和拥塞控制</td></tr><tr><td><strong>广播&#x2F;多播支持</strong></td><td>支持局域网内广播和组播，是 TCP 不具备的能力</td></tr></tbody></table><hr><h2 id="✅-2️⃣-UDP-报文结构"><a href="#✅-2️⃣-UDP-报文结构" class="headerlink" title="✅ 2️⃣ UDP 报文结构"></a>✅ <strong>2️⃣ UDP 报文结构</strong></h2><p>UDP 报文格式如下（共 8 字节）：</p><table><thead><tr><th>字段名称</th><th>长度（字节）</th><th>说明</th></tr></thead><tbody><tr><td>源端口</td><td>2</td><td>发送方端口号</td></tr><tr><td>目标端口</td><td>2</td><td>接收方端口号</td></tr><tr><td>长度</td><td>2</td><td>整个 UDP 报文的长度（含头部）</td></tr><tr><td>校验和</td><td>2</td><td>可选，用于错误检测</td></tr></tbody></table><hr><h2 id="✅-3️⃣-Java-中的-UDP-编程"><a href="#✅-3️⃣-Java-中的-UDP-编程" class="headerlink" title="✅ 3️⃣ Java 中的 UDP 编程"></a>✅ <strong>3️⃣ Java 中的 UDP 编程</strong></h2><p>Java 提供了 <code>DatagramSocket</code> 和 <code>DatagramPacket</code> 两个类来支持 UDP 通信。</p><hr><h3 id="🔹-发送端代码示例"><a href="#🔹-发送端代码示例" class="headerlink" title="🔹 发送端代码示例"></a>🔹 <strong>发送端代码示例</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.net.DatagramPacket;<br><span class="hljs-keyword">import</span> java.net.DatagramSocket;<br><span class="hljs-keyword">import</span> java.net.InetAddress;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UDPSender</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 1. 创建发送端Socket对象</span><br>        <span class="hljs-type">DatagramSocket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramSocket</span>();<br><br>        <span class="hljs-comment">// 2. 创建数据包（DatagramPacket）</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;你好，UDP！&quot;</span>;<br>        <span class="hljs-type">byte</span>[] data = msg.getBytes();<br>        <span class="hljs-type">InetAddress</span> <span class="hljs-variable">ip</span> <span class="hljs-operator">=</span> InetAddress.getByName(<span class="hljs-string">&quot;localhost&quot;</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">port</span> <span class="hljs-operator">=</span> <span class="hljs-number">8888</span>;<br>        <span class="hljs-type">DatagramPacket</span> <span class="hljs-variable">packet</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramPacket</span>(data, data.length, ip, port);<br><br>        <span class="hljs-comment">// 3. 发送数据</span><br>        socket.send(packet);<br><br>        <span class="hljs-comment">// 4. 释放资源</span><br>        socket.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="🔹-接收端代码示例"><a href="#🔹-接收端代码示例" class="headerlink" title="🔹 接收端代码示例"></a>🔹 <strong>接收端代码示例</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.net.DatagramPacket;<br><span class="hljs-keyword">import</span> java.net.DatagramSocket;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UDPReceiver</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 1. 创建接收端Socket并绑定端口</span><br>        <span class="hljs-type">DatagramSocket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramSocket</span>(<span class="hljs-number">8888</span>);<br><br>        <span class="hljs-comment">// 2. 创建接收数据包</span><br>        <span class="hljs-type">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br>        <span class="hljs-type">DatagramPacket</span> <span class="hljs-variable">packet</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramPacket</span>(buffer, buffer.length);<br><br>        <span class="hljs-comment">// 3. 接收数据（阻塞式）</span><br>        socket.receive(packet);<br><br>        <span class="hljs-comment">// 4. 解析数据</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">received</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(packet.getData(), <span class="hljs-number">0</span>, packet.getLength());<br>        System.out.println(<span class="hljs-string">&quot;接收到消息：&quot;</span> + received);<br><br>        <span class="hljs-comment">// 5. 释放资源</span><br>        socket.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="✅-4️⃣-UDP-的应用场景"><a href="#✅-4️⃣-UDP-的应用场景" class="headerlink" title="✅ 4️⃣ UDP 的应用场景"></a>✅ <strong>4️⃣ UDP 的应用场景</strong></h2><table><thead><tr><th>应用类型</th><th>说明</th></tr></thead><tbody><tr><td><strong>视频会议</strong></td><td>音视频实时传输，丢失部分数据包不会严重影响体验</td></tr><tr><td><strong>语音通话</strong></td><td>VoIP 应用中，对延迟敏感而对丢包容忍</td></tr><tr><td><strong>在线游戏</strong></td><td>高并发、低延迟需求强，允许偶尔丢失位置或状态更新</td></tr><tr><td><strong>实时传感器</strong></td><td>物联网设备传输实时数据，不要求每一帧都收到</td></tr><tr><td><strong>广播&#x2F;组播</strong></td><td>网络设备发现、服务通知（如DHCP、UPnP）需要广播或多播</td></tr></tbody></table><hr><h2 id="✅-5️⃣-UDP-与-TCP-的比较"><a href="#✅-5️⃣-UDP-与-TCP-的比较" class="headerlink" title="✅ 5️⃣ UDP 与 TCP 的比较"></a>✅ <strong>5️⃣ UDP 与 TCP 的比较</strong></h2><table><thead><tr><th>特性</th><th><strong>UDP</strong></th><th><strong>TCP</strong></th></tr></thead><tbody><tr><td><strong>是否连接</strong></td><td>无连接</td><td>面向连接（三次握手）</td></tr><tr><td><strong>可靠性</strong></td><td>不可靠，可能丢包或乱序</td><td>可靠，顺序性强，支持重传与校验</td></tr><tr><td><strong>速度</strong></td><td>快，适用于实时应用</td><td>慢，适用于高可靠性要求的应用</td></tr><tr><td><strong>流量控制</strong></td><td>无</td><td>有（滑动窗口机制）</td></tr><tr><td><strong>拥塞控制</strong></td><td>无</td><td>有（拥塞窗口控制）</td></tr><tr><td><strong>开销</strong></td><td>小，头部只有 8 字节</td><td>大，头部最少 20 字节</td></tr><tr><td><strong>使用场景</strong></td><td>语音、视频、游戏、物联网</td><td>文件传输、网页浏览、邮件、数据库连接等</td></tr></tbody></table><hr><h2 id="✅-6️⃣-小结"><a href="#✅-6️⃣-小结" class="headerlink" title="✅ 6️⃣ 小结"></a>✅ <strong>6️⃣ 小结</strong></h2><ul><li><strong>UDP 优点</strong>：<ul><li>轻量快速，适用于实时通信</li><li>无连接，代码实现简单</li><li>支持广播与多播</li></ul></li><li><strong>UDP 缺点</strong>：<ul><li>不可靠传输</li><li>无顺序保证</li><li>无拥塞控制和流量控制</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP与UDP</title>
      <link href="/2025/04/04/javaBasics/6.2.1%20TCP%E4%B8%8EUDP/"/>
      <url>/2025/04/04/javaBasics/6.2.1%20TCP%E4%B8%8EUDP/</url>
      
        <content type="html"><![CDATA[<p>好的！我将根据你提供的要求，写一篇详细且结构清晰的关于 <strong>TCP 与 UDP</strong> 协议对比的文章：</p><hr><h1 id="✅-TCP-与-UDP-协议对比"><a href="#✅-TCP-与-UDP-协议对比" class="headerlink" title="✅ TCP 与 UDP 协议对比"></a>✅ <strong>TCP 与 UDP 协议对比</strong></h1><p>在计算机网络中，<strong>TCP</strong>（传输控制协议）和<strong>UDP</strong>（用户数据报协议）是两种常见的传输层协议。它们各自具有不同的特点和应用场景，理解它们的区别对于网络编程和网络应用的设计至关重要。</p><hr><h2 id="1️⃣-什么是-TCP？"><a href="#1️⃣-什么是-TCP？" class="headerlink" title="1️⃣ 什么是 TCP？"></a><strong>1️⃣ 什么是 TCP？</strong></h2><p><strong>TCP（Transmission Control Protocol，传输控制协议）</strong> 是一种面向连接的协议，提供可靠的数据传输服务。TCP 在数据传输前需要建立连接，并通过一系列的确认机制来确保数据的可靠性。</p><h3 id="TCP-的特点："><a href="#TCP-的特点：" class="headerlink" title="TCP 的特点："></a><strong>TCP 的特点：</strong></h3><ul><li><strong>面向连接</strong>：TCP 在发送数据之前需要通过三次握手建立连接，确保通信双方准备好进行数据传输。</li><li><strong>可靠性</strong>：TCP 使用序列号、确认应答（ACK）、重传机制、数据完整性检查等手段保证数据的可靠传输。</li><li><strong>顺序性</strong>：保证数据按发送顺序到达接收端。</li><li><strong>流量控制</strong>：TCP 通过滑动窗口机制控制发送方的数据发送速度，以避免网络拥堵。</li><li><strong>拥塞控制</strong>：TCP 会根据网络的拥堵情况动态调整数据发送速率，避免造成网络堵塞。</li></ul><h3 id="TCP-工作过程："><a href="#TCP-工作过程：" class="headerlink" title="TCP 工作过程："></a><strong>TCP 工作过程：</strong></h3><ol><li><p><strong>建立连接（三次握手）</strong>：</p><ul><li>客户端发送连接请求（SYN）。</li><li>服务器响应连接请求（SYN+ACK）。</li><li>客户端确认连接（ACK）。</li></ul></li><li><p><strong>数据传输</strong>：</p><ul><li>通过数据分段传输，确保数据按顺序到达。</li><li>每个数据段都会被确认。</li></ul></li><li><p><strong>断开连接（四次挥手）</strong>：</p><ul><li>双方通过四次挥手协议断开连接。</li></ul></li></ol><hr><h2 id="2️⃣-什么是-UDP？"><a href="#2️⃣-什么是-UDP？" class="headerlink" title="2️⃣ 什么是 UDP？"></a><strong>2️⃣ 什么是 UDP？</strong></h2><p><strong>UDP（User Datagram Protocol，用户数据报协议）</strong> 是一种无连接的协议，提供较少的可靠性保障。UDP 不像 TCP 那样需要建立连接，数据传输过程中也没有确认应答和重传机制。</p><h3 id="UDP-的特点："><a href="#UDP-的特点：" class="headerlink" title="UDP 的特点："></a><strong>UDP 的特点：</strong></h3><ul><li><strong>无连接</strong>：UDP 在数据传输之前不需要建立连接，直接发送数据。</li><li><strong>不可靠性</strong>：UDP 不保证数据包的到达，也不保证顺序，可能会丢失、重复或乱序。</li><li><strong>速度快</strong>：由于没有建立连接和确认机制，UDP 的传输速度相对较快。</li><li><strong>适用于实时通信</strong>：适合用于实时性要求较高的场景，如视频会议、语音通话等。</li></ul><h3 id="UDP-工作过程："><a href="#UDP-工作过程：" class="headerlink" title="UDP 工作过程："></a><strong>UDP 工作过程：</strong></h3><ol><li><p><strong>数据传输</strong>：</p><ul><li>客户端直接将数据包发送给接收端，不需要建立连接。</li></ul></li><li><p><strong>数据包</strong>：</p><ul><li>每个 UDP 数据包是独立的，没有顺序保障。</li></ul></li><li><p><strong>传输完毕</strong>：</p><ul><li>一旦数据包被发送，它们就不再被管理，接收方不会确认收到的每个数据包。</li></ul></li></ol><hr><h2 id="3️⃣-TCP-与-UDP-的对比"><a href="#3️⃣-TCP-与-UDP-的对比" class="headerlink" title="3️⃣ TCP 与 UDP 的对比"></a><strong>3️⃣ TCP 与 UDP 的对比</strong></h2><table><thead><tr><th>特性</th><th><strong>TCP</strong></th><th><strong>UDP</strong></th></tr></thead><tbody><tr><td><strong>连接方式</strong></td><td>面向连接，需建立连接（三次握手）</td><td>无连接，不需要建立连接</td></tr><tr><td><strong>可靠性</strong></td><td>高，提供可靠的数据传输，确保数据到达并按顺序到达</td><td>低，不保证数据到达，可能丢失或乱序</td></tr><tr><td><strong>数据传输</strong></td><td>按顺序传输，使用序列号和确认应答保证顺序</td><td>无顺序保证，每个数据包独立传输</td></tr><tr><td><strong>流量控制</strong></td><td>有，使用滑动窗口控制数据发送速度</td><td>无，数据包会直接发送，不考虑流量控制</td></tr><tr><td><strong>拥塞控制</strong></td><td>有，根据网络状况调整发送速率</td><td>无，不会根据网络状况调整发送速率</td></tr><tr><td><strong>应用场景</strong></td><td>适用于文件传输、网页浏览、邮件传输等</td><td>适用于实时性要求高的应用，如视频直播、语音通话、在线游戏等</td></tr><tr><td><strong>开销</strong></td><td>较高，需要建立和维持连接，数据包较大</td><td>较低，不需要连接建立和维护，数据包较小</td></tr></tbody></table><hr><h2 id="4️⃣-TCP-与-UDP-适用的场景"><a href="#4️⃣-TCP-与-UDP-适用的场景" class="headerlink" title="4️⃣ TCP 与 UDP 适用的场景"></a><strong>4️⃣ TCP 与 UDP 适用的场景</strong></h2><h3 id="✅-TCP-适用场景："><a href="#✅-TCP-适用场景：" class="headerlink" title="✅ TCP 适用场景："></a>✅ <strong>TCP 适用场景：</strong></h3><ul><li><strong>文件传输</strong>：如 FTP 协议，保证文件的完整性和顺序性。</li><li><strong>网页浏览</strong>：如 HTTP 协议，确保网页内容的完整性。</li><li><strong>电子邮件</strong>：如 SMTP 协议，确保邮件的可靠发送。</li><li><strong>数据库连接</strong>：如 JDBC 协议，确保数据的准确传输。</li></ul><h3 id="✅-UDP-适用场景："><a href="#✅-UDP-适用场景：" class="headerlink" title="✅ UDP 适用场景："></a>✅ <strong>UDP 适用场景：</strong></h3><ul><li><strong>视频会议</strong>：如 WebRTC 协议，实时传输音视频数据，即使丢失一些数据也不会影响体验。</li><li><strong>语音通话</strong>：如 VoIP 协议，实时语音传输，要求低延迟而非数据可靠性。</li><li><strong>在线游戏</strong>：如在线多人游戏，游戏中的位置信息和状态更新，丢包对游戏影响不大。</li><li><strong>实时数据广播</strong>：如 DNS 查询、网络时间协议（NTP）。</li></ul><hr><h2 id="✅-总结"><a href="#✅-总结" class="headerlink" title="✅ 总结"></a>✅ <strong>总结</strong></h2><table><thead><tr><th>特性</th><th><strong>TCP</strong></th><th><strong>UDP</strong></th></tr></thead><tbody><tr><td><strong>连接方式</strong></td><td>需要建立连接（三次握手）</td><td>无连接，数据包直接发送</td></tr><tr><td><strong>可靠性</strong></td><td>高，确保数据可靠传输</td><td>低，不保证数据到达</td></tr><tr><td><strong>传输效率</strong></td><td>相对较慢，建立连接、确认应答等增加了开销</td><td>快，直接传输数据</td></tr><tr><td><strong>应用场景</strong></td><td>适用于文件传输、网页浏览、邮件等需要高可靠性的应用</td><td>适用于实时通信、在线游戏等对延迟要求高的应用</td></tr></tbody></table><p>🎯 <strong>TCP 和 UDP 各有优缺点，选择合适的协议取决于应用需求：</strong></p><ul><li>如果需要保证数据的完整性和顺序，使用 <strong>TCP</strong>。</li><li>如果需要低延迟，且容忍丢失少量数据，使用 <strong>UDP</strong>。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>协议</title>
      <link href="/2025/04/03/javaBasics/6.1.4%20%E5%8D%8F%E8%AE%AE/"/>
      <url>/2025/04/03/javaBasics/6.1.4%20%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="✅-Java-网络编程基础：协议（Protocol）详解"><a href="#✅-Java-网络编程基础：协议（Protocol）详解" class="headerlink" title="✅ Java 网络编程基础：协议（Protocol）详解"></a>✅ <strong>Java 网络编程基础：协议（Protocol）详解</strong></h1><p>在计算机网络中，<strong>协议</strong>是通信的规则和标准，它规定了数据如何格式化、传输、接收与处理。</p><p>在 Java 网络编程中，我们主要关注的协议有：<strong>TCP、UDP、HTTP、FTP</strong> 等。</p><hr><h2 id="1️⃣-什么是网络协议？"><a href="#1️⃣-什么是网络协议？" class="headerlink" title="1️⃣ 什么是网络协议？"></a><strong>1️⃣ 什么是网络协议？</strong></h2><p>网络协议定义了两台主机通信时要遵循的规则，类似于人与人交流时的“语言”。</p><p>👉 没有协议，网络通信就像“鸡同鸭讲”。</p><hr><h2 id="2️⃣-常见网络协议及用途"><a href="#2️⃣-常见网络协议及用途" class="headerlink" title="2️⃣ 常见网络协议及用途"></a><strong>2️⃣ 常见网络协议及用途</strong></h2><table><thead><tr><th>协议</th><th>类型</th><th>特点</th><th>应用场景</th></tr></thead><tbody><tr><td><strong>TCP</strong></td><td>面向连接</td><td>可靠、数据有序、速度略慢</td><td>网页浏览、文件传输、聊天程序</td></tr><tr><td><strong>UDP</strong></td><td>无连接</td><td>不可靠、数据无序、速度快、效率高</td><td>视频直播、语音通话、在线游戏</td></tr><tr><td><strong>HTTP</strong></td><td>应用层</td><td>基于 TCP 的协议，用于浏览器和服务器之间的通信</td><td>网站访问、接口调用</td></tr><tr><td><strong>FTP</strong></td><td>应用层</td><td>基于 TCP，用于文件上传与下载</td><td>远程文件传输</td></tr><tr><td><strong>SMTP</strong></td><td>应用层</td><td>用于发送电子邮件</td><td>邮件客户端发送邮件</td></tr><tr><td><strong>POP3&#x2F;IMAP</strong></td><td>应用层</td><td>用于接收电子邮件</td><td>邮件客户端接收邮件</td></tr></tbody></table><hr><h2 id="3️⃣-TCP-与-UDP-对比"><a href="#3️⃣-TCP-与-UDP-对比" class="headerlink" title="3️⃣ TCP 与 UDP 对比"></a><strong>3️⃣ TCP 与 UDP 对比</strong></h2><table><thead><tr><th>对比项</th><th>TCP</th><th>UDP</th></tr></thead><tbody><tr><td>是否连接</td><td>面向连接，需要三次握手</td><td>无连接，直接发送</td></tr><tr><td>可靠性</td><td>高，确保数据不丢失、不重复、不乱序</td><td>低，可能丢失或乱序</td></tr><tr><td>速度</td><td>相对较慢</td><td>快，适合实时性要求高的场景</td></tr><tr><td>应用举例</td><td>网页访问、文件传输、数据库连接</td><td>视频通话、直播、游戏、广播</td></tr></tbody></table><hr><h2 id="4️⃣-Java-中如何使用这些协议？"><a href="#4️⃣-Java-中如何使用这些协议？" class="headerlink" title="4️⃣ Java 中如何使用这些协议？"></a><strong>4️⃣ Java 中如何使用这些协议？</strong></h2><table><thead><tr><th>协议</th><th>Java 类&#x2F;接口</th><th>用途说明</th></tr></thead><tbody><tr><td>TCP</td><td><code>Socket</code> &#x2F; <code>ServerSocket</code></td><td>客户端&#x2F;服务端通信</td></tr><tr><td>UDP</td><td><code>DatagramSocket</code> &#x2F; <code>DatagramPacket</code></td><td>发送&#x2F;接收不可靠数据报</td></tr><tr><td>HTTP</td><td><code>HttpURLConnection</code> &#x2F; <code>HttpClient</code></td><td>访问 Web 接口、网站等</td></tr><tr><td>FTP</td><td>第三方库（如 Apache Commons Net）</td><td>实现 FTP 上传&#x2F;下载功能</td></tr></tbody></table><hr><h2 id="5️⃣-示例：使用-TCP-协议实现客户端-服务端通信"><a href="#5️⃣-示例：使用-TCP-协议实现客户端-服务端通信" class="headerlink" title="5️⃣ 示例：使用 TCP 协议实现客户端&#x2F;服务端通信"></a><strong>5️⃣ 示例：使用 TCP 协议实现客户端&#x2F;服务端通信</strong></h2><h3 id="✅-服务端（使用-TCP-协议）"><a href="#✅-服务端（使用-TCP-协议）" class="headerlink" title="✅ 服务端（使用 TCP 协议）"></a>✅ 服务端（使用 TCP 协议）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> java.net.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TCPServer</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">ServerSocket</span> <span class="hljs-variable">server</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(<span class="hljs-number">8888</span>);<br>        System.out.println(<span class="hljs-string">&quot;服务器已启动，等待连接...&quot;</span>);<br><br>        <span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> server.accept();<br>        System.out.println(<span class="hljs-string">&quot;客户端已连接：&quot;</span> + socket.getInetAddress());<br><br>        <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(socket.getInputStream()));<br>        <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> reader.readLine();<br>        System.out.println(<span class="hljs-string">&quot;收到客户端消息：&quot;</span> + msg);<br><br>        reader.close();<br>        socket.close();<br>        server.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="✅-客户端（使用-TCP-协议）"><a href="#✅-客户端（使用-TCP-协议）" class="headerlink" title="✅ 客户端（使用 TCP 协议）"></a>✅ 客户端（使用 TCP 协议）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> java.net.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TCPClient</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Socket</span>(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8888</span>);<br><br>        <span class="hljs-type">BufferedWriter</span> <span class="hljs-variable">writer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OutputStreamWriter</span>(socket.getOutputStream()));<br>        writer.write(<span class="hljs-string">&quot;你好，服务端！\n&quot;</span>);<br>        writer.flush();<br><br>        writer.close();<br>        socket.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="✅-总结"><a href="#✅-总结" class="headerlink" title="✅ 总结"></a>✅ <strong>总结</strong></h2><table><thead><tr><th>概念</th><th>说明</th></tr></thead><tbody><tr><td>协议</td><td>规定网络通信规则的标准</td></tr><tr><td>TCP</td><td>可靠、面向连接的协议，常用于文件&#x2F;网页通信</td></tr><tr><td>UDP</td><td>不可靠、无连接的协议，常用于语音&#x2F;视频&#x2F;游戏</td></tr><tr><td>Java 支持</td><td>通过 <code>Socket</code>、<code>DatagramSocket</code>、<code>HttpURLConnection</code> 等类支持</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>端口</title>
      <link href="/2025/04/03/javaBasics/6.1.3%20%E7%AB%AF%E5%8F%A3/"/>
      <url>/2025/04/03/javaBasics/6.1.3%20%E7%AB%AF%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="✅-Java-网络编程基础：端口（Port）详解"><a href="#✅-Java-网络编程基础：端口（Port）详解" class="headerlink" title="✅ Java 网络编程基础：端口（Port）详解"></a>✅ <strong>Java 网络编程基础：端口（Port）详解</strong></h1><p>在计算机网络中，<strong>端口</strong>（Port）是用于区分不同网络服务的数字标识，它与 IP 地址共同组成网络通信的“地址”。</p><hr><h2 id="1️⃣-什么是端口？"><a href="#1️⃣-什么是端口？" class="headerlink" title="1️⃣ 什么是端口？"></a><strong>1️⃣ 什么是端口？</strong></h2><ul><li>IP 地址标识一台主机</li><li>端口号标识该主机上的某个应用程序（网络服务）</li></ul><p>👉 通信时数据发送的目标为：<strong>IP 地址 + 端口号</strong></p><hr><h2 id="2️⃣-端口号的范围"><a href="#2️⃣-端口号的范围" class="headerlink" title="2️⃣ 端口号的范围"></a><strong>2️⃣ 端口号的范围</strong></h2><table><thead><tr><th>范围</th><th>说明</th></tr></thead><tbody><tr><td><code>0 ~ 1023</code></td><td><strong>系统端口</strong>，保留给操作系统使用，如 HTTP（80）、FTP（21）等</td></tr><tr><td><code>1024 ~ 49151</code></td><td><strong>注册端口</strong>，用于用户进程或服务（如 MySQL：3306）</td></tr><tr><td><code>49152 ~ 65535</code></td><td><strong>动态端口 &#x2F; 私有端口</strong>，临时分配的端口</td></tr></tbody></table><hr><h2 id="3️⃣-常见端口号"><a href="#3️⃣-常见端口号" class="headerlink" title="3️⃣ 常见端口号"></a><strong>3️⃣ 常见端口号</strong></h2><table><thead><tr><th>服务&#x2F;协议</th><th>默认端口号</th></tr></thead><tbody><tr><td>HTTP</td><td>80</td></tr><tr><td>HTTPS</td><td>443</td></tr><tr><td>FTP</td><td>21</td></tr><tr><td>SSH</td><td>22</td></tr><tr><td>Telnet</td><td>23</td></tr><tr><td>MySQL</td><td>3306</td></tr><tr><td>Oracle</td><td>1521</td></tr><tr><td>Redis</td><td>6379</td></tr></tbody></table><hr><h2 id="4️⃣-Java-中的端口使用场景"><a href="#4️⃣-Java-中的端口使用场景" class="headerlink" title="4️⃣ Java 中的端口使用场景"></a><strong>4️⃣ Java 中的端口使用场景</strong></h2><table><thead><tr><th>使用方式</th><th>示例类</th></tr></thead><tbody><tr><td>创建服务器并绑定端口</td><td><code>ServerSocket(int port)</code></td></tr><tr><td>客户端连接服务器的端口</td><td><code>Socket(String host, int port)</code></td></tr><tr><td>使用 DatagramSocket 绑定端口</td><td><code>DatagramSocket(int port)</code></td></tr></tbody></table><hr><h2 id="5️⃣-示例一：开启服务端监听端口"><a href="#5️⃣-示例一：开启服务端监听端口" class="headerlink" title="5️⃣ 示例一：开启服务端监听端口"></a><strong>5️⃣ 示例一：开启服务端监听端口</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.net.ServerSocket;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServerExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">ServerSocket</span> <span class="hljs-variable">server</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(<span class="hljs-number">8080</span>);<br>        System.out.println(<span class="hljs-string">&quot;服务端已启动，正在监听端口 8080...&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>📌 <strong>说明</strong>：创建一个服务端，监听 8080 端口，用于等待客户端连接。</p><hr><h2 id="6️⃣-示例二：客户端连接指定端口的服务端"><a href="#6️⃣-示例二：客户端连接指定端口的服务端" class="headerlink" title="6️⃣ 示例二：客户端连接指定端口的服务端"></a><strong>6️⃣ 示例二：客户端连接指定端口的服务端</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.net.Socket;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClientExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Socket</span> <span class="hljs-variable">client</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Socket</span>(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8080</span>);<br>        System.out.println(<span class="hljs-string">&quot;已连接服务器：localhost:8080&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>📌 <strong>说明</strong>：客户端主动连接服务端的 8080 端口，实现通信连接。</p><hr><h2 id="✅-总结"><a href="#✅-总结" class="headerlink" title="✅ 总结"></a>✅ <strong>总结</strong></h2><table><thead><tr><th>概念</th><th>说明</th></tr></thead><tbody><tr><td>端口号</td><td>标识一台主机中的一个网络应用</td></tr><tr><td>范围</td><td>0 ~ 65535，共 65536 个端口</td></tr><tr><td>常见端口</td><td>HTTP 80，HTTPS 443，MySQL 3306 等</td></tr><tr><td>Java 应用场景</td><td><code>ServerSocket</code>, <code>Socket</code>, <code>DatagramSocket</code> 等绑定使用</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>InetAddress</title>
      <link href="/2025/04/03/javaBasics/6.1.2%20InetAddress/"/>
      <url>/2025/04/03/javaBasics/6.1.2%20InetAddress/</url>
      
        <content type="html"><![CDATA[<h1 id="✅-Java-网络编程：InetAddress-类详解"><a href="#✅-Java-网络编程：InetAddress-类详解" class="headerlink" title="✅ Java 网络编程：InetAddress 类详解"></a>✅ <strong>Java 网络编程：InetAddress 类详解</strong></h1><p>在 Java 中，<code>InetAddress</code> 类用于表示 <strong>IP 地址</strong>（IPv4 或 IPv6），它是 Java 网络编程中最常用的类之一，属于 <code>java.net</code> 包。</p><hr><h2 id="1️⃣-InetAddress-的作用"><a href="#1️⃣-InetAddress-的作用" class="headerlink" title="1️⃣ InetAddress 的作用"></a><strong>1️⃣ InetAddress 的作用</strong></h2><ul><li>表示一个 IP 地址（域名或 IP 本身）</li><li>提供主机名与 IP 地址的解析功能</li><li>是进行 Socket 编程的基础类之一</li></ul><hr><h2 id="2️⃣-常用方法"><a href="#2️⃣-常用方法" class="headerlink" title="2️⃣ 常用方法"></a><strong>2️⃣ 常用方法</strong></h2><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td><code>getLocalHost()</code></td><td>获取本机的 <code>InetAddress</code> 对象</td></tr><tr><td><code>getByName(String host)</code></td><td>根据主机名或 IP 获取对应的 <code>InetAddress</code> 对象</td></tr><tr><td><code>getAllByName(String host)</code></td><td>获取与指定主机名关联的所有 IP 地址</td></tr><tr><td><code>getHostName()</code></td><td>获取该 IP 对象对应的主机名</td></tr><tr><td><code>getHostAddress()</code></td><td>获取该对象的 IP 地址字符串</td></tr><tr><td><code>isReachable(int timeout)</code></td><td>判断该地址是否可以在指定时间内连通</td></tr></tbody></table><hr><h2 id="3️⃣-示例一：获取本机-IP-与主机名"><a href="#3️⃣-示例一：获取本机-IP-与主机名" class="headerlink" title="3️⃣ 示例一：获取本机 IP 与主机名"></a><strong>3️⃣ 示例一：获取本机 IP 与主机名</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.net.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LocalHostInfo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> UnknownHostException &#123;<br>        <span class="hljs-type">InetAddress</span> <span class="hljs-variable">local</span> <span class="hljs-operator">=</span> InetAddress.getLocalHost();<br>        System.out.println(<span class="hljs-string">&quot;本机主机名: &quot;</span> + local.getHostName());<br>        System.out.println(<span class="hljs-string">&quot;本机 IP 地址: &quot;</span> + local.getHostAddress());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>📌 <strong>输出示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">本机主机名: DESKTOP-123ABC<br>本机 IP 地址: 192.168.1.100<br></code></pre></td></tr></table></figure><hr><h2 id="4️⃣-示例二：根据域名获取-IP-地址"><a href="#4️⃣-示例二：根据域名获取-IP-地址" class="headerlink" title="4️⃣ 示例二：根据域名获取 IP 地址"></a><strong>4️⃣ 示例二：根据域名获取 IP 地址</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.net.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DomainIP</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> UnknownHostException &#123;<br>        <span class="hljs-type">InetAddress</span> <span class="hljs-variable">address</span> <span class="hljs-operator">=</span> InetAddress.getByName(<span class="hljs-string">&quot;www.baidu.com&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;主机名: &quot;</span> + address.getHostName());<br>        System.out.println(<span class="hljs-string">&quot;IP 地址: &quot;</span> + address.getHostAddress());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>📌 <strong>输出示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">主机名: www.baidu.com<br>IP 地址: 220.181.38.150<br></code></pre></td></tr></table></figure><hr><h2 id="5️⃣-示例三：获取主机所有-IP-地址"><a href="#5️⃣-示例三：获取主机所有-IP-地址" class="headerlink" title="5️⃣ 示例三：获取主机所有 IP 地址"></a><strong>5️⃣ 示例三：获取主机所有 IP 地址</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.net.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AllIPAddresses</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        InetAddress[] addresses = InetAddress.getAllByName(<span class="hljs-string">&quot;www.google.com&quot;</span>);<br><br>        <span class="hljs-keyword">for</span> (InetAddress addr : addresses) &#123;<br>            System.out.println(<span class="hljs-string">&quot;IP: &quot;</span> + addr.getHostAddress());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>📌 <strong>用途</strong>：获取网站的所有服务器地址，用于负载均衡场景分析。</p><hr><h2 id="6️⃣-示例四：判断地址是否可达"><a href="#6️⃣-示例四：判断地址是否可达" class="headerlink" title="6️⃣ 示例四：判断地址是否可达"></a><strong>6️⃣ 示例四：判断地址是否可达</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.net.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PingTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">InetAddress</span> <span class="hljs-variable">address</span> <span class="hljs-operator">=</span> InetAddress.getByName(<span class="hljs-string">&quot;www.baidu.com&quot;</span>);<br><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">reachable</span> <span class="hljs-operator">=</span> address.isReachable(<span class="hljs-number">3000</span>); <span class="hljs-comment">// 3秒超时</span><br>        System.out.println(<span class="hljs-string">&quot;百度是否可达: &quot;</span> + reachable);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="7️⃣-补充说明"><a href="#7️⃣-补充说明" class="headerlink" title="7️⃣ 补充说明"></a><strong>7️⃣ 补充说明</strong></h2><ul><li><code>InetAddress</code> 是一个 <strong>抽象类</strong>，不能直接实例化。</li><li>它的两个子类是：<ul><li><code>Inet4Address</code>：IPv4 地址</li><li><code>Inet6Address</code>：IPv6 地址</li></ul></li></ul><hr><h2 id="✅-总结"><a href="#✅-总结" class="headerlink" title="✅ 总结"></a>✅ <strong>总结</strong></h2><table><thead><tr><th>功能</th><th>方法示例</th></tr></thead><tbody><tr><td>获取本机信息</td><td><code>InetAddress.getLocalHost()</code></td></tr><tr><td>通过域名获取 IP</td><td><code>InetAddress.getByName(&quot;example.com&quot;)</code></td></tr><tr><td>获取所有 IP 地址</td><td><code>InetAddress.getAllByName(...)</code></td></tr><tr><td>获取主机名</td><td><code>getHostName()</code></td></tr><tr><td>获取 IP 字符串</td><td><code>getHostAddress()</code></td></tr><tr><td>判断网络是否连通</td><td><code>isReachable(timeout)</code></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IP</title>
      <link href="/2025/04/03/javaBasics/6.1.1%20IP/"/>
      <url>/2025/04/03/javaBasics/6.1.1%20IP/</url>
      
        <content type="html"><![CDATA[<h1 id="✅-IP-地址详解（Internet-Protocol）"><a href="#✅-IP-地址详解（Internet-Protocol）" class="headerlink" title="✅ IP 地址详解（Internet Protocol）"></a>✅ <strong>IP 地址详解（Internet Protocol）</strong></h1><p>IP（Internet Protocol）是网络通信中的核心协议之一，主要用于为网络中的每台设备分配唯一的地址，实现数据在网络中的传输与定位。</p><hr><h2 id="1️⃣-IP-地址的作用"><a href="#1️⃣-IP-地址的作用" class="headerlink" title="1️⃣ IP 地址的作用"></a><strong>1️⃣ IP 地址的作用</strong></h2><p>IP 地址相当于“网络中的门牌号”，用来唯一标识网络上的一台主机。当你访问网站、下载文件、发送邮件时，系统就是通过 IP 地址找到目标主机。</p><hr><h2 id="2️⃣-IP-地址的分类"><a href="#2️⃣-IP-地址的分类" class="headerlink" title="2️⃣ IP 地址的分类"></a><strong>2️⃣ IP 地址的分类</strong></h2><h3 id="📌-按地址类型分类"><a href="#📌-按地址类型分类" class="headerlink" title="📌 按地址类型分类"></a><strong>📌 按地址类型分类</strong></h3><table><thead><tr><th>类型</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td>IPv4</td><td>使用 32 位地址，写作 4 个十进制数</td><td>192.168.0.1</td></tr><tr><td>IPv6</td><td>使用 128 位地址，支持更多设备</td><td>2001:0db8:85a3::8a2e:0370:7334</td></tr></tbody></table><h3 id="📌-按使用范围分类"><a href="#📌-按使用范围分类" class="headerlink" title="📌 按使用范围分类"></a><strong>📌 按使用范围分类</strong></h3><table><thead><tr><th>类型</th><th>描述</th><th>示例 IP 范围</th></tr></thead><tbody><tr><td>公网 IP</td><td>在互联网中唯一</td><td>8.8.8.8（Google DNS）</td></tr><tr><td>私有 IP（内网）</td><td>局域网中使用，不可直接访问公网</td><td>192.168.0.0&#x2F;16，10.0.0.0&#x2F;8</td></tr></tbody></table><hr><h2 id="3️⃣-IPv4-地址详解"><a href="#3️⃣-IPv4-地址详解" class="headerlink" title="3️⃣ IPv4 地址详解"></a><strong>3️⃣ IPv4 地址详解</strong></h2><h3 id="📌-IPv4-地址结构"><a href="#📌-IPv4-地址结构" class="headerlink" title="📌 IPv4 地址结构"></a><strong>📌 IPv4 地址结构</strong></h3><p>IPv4 地址由 4 段 0~255 的数字组成，形式如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">192.168.1.10<br></code></pre></td></tr></table></figure><h3 id="📌-IPv4-的分类（A-B-C-D-E-类）"><a href="#📌-IPv4-的分类（A-B-C-D-E-类）" class="headerlink" title="📌 IPv4 的分类（A&#x2F;B&#x2F;C&#x2F;D&#x2F;E 类）"></a><strong>📌 IPv4 的分类（A&#x2F;B&#x2F;C&#x2F;D&#x2F;E 类）</strong></h3><table><thead><tr><th>类别</th><th>起始地址范围</th><th>子网默认掩码</th><th>用途</th></tr></thead><tbody><tr><td>A</td><td>1.0.0.0 ~ 126.255.255.255</td><td>255.0.0.0</td><td>大型网络</td></tr><tr><td>B</td><td>128.0.0.0 ~ 191.255.255.255</td><td>255.255.0.0</td><td>中型网络</td></tr><tr><td>C</td><td>192.0.0.0 ~ 223.255.255.255</td><td>255.255.255.0</td><td>小型网络</td></tr><tr><td>D</td><td>224.0.0.0 ~ 239.255.255.255</td><td>-</td><td>组播地址</td></tr><tr><td>E</td><td>240.0.0.0 ~ 255.255.255.255</td><td>-</td><td>实验&#x2F;预留地址</td></tr></tbody></table><hr><h2 id="4️⃣-子网掩码与网络划分"><a href="#4️⃣-子网掩码与网络划分" class="headerlink" title="4️⃣ 子网掩码与网络划分"></a><strong>4️⃣ 子网掩码与网络划分</strong></h2><p>子网掩码（Subnet Mask）用来区分 <strong>网络地址</strong> 和 <strong>主机地址</strong>，例如：</p><table><thead><tr><th>IP 地址</th><th>子网掩码</th><th>网络地址</th><th>主机地址</th></tr></thead><tbody><tr><td>192.168.1.10</td><td>255.255.255.0</td><td>192.168.1.0</td><td>.10</td></tr></tbody></table><hr><h2 id="5️⃣-IPv6-简介"><a href="#5️⃣-IPv6-简介" class="headerlink" title="5️⃣ IPv6 简介"></a><strong>5️⃣ IPv6 简介</strong></h2><ul><li>使用 <strong>128 位地址</strong>，写作 8 组 4 个十六进制数：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">2001:0db8:0000:0000:0000:ff00:0042:8329<br></code></pre></td></tr></table></figure><ul><li>支持 <strong>2 的 128 次方</strong> 个地址，彻底解决 IPv4 地址枯竭问题。</li><li>IPv6 可省略前导 0、连续 0 用 <code>::</code> 表示。</li></ul><hr><h2 id="6️⃣-特殊-IP-地址"><a href="#6️⃣-特殊-IP-地址" class="headerlink" title="6️⃣ 特殊 IP 地址"></a><strong>6️⃣ 特殊 IP 地址</strong></h2><table><thead><tr><th>IP 地址</th><th>含义</th></tr></thead><tbody><tr><td>127.0.0.1</td><td>本机回环地址（localhost）</td></tr><tr><td>0.0.0.0</td><td>表示所有 IP、默认路由</td></tr><tr><td>255.255.255.255</td><td>广播地址</td></tr><tr><td>169.254.x.x</td><td>自动分配地址（APIPA）</td></tr></tbody></table><hr><h2 id="7️⃣-实战：获取本机-IP-地址（Java-示例）"><a href="#7️⃣-实战：获取本机-IP-地址（Java-示例）" class="headerlink" title="7️⃣ 实战：获取本机 IP 地址（Java 示例）"></a><strong>7️⃣ 实战：获取本机 IP 地址（Java 示例）</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.net.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IPAddressExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">InetAddress</span> <span class="hljs-variable">address</span> <span class="hljs-operator">=</span> InetAddress.getLocalHost();<br>        System.out.println(<span class="hljs-string">&quot;本机 IP 地址: &quot;</span> + address.getHostAddress());<br>        System.out.println(<span class="hljs-string">&quot;主机名: &quot;</span> + address.getHostName());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="8️⃣-IP-与端口的关系"><a href="#8️⃣-IP-与端口的关系" class="headerlink" title="8️⃣ IP 与端口的关系"></a><strong>8️⃣ IP 与端口的关系</strong></h2><ul><li>IP 确定的是 “<strong>哪台主机</strong>”；</li><li>端口号确定的是 “<strong>主机上的哪个服务&#x2F;程序</strong>”。</li></ul><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">http://127.0.0.1:8080/<br>↑       ↑         ↑<br>协议    IP       端口号<br></code></pre></td></tr></table></figure><hr><h2 id="✅-总结"><a href="#✅-总结" class="headerlink" title="✅ 总结"></a><strong>✅ 总结</strong></h2><table><thead><tr><th>项目</th><th>描述</th></tr></thead><tbody><tr><td>IP 地址作用</td><td>唯一标识网络中的设备</td></tr><tr><td>IPv4</td><td>4 段十进制组成，共 32 位地址</td></tr><tr><td>IPv6</td><td>更长的地址，适用于未来网络发展</td></tr><tr><td>子网掩码</td><td>区分网络地址和主机地址</td></tr><tr><td>端口号</td><td>标识主机中具体的应用服务</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程池</title>
      <link href="/2025/04/02/javaBasics/5.5%20%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
      <url>/2025/04/02/javaBasics/5.5%20%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="✅-线程池概述"><a href="#✅-线程池概述" class="headerlink" title="✅ 线程池概述"></a>✅ <strong>线程池概述</strong></h2><p>在多线程编程中，创建和销毁线程是一项相对昂贵的操作。为了减少频繁创建和销毁线程带来的性能开销，<strong>线程池</strong>（Thread Pool）技术应运而生。线程池通过提前创建一定数量的线程来 <strong>复用线程</strong>，提高系统的 <strong>效率</strong> 和 <strong>性能</strong>。</p><p><strong>线程池的主要优势</strong>：</p><ol><li><strong>避免频繁创建和销毁线程的开销</strong>。</li><li><strong>可以控制线程的最大并发数</strong>，防止资源过度消耗。</li><li><strong>线程池可以更好地管理线程生命周期</strong>，避免线程泄漏。</li></ol><hr><h2 id="✅-Java-中的线程池"><a href="#✅-Java-中的线程池" class="headerlink" title="✅ Java 中的线程池"></a>✅ <strong>Java 中的线程池</strong></h2><p>在 <strong>Java</strong> 中，线程池的使用通过 <strong><code>java.util.concurrent</code></strong> 包中的 <strong><code>Executor</code></strong> 接口及其实现类来完成。</p><h3 id="1-线程池核心接口：Executor"><a href="#1-线程池核心接口：Executor" class="headerlink" title="1. 线程池核心接口：Executor"></a><strong>1. 线程池核心接口：<code>Executor</code></strong></h3><ul><li><strong><code>Executor</code></strong> 接口定义了执行异步任务的核心方法：<strong><code>execute(Runnable command)</code></strong>。</li><li><strong><code>ExecutorService</code></strong> 是 <strong><code>Executor</code></strong> 的子接口，提供了更多的线程池控制方法，如提交任务、关闭线程池等。</li></ul><h3 id="2-常见线程池实现："><a href="#2-常见线程池实现：" class="headerlink" title="2. 常见线程池实现："></a><strong>2. 常见线程池实现：</strong></h3><ol><li><strong><code>ThreadPoolExecutor</code></strong><ul><li>这是 <code>ExecutorService</code> 的最常用实现类，具有高度的自定义性。</li></ul></li><li><strong><code>Executors</code> 工厂类</strong><ul><li>提供了几种常用的线程池实现，如 <strong>固定大小线程池</strong>、<strong>单线程池</strong>、<strong>可缓存线程池</strong> 等。</li></ul></li></ol><hr><h2 id="✅-线程池的类型"><a href="#✅-线程池的类型" class="headerlink" title="✅ 线程池的类型"></a>✅ <strong>线程池的类型</strong></h2><h3 id="1-可缓存线程池（newCachedThreadPool-）"><a href="#1-可缓存线程池（newCachedThreadPool-）" class="headerlink" title="1. 可缓存线程池（newCachedThreadPool()）"></a><strong>1. 可缓存线程池（<code>newCachedThreadPool()</code>）</strong></h3><ul><li><strong>特点</strong>：线程池的大小会根据实际情况调整，如果线程池中没有空闲线程，就会创建新线程，空闲线程会在60秒后被回收。</li><li><strong>适用场景</strong>：适合执行大量短时间的小任务。</li></ul><h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a><strong>代码示例</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.ExecutorService;<br><span class="hljs-keyword">import</span> java.util.concurrent.Executors;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CachedThreadPoolExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> Executors.newCachedThreadPool();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            executor.submit(() -&gt; &#123;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 执行任务&quot;</span>);<br>            &#125;);<br>        &#125;<br><br>        executor.shutdown();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>解析</strong>：<code>newCachedThreadPool</code> 创建一个可缓存线程池，根据任务量自动调整线程池的大小。</li></ul><h3 id="2-固定大小线程池（newFixedThreadPool-）"><a href="#2-固定大小线程池（newFixedThreadPool-）" class="headerlink" title="2. 固定大小线程池（newFixedThreadPool()）"></a><strong>2. 固定大小线程池（<code>newFixedThreadPool()</code>）</strong></h3><ul><li><strong>特点</strong>：线程池中的线程数固定，如果所有线程都处于忙碌状态，新的任务会被放入队列等待。</li><li><strong>适用场景</strong>：适用于负载较重的任务，需要控制最大线程数的场景。</li></ul><h4 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a><strong>代码示例</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.ExecutorService;<br><span class="hljs-keyword">import</span> java.util.concurrent.Executors;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FixedThreadPoolExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">3</span>); <span class="hljs-comment">// 创建一个固定大小的线程池</span><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            executor.submit(() -&gt; &#123;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 执行任务&quot;</span>);<br>            &#125;);<br>        &#125;<br><br>        executor.shutdown();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>解析</strong>：<code>newFixedThreadPool(3)</code> 创建一个包含 3 个线程的线程池，超过 3 个任务会被放入队列中等待。</li></ul><h3 id="3-单线程池（newSingleThreadExecutor-）"><a href="#3-单线程池（newSingleThreadExecutor-）" class="headerlink" title="3. 单线程池（newSingleThreadExecutor()）"></a><strong>3. 单线程池（<code>newSingleThreadExecutor()</code>）</strong></h3><ul><li><strong>特点</strong>：线程池只会创建一个线程，所有任务都会在该线程中顺序执行，适用于任务需要串行执行的场景。</li><li><strong>适用场景</strong>：适用于需要确保任务顺序执行的场景。</li></ul><h4 id="代码示例-2"><a href="#代码示例-2" class="headerlink" title="代码示例"></a><strong>代码示例</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.ExecutorService;<br><span class="hljs-keyword">import</span> java.util.concurrent.Executors;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SingleThreadExecutorExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> Executors.newSingleThreadExecutor(); <span class="hljs-comment">// 创建一个单线程池</span><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            executor.submit(() -&gt; &#123;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 执行任务&quot;</span>);<br>            &#125;);<br>        &#125;<br><br>        executor.shutdown();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>解析</strong>：<code>newSingleThreadExecutor</code> 创建一个单线程池，所有任务会按顺序执行，不会并发。</li></ul><h3 id="4-定时线程池（newScheduledThreadPool-）"><a href="#4-定时线程池（newScheduledThreadPool-）" class="headerlink" title="4. 定时线程池（newScheduledThreadPool()）"></a><strong>4. 定时线程池（<code>newScheduledThreadPool()</code>）</strong></h3><ul><li><strong>特点</strong>：线程池支持定时任务执行，可以周期性地执行任务。</li><li><strong>适用场景</strong>：适合定时调度任务或周期性任务。</li></ul><h4 id="代码示例-3"><a href="#代码示例-3" class="headerlink" title="代码示例"></a><strong>代码示例</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.Executors;<br><span class="hljs-keyword">import</span> java.util.concurrent.ScheduledExecutorService;<br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ScheduledThreadPoolExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ScheduledExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> Executors.newScheduledThreadPool(<span class="hljs-number">1</span>);<br><br>        executor.scheduleAtFixedRate(() -&gt; &#123;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 执行定时任务&quot;</span>);<br>        &#125;, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, TimeUnit.SECONDS); <span class="hljs-comment">// 从 0 秒后每 2 秒执行一次</span><br><br>        <span class="hljs-comment">// 等待 10 秒后关闭线程池</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">10000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>        executor.shutdown();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>解析</strong>：<code>scheduleAtFixedRate</code> 用于按固定频率执行任务，适合定时调度任务。</li></ul><hr><h1 id="✅-ThreadPoolExecutor-自定义线程池"><a href="#✅-ThreadPoolExecutor-自定义线程池" class="headerlink" title="✅ ThreadPoolExecutor 自定义线程池"></a>✅ <strong><code>ThreadPoolExecutor</code> 自定义线程池</strong></h1><h2 id="1️⃣-概述"><a href="#1️⃣-概述" class="headerlink" title="1️⃣ 概述"></a><strong>1️⃣ 概述</strong></h2><p><code>ThreadPoolExecutor</code> 是 Java 最强大的线程池实现类，允许我们自定义 <strong>核心线程数</strong>、<strong>最大线程数</strong>、<strong>任务队列</strong>、<strong>拒绝策略</strong> 等参数，从而精细控制线程池的行为。  </p><p>在实际开发中，合理使用线程池可以<strong>提高系统吞吐量</strong>、<strong>降低资源消耗</strong>、<strong>防止线程无限创建</strong>导致 OOM（内存溢出）。  </p><hr><h2 id="2️⃣-ThreadPoolExecutor-构造方法"><a href="#2️⃣-ThreadPoolExecutor-构造方法" class="headerlink" title="2️⃣ ThreadPoolExecutor 构造方法"></a><strong>2️⃣ <code>ThreadPoolExecutor</code> 构造方法</strong></h2><p>完整的 <code>ThreadPoolExecutor</code> 构造方法包含 <strong>7 个参数</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize, </span><br><span class="hljs-params">                          <span class="hljs-type">int</span> maximumPoolSize,</span><br><span class="hljs-params">                          <span class="hljs-type">long</span> keepAliveTime,</span><br><span class="hljs-params">                          TimeUnit unit,</span><br><span class="hljs-params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="hljs-params">                          ThreadFactory threadFactory,</span><br><span class="hljs-params">                          RejectedExecutionHandler handler)</span><br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>参数</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td><code>corePoolSize</code></td><td>核心线程数</td></tr><tr><td><code>maximumPoolSize</code></td><td>最大线程数</td></tr><tr><td><code>keepAliveTime</code></td><td>非核心线程的存活时间</td></tr><tr><td><code>unit</code></td><td>时间单位</td></tr><tr><td><code>workQueue</code></td><td>任务队列（存放等待执行的任务）</td></tr><tr><td><code>threadFactory</code></td><td>线程工厂（可自定义线程名称等）</td></tr><tr><td><code>handler</code></td><td>拒绝策略（线程池满时如何处理新任务）</td></tr></tbody></table><hr><h2 id="3️⃣-代码示例"><a href="#3️⃣-代码示例" class="headerlink" title="3️⃣ 代码示例"></a><strong>3️⃣ 代码示例</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomThreadPoolExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 1. 创建自定义线程池</span><br>        <span class="hljs-type">ThreadPoolExecutor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<br>            <span class="hljs-number">2</span>,  <span class="hljs-comment">// 核心线程数</span><br>            <span class="hljs-number">4</span>,  <span class="hljs-comment">// 最大线程数</span><br>            <span class="hljs-number">60</span>, <span class="hljs-comment">// 空闲线程存活时间</span><br>            TimeUnit.SECONDS, <span class="hljs-comment">// 时间单位</span><br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="hljs-number">2</span>), <span class="hljs-comment">// 任务队列（最多 2 个任务）</span><br>            Executors.defaultThreadFactory(), <span class="hljs-comment">// 线程工厂（默认）</span><br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>.AbortPolicy() <span class="hljs-comment">// 拒绝策略（直接抛出异常）</span><br>        );<br><br>        <span class="hljs-comment">// 2. 提交任务</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">6</span>; i++) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">taskId</span> <span class="hljs-operator">=</span> i;<br>            executor.submit(() -&gt; &#123;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 执行任务 &quot;</span> + taskId);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">1000</span>); <span class="hljs-comment">// 模拟任务执行</span><br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;);<br>        &#125;<br><br>        <span class="hljs-comment">// 3. 关闭线程池</span><br>        executor.shutdown();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="4️⃣-运行分析"><a href="#4️⃣-运行分析" class="headerlink" title="4️⃣ 运行分析"></a><strong>4️⃣ 运行分析</strong></h2><p>🔹 <strong>线程池核心线程数 &#x3D; 2</strong>，最大线程数 &#x3D; 4，任务队列最多存 2 个任务：</p><ol><li><strong>前 2 个任务</strong> 直接由核心线程执行。</li><li><strong>第 3、4 个任务</strong> 进入任务队列等待执行。</li><li><strong>第 5、6 个任务</strong> 触发扩容，由最大线程数中的 2 个额外线程执行。</li><li><strong>第 7 个任务</strong> 由于线程池 + 任务队列已满，根据 <code>AbortPolicy</code> <strong>抛出异常</strong>。</li></ol><hr><h2 id="5️⃣-线程池拒绝策略（RejectedExecutionHandler）"><a href="#5️⃣-线程池拒绝策略（RejectedExecutionHandler）" class="headerlink" title="5️⃣ 线程池拒绝策略（RejectedExecutionHandler）"></a><strong>5️⃣ 线程池拒绝策略（<code>RejectedExecutionHandler</code>）</strong></h2><table><thead><tr><th><strong>策略</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><code>AbortPolicy</code>（默认）</td><td>直接抛出 <code>RejectedExecutionException</code>，<strong>任务被丢弃</strong> 🚨</td></tr><tr><td><code>CallerRunsPolicy</code></td><td>由提交任务的线程（<strong>主线程</strong>）执行该任务，<strong>防止任务丢失</strong> ✅</td></tr><tr><td><code>DiscardPolicy</code></td><td>直接丢弃无法执行的任务，<strong>不抛异常</strong> ❌</td></tr><tr><td><code>DiscardOldestPolicy</code></td><td>丢弃任务队列中<strong>最老的任务</strong>，然后重新尝试提交新任务 🔄</td></tr></tbody></table><p>📌 <strong>示例：使用 <code>CallerRunsPolicy</code>（防止任务丢失）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<br>    <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">60</span>, TimeUnit.SECONDS,<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="hljs-number">2</span>),<br>    Executors.defaultThreadFactory(),<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>.CallerRunsPolicy()<br>);<br></code></pre></td></tr></table></figure><p>🔹 <strong>适用场景</strong>：希望任务<strong>不丢失</strong>，但可能会影响主线程性能。</p><hr><h2 id="6️⃣-线程池使用注意事项"><a href="#6️⃣-线程池使用注意事项" class="headerlink" title="6️⃣ 线程池使用注意事项"></a><strong>6️⃣ 线程池使用注意事项</strong></h2><p>✅ <strong>合理设置 <code>corePoolSize</code> 和 <code>maximumPoolSize</code></strong>  </p><ul><li><strong>CPU 密集型任务</strong>（计算型）：<code>corePoolSize = CPU 核心数</code></li><li><strong>IO 密集型任务</strong>（磁盘&#x2F;网络）：<code>corePoolSize = 2 * CPU 核心数</code></li></ul><p>✅ <strong>选择合适的 <code>BlockingQueue</code></strong></p><table><thead><tr><th><strong>队列类型</strong></th><th><strong>特点</strong></th></tr></thead><tbody><tr><td><code>LinkedBlockingQueue</code></td><td><strong>无界队列</strong>，可能导致 OOM</td></tr><tr><td><code>ArrayBlockingQueue</code></td><td><strong>有界队列</strong>，需要指定大小</td></tr><tr><td><code>SynchronousQueue</code></td><td><strong>不存储任务</strong>，提交任务必须有可用线程执行</td></tr></tbody></table><p>✅ <strong>合理使用 <code>RejectedExecutionHandler</code></strong></p><ul><li><strong>关键任务</strong>（不能丢失）：<code>CallerRunsPolicy</code></li><li><strong>非关键任务</strong>（允许丢弃）：<code>DiscardPolicy</code></li></ul><hr><h2 id="✅-总结"><a href="#✅-总结" class="headerlink" title="✅ 总结"></a>✅ <strong>总结</strong></h2><table><thead><tr><th><strong>线程池类型</strong></th><th><strong>特点</strong></th><th><strong>适用场景</strong></th></tr></thead><tbody><tr><td><strong>可缓存线程池</strong> (<code>newCachedThreadPool()</code>)</td><td>根据需求动态增加线程，空闲线程会被回收</td><td>适合大量短时间任务</td></tr><tr><td><strong>固定线程池</strong> (<code>newFixedThreadPool()</code>)</td><td>线程数固定，多余的任务会在队列中等待</td><td>适合负载较重，控制线程数的场景</td></tr><tr><td><strong>单线程池</strong> (<code>newSingleThreadExecutor()</code>)</td><td>只有一个线程，任务顺序执行</td><td>需要保证任务顺序执行的场景</td></tr><tr><td><strong>定时线程池</strong> (<code>newScheduledThreadPool()</code>)</td><td>支持定时任务执行</td><td>定时任务、周期性任务</td></tr><tr><td><strong>自定义线程池</strong> (<code>ThreadPoolExecutor</code>)</td><td>高度可定制，灵活配置核心线程数、最大线程数等</td><td>需要精细控制线程池行为的场景</td></tr></tbody></table><blockquote><p><strong>总结</strong>：选择线程池时，要根据任务的特性、负载要求和并发需求，来决定使用哪种类型的线程池。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程同步</title>
      <link href="/2025/04/02/javaBasics/5.4%20%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/"/>
      <url>/2025/04/02/javaBasics/5.4%20%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="✅-1-线程同步概述"><a href="#✅-1-线程同步概述" class="headerlink" title="✅ 1. 线程同步概述"></a>✅ <strong>1. 线程同步概述</strong></h2><p>在 <strong>多线程环境</strong> 下，如果多个线程同时访问 <strong>共享资源</strong>，可能会导致 <strong>数据不一致</strong> 或 <strong>线程安全问题</strong>。为了避免这种情况，我们需要 <strong>线程同步机制</strong> 来 <strong>控制多个线程对共享资源的访问</strong>。</p><p><strong>常见的线程同步方式</strong>：</p><ol><li><strong>同步代码块（synchronized 代码块）</strong></li><li><strong>同步方法（synchronized 方法）</strong></li><li><strong>显示锁（Lock 机制，如 ReentrantLock）</strong></li></ol><hr><h2 id="✅-2-同步代码块（synchronized-代码块）"><a href="#✅-2-同步代码块（synchronized-代码块）" class="headerlink" title="✅ 2. 同步代码块（synchronized 代码块）"></a>✅ <strong>2. 同步代码块（synchronized 代码块）</strong></h2><h3 id="🔹-概念"><a href="#🔹-概念" class="headerlink" title="🔹 概念"></a><strong>🔹 概念</strong></h3><ul><li><strong>通过 <code>synchronized</code> 关键字</strong> <strong>锁定某个对象</strong>，保证 <strong>同一时刻只有一个线程</strong> 执行同步代码块。</li><li><strong>适用于部分代码需要同步</strong> 的情况，提高性能。</li></ul><h3 id="🔹-代码示例"><a href="#🔹-代码示例" class="headerlink" title="🔹 代码示例"></a><strong>🔹 代码示例</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SharedResource</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">increment</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123; <span class="hljs-comment">// 只锁定 this（当前实例）</span><br>            count++;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; -&gt; &quot;</span> + count);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SynchronizedBlockExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">SharedResource</span> <span class="hljs-variable">resource</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SharedResource</span>();<br><br>        <span class="hljs-type">Runnable</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> () -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>                resource.increment();<br>            &#125;<br>        &#125;;<br><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(task, <span class="hljs-string">&quot;线程1&quot;</span>);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(task, <span class="hljs-string">&quot;线程2&quot;</span>);<br><br>        t1.start();<br>        t2.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="🔹-解析"><a href="#🔹-解析" class="headerlink" title="🔹 解析"></a><strong>🔹 解析</strong></h3><ul><li><code>synchronized (this)</code> <strong>锁定当前实例</strong>，多个线程访问 <code>increment()</code> 方法时 <strong>会串行执行</strong>，避免竞态条件。</li><li><strong>适用于部分代码需要同步</strong> 的场景，而不是锁住整个方法，能提高程序 <strong>并发性能</strong>。</li></ul><hr><h2 id="✅-3-同步方法（synchronized-方法）"><a href="#✅-3-同步方法（synchronized-方法）" class="headerlink" title="✅ 3. 同步方法（synchronized 方法）"></a>✅ <strong>3. 同步方法（synchronized 方法）</strong></h2><h3 id="🔹-概念-1"><a href="#🔹-概念-1" class="headerlink" title="🔹 概念"></a><strong>🔹 概念</strong></h3><ul><li><strong>在方法前加 <code>synchronized</code></strong>，使得 <strong>整个方法</strong> 在同一时刻只能被 <strong>一个线程访问</strong>。</li><li>适用于 <strong>整个方法都需要同步</strong> 的场景，但可能会 <strong>影响并发性能</strong>。</li></ul><h3 id="🔹-代码示例-1"><a href="#🔹-代码示例-1" class="headerlink" title="🔹 代码示例"></a><strong>🔹 代码示例</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SharedResource</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">increment</span><span class="hljs-params">()</span> &#123; <span class="hljs-comment">// 方法同步</span><br>        count++;<br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; -&gt; &quot;</span> + count);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SynchronizedMethodExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">SharedResource</span> <span class="hljs-variable">resource</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SharedResource</span>();<br><br>        <span class="hljs-type">Runnable</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> () -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>                resource.increment();<br>            &#125;<br>        &#125;;<br><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(task, <span class="hljs-string">&quot;线程1&quot;</span>);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(task, <span class="hljs-string">&quot;线程2&quot;</span>);<br><br>        t1.start();<br>        t2.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="🔹-解析-1"><a href="#🔹-解析-1" class="headerlink" title="🔹 解析"></a><strong>🔹 解析</strong></h3><ul><li><code>synchronized</code> 修饰方法，相当于 <strong><code>synchronized (this) &#123;&#125;</code></strong>。</li><li><strong>适用于整个方法都需要同步</strong> 的情况，但会影响 <strong>程序并发性能</strong>。</li></ul><h3 id="⚠️-静态方法同步"><a href="#⚠️-静态方法同步" class="headerlink" title="⚠️ 静态方法同步"></a><strong>⚠️ 静态方法同步</strong></h3><ul><li><strong><code>synchronized static</code></strong> 方法锁定的是 <strong>类对象（Class 对象）</strong>，而不是实例：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SharedResource</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">increment</span><span class="hljs-params">()</span> &#123; <span class="hljs-comment">// 锁定类对象</span><br>        count++;<br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; -&gt; &quot;</span> + count);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>等价于：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">increment</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">synchronized</span> (SharedResource.class) &#123; <br>        count++;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>适用于</strong> 需要对 <strong>类级别共享资源</strong> 进行同步的场景。</p></blockquote><hr><h2 id="✅-4-Lock（显式锁机制）"><a href="#✅-4-Lock（显式锁机制）" class="headerlink" title="✅ 4. Lock（显式锁机制）"></a>✅ <strong>4. Lock（显式锁机制）</strong></h2><h3 id="🔹-概念-2"><a href="#🔹-概念-2" class="headerlink" title="🔹 概念"></a><strong>🔹 概念</strong></h3><ul><li><code>Lock</code>（如 <code>ReentrantLock</code>）提供 <strong>更灵活的同步控制</strong>，相比 <code>synchronized</code> 具有以下优势：<ul><li><strong>支持公平锁和非公平锁</strong>（<code>synchronized</code> 只能是非公平锁）</li><li><strong>可以尝试获取锁</strong>（避免死锁）</li><li><strong>可以中断</strong>（线程可被打断）</li></ul></li></ul><h3 id="🔹-代码示例-2"><a href="#🔹-代码示例-2" class="headerlink" title="🔹 代码示例"></a><strong>🔹 代码示例</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.locks.Lock;<br><span class="hljs-keyword">import</span> java.util.concurrent.locks.ReentrantLock;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SharedResource</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Lock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>(); <span class="hljs-comment">// 创建锁对象</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">increment</span><span class="hljs-params">()</span> &#123;<br>        lock.lock(); <span class="hljs-comment">// 获取锁</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            count++;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; -&gt; &quot;</span> + count);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock(); <span class="hljs-comment">// 确保释放锁</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LockExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">SharedResource</span> <span class="hljs-variable">resource</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SharedResource</span>();<br><br>        <span class="hljs-type">Runnable</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> () -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>                resource.increment();<br>            &#125;<br>        &#125;;<br><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(task, <span class="hljs-string">&quot;线程1&quot;</span>);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(task, <span class="hljs-string">&quot;线程2&quot;</span>);<br><br>        t1.start();<br>        t2.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="🔹-解析-2"><a href="#🔹-解析-2" class="headerlink" title="🔹 解析"></a><strong>🔹 解析</strong></h3><ul><li><code>lock.lock()</code> 获取锁，<code>lock.unlock()</code> 释放锁，确保 <code>finally</code> 代码块中释放锁，防止 <strong>死锁</strong>。</li><li><code>ReentrantLock</code> 是 <strong>可重入锁</strong>，同一线程可多次获取锁。</li></ul><hr><h2 id="✅-5-synchronized-vs-Lock-对比"><a href="#✅-5-synchronized-vs-Lock-对比" class="headerlink" title="✅ 5. synchronized vs Lock 对比"></a>✅ <strong>5. <code>synchronized</code> vs <code>Lock</code> 对比</strong></h2><table><thead><tr><th><strong>对比项</strong></th><th><strong>synchronized</strong></th><th><strong>Lock（ReentrantLock）</strong></th></tr></thead><tbody><tr><td><strong>锁的类型</strong></td><td><strong>隐式锁</strong>（JVM 负责加锁解锁）</td><td><strong>显式锁</strong>（手动加锁解锁）</td></tr><tr><td><strong>公平锁</strong></td><td>不支持</td><td>支持 <strong>公平锁&#x2F;非公平锁</strong></td></tr><tr><td><strong>可中断性</strong></td><td><strong>不可中断</strong>，必须执行完</td><td><strong>可中断</strong>（<code>lockInterruptibly()</code>）</td></tr><tr><td><strong>尝试获取锁</strong></td><td>不支持</td><td><strong>支持 <code>tryLock()</code></strong>（避免死锁）</td></tr><tr><td><strong>性能</strong></td><td><strong>JVM 优化，性能较高</strong></td><td><strong>稍低，但更灵活</strong></td></tr></tbody></table><h3 id="✅-使用建议"><a href="#✅-使用建议" class="headerlink" title="✅ 使用建议"></a><strong>✅ 使用建议</strong></h3><ul><li><strong>简单的同步</strong>（如线程安全的计数器）：✅ <code>synchronized</code></li><li><strong>需要公平锁、可中断锁</strong> 或 <strong>避免死锁</strong>：✅ <code>ReentrantLock</code></li><li><strong>涉及多个共享资源</strong>（如数据库事务、读写锁）：✅ <code>ReentrantLock</code></li></ul><hr><h2 id="✅-6-总结"><a href="#✅-6-总结" class="headerlink" title="✅ 6. 总结"></a>✅ <strong>6. 总结</strong></h2><table><thead><tr><th><strong>同步方式</strong></th><th><strong>特点</strong></th></tr></thead><tbody><tr><td><strong>同步代码块</strong> (<code>synchronized (this) &#123;&#125;</code>)</td><td>适用于 <strong>部分代码</strong> 需要同步，提高性能</td></tr><tr><td><strong>同步方法</strong> (<code>synchronized 方法名() &#123;&#125;</code>)</td><td>适用于 <strong>整个方法</strong> 需要同步，简单但影响并发</td></tr><tr><td><strong>Lock（ReentrantLock）</strong></td><td><strong>显式锁</strong>，支持 <strong>公平锁、可中断、尝试获取锁</strong>，适用于 <strong>高级同步</strong></td></tr></tbody></table><blockquote><p><strong>推荐方式</strong>：</p><ul><li><strong>首选 <code>synchronized</code>（简单、高效）</strong></li><li><strong>如果需要复杂控制（如公平锁、可中断）</strong>，使用 <code>Lock</code></li></ul></blockquote><hr>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>thread提供的常用构造器</title>
      <link href="/2025/04/02/javaBasics/5.3%20thread%E6%8F%90%E4%BE%9B%E7%9A%84%E5%B8%B8%E7%94%A8%E6%9E%84%E9%80%A0%E5%99%A8/"/>
      <url>/2025/04/02/javaBasics/5.3%20thread%E6%8F%90%E4%BE%9B%E7%9A%84%E5%B8%B8%E7%94%A8%E6%9E%84%E9%80%A0%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p><code>Thread</code> 类提供了几个常见的构造方法，用于创建和初始化线程。下面是 <code>Thread</code> 类的常见构造器及其说明：</p><hr><h2 id="✅-1-Thread"><a href="#✅-1-Thread" class="headerlink" title="✅ 1. Thread()"></a>✅ <strong>1. <code>Thread()</code></strong></h2><ul><li><strong>作用</strong>：创建一个新的线程，默认没有指定任务，也没有指定线程名称。</li><li><strong>使用场景</strong>：当你想要自定义线程的任务时，通常通过继承 <code>Thread</code> 类并重写 <code>run()</code> 方法。</li></ul><h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a><strong>示例</strong>：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>();<br>thread.start();<br></code></pre></td></tr></table></figure><hr><h2 id="✅-2-Thread-Runnable-target"><a href="#✅-2-Thread-Runnable-target" class="headerlink" title="✅ 2. Thread(Runnable target)"></a>✅ <strong>2. <code>Thread(Runnable target)</code></strong></h2><ul><li><strong>作用</strong>：创建一个新的线程并将指定的 <code>Runnable</code> 目标传递给线程。该线程会执行 <code>Runnable</code> 的 <code>run()</code> 方法中的任务。</li><li><strong>使用场景</strong>：当线程的任务已经被实现为 <code>Runnable</code> 接口时，可以直接传递给 <code>Thread</code> 构造方法。</li></ul><h3 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a><strong>示例</strong>：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Runnable</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> () -&gt; System.out.println(<span class="hljs-string">&quot;线程执行&quot;</span>);<br><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(task);<br>thread.start();<br></code></pre></td></tr></table></figure><hr><h2 id="✅-3-Thread-String-name"><a href="#✅-3-Thread-String-name" class="headerlink" title="✅ 3. Thread(String name)"></a>✅ <strong>3. <code>Thread(String name)</code></strong></h2><ul><li><strong>作用</strong>：创建一个新的线程并指定线程名称。该线程将执行 <code>run()</code> 方法，线程名称默认为 <code>Thread-0</code>、<code>Thread-1</code> 等。</li><li><strong>使用场景</strong>：当你想为线程指定名称时，可以使用该构造方法。</li></ul><h3 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a><strong>示例</strong>：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-string">&quot;自定义线程名称&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;线程名称: &quot;</span> + thread.getName());<br>thread.start();<br></code></pre></td></tr></table></figure><hr><h2 id="✅-4-Thread-Runnable-target-String-name"><a href="#✅-4-Thread-Runnable-target-String-name" class="headerlink" title="✅ 4. Thread(Runnable target, String name)"></a>✅ <strong>4. <code>Thread(Runnable target, String name)</code></strong></h2><ul><li><strong>作用</strong>：创建一个新的线程并将指定的 <code>Runnable</code> 目标传递给线程，同时为线程指定一个名称。该线程将执行 <code>Runnable</code> 的 <code>run()</code> 方法中的任务。</li><li><strong>使用场景</strong>：当你想为线程指定任务并为其命名时，可以使用该构造方法。</li></ul><h3 id="示例：-3"><a href="#示例：-3" class="headerlink" title="示例："></a><strong>示例</strong>：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Runnable</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> () -&gt; System.out.println(<span class="hljs-string">&quot;线程执行&quot;</span>);<br><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(task, <span class="hljs-string">&quot;自定义线程名称&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;线程名称: &quot;</span> + thread.getName());<br>thread.start();<br></code></pre></td></tr></table></figure><hr><h2 id="✅-5-Thread-ThreadGroup-group-Runnable-target"><a href="#✅-5-Thread-ThreadGroup-group-Runnable-target" class="headerlink" title="✅ 5. Thread(ThreadGroup group, Runnable target)"></a>✅ <strong>5. <code>Thread(ThreadGroup group, Runnable target)</code></strong></h2><ul><li><strong>作用</strong>：创建一个新的线程并指定线程组 <code>group</code> 和执行的任务 <code>Runnable target</code>。  </li><li><strong>使用场景</strong>：当需要将线程加入特定的线程组时，可以使用该构造方法。</li></ul><h3 id="示例：-4"><a href="#示例：-4" class="headerlink" title="示例："></a><strong>示例</strong>：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ThreadGroup</span> <span class="hljs-variable">group</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadGroup</span>(<span class="hljs-string">&quot;线程组&quot;</span>);<br><span class="hljs-type">Runnable</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> () -&gt; System.out.println(<span class="hljs-string">&quot;线程执行&quot;</span>);<br><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(group, task);<br>thread.start();<br></code></pre></td></tr></table></figure><hr><h2 id="✅-6-Thread-ThreadGroup-group-Runnable-target-String-name"><a href="#✅-6-Thread-ThreadGroup-group-Runnable-target-String-name" class="headerlink" title="✅ 6. Thread(ThreadGroup group, Runnable target, String name)"></a>✅ <strong>6. <code>Thread(ThreadGroup group, Runnable target, String name)</code></strong></h2><ul><li><strong>作用</strong>：创建一个新的线程并指定线程组、执行的任务和线程名称。</li><li><strong>使用场景</strong>：当你需要将线程加入特定的线程组、指定任务并命名线程时，可以使用该构造方法。</li></ul><h3 id="示例：-5"><a href="#示例：-5" class="headerlink" title="示例："></a><strong>示例</strong>：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ThreadGroup</span> <span class="hljs-variable">group</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadGroup</span>(<span class="hljs-string">&quot;线程组&quot;</span>);<br><span class="hljs-type">Runnable</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> () -&gt; System.out.println(<span class="hljs-string">&quot;线程执行&quot;</span>);<br><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(group, task, <span class="hljs-string">&quot;自定义线程名称&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;线程名称: &quot;</span> + thread.getName());<br>thread.start();<br></code></pre></td></tr></table></figure><hr><h2 id="✅-总结"><a href="#✅-总结" class="headerlink" title="✅ 总结"></a>✅ <strong>总结</strong></h2><table><thead><tr><th><strong>构造方法</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><code>Thread()</code></td><td>创建一个没有任务和名称的线程</td></tr><tr><td><code>Thread(Runnable target)</code></td><td>创建一个带有 <code>Runnable</code> 任务的线程</td></tr><tr><td><code>Thread(String name)</code></td><td>创建一个没有任务但指定名称的线程</td></tr><tr><td><code>Thread(Runnable target, String name)</code></td><td>创建一个带有 <code>Runnable</code> 任务并指定名称的线程</td></tr><tr><td><code>Thread(ThreadGroup group, Runnable target)</code></td><td>创建一个带有 <code>Runnable</code> 任务并指定线程组的线程</td></tr><tr><td><code>Thread(ThreadGroup group, Runnable target, String name)</code></td><td>创建一个带有 <code>Runnable</code> 任务、指定线程组和名称的线程</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>thread提供的常用方法</title>
      <link href="/2025/04/02/javaBasics/5.2%20thread%E6%8F%90%E4%BE%9B%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/"/>
      <url>/2025/04/02/javaBasics/5.2%20thread%E6%8F%90%E4%BE%9B%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p><code>Thread</code> 类提供了多种常用方法，用于创建和管理线程。下面是一些常用的 <code>Thread</code> 方法及其说明：</p><hr><h2 id="✅-1-创建和启动线程的方法"><a href="#✅-1-创建和启动线程的方法" class="headerlink" title="✅ 1. 创建和启动线程的方法"></a>✅ <strong>1. 创建和启动线程的方法</strong></h2><h3 id="1-start"><a href="#1-start" class="headerlink" title="(1) start()"></a><strong>(1) <code>start()</code></strong></h3><ul><li><strong>作用</strong>：启动线程。调用 <code>start()</code> 方法后，线程将进入“可运行”状态，并开始执行 <code>run()</code> 方法。</li><li><strong>注意</strong>：只能调用一次，调用多次会抛出 <code>IllegalThreadStateException</code> 异常。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; System.out.println(<span class="hljs-string">&quot;线程正在执行&quot;</span>));<br>thread.start();<br></code></pre></td></tr></table></figure><h3 id="2-run"><a href="#2-run" class="headerlink" title="(2) run()"></a><strong>(2) <code>run()</code></strong></h3><ul><li><strong>作用</strong>：线程执行的代码逻辑。<code>run()</code> 方法是线程的入口，线程在启动时会执行 <code>run()</code> 方法中的代码。  </li><li><strong>注意</strong>：通常不直接调用 <code>run()</code> 方法，而是调用 <code>start()</code> 来启动线程。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;线程执行&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">MyThread</span> <span class="hljs-variable">myThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>();<br>        myThread.start(); <span class="hljs-comment">// 调用 start() 执行 run()</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="✅-2-线程的生命周期方法"><a href="#✅-2-线程的生命周期方法" class="headerlink" title="✅ 2. 线程的生命周期方法"></a>✅ <strong>2. 线程的生命周期方法</strong></h2><h3 id="1-sleep-long-millis"><a href="#1-sleep-long-millis" class="headerlink" title="(1) sleep(long millis)"></a><strong>(1) <code>sleep(long millis)</code></strong></h3><ul><li><strong>作用</strong>：使当前线程暂停（休眠）指定时间（毫秒）。休眠期间线程不占用 CPU 资源。</li><li><strong>注意</strong>：<code>sleep()</code> 方法是静态的，调用后，当前线程进入“休眠”状态。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        System.out.println(<span class="hljs-string">&quot;线程开始&quot;</span>);<br>        Thread.sleep(<span class="hljs-number">2000</span>); <span class="hljs-comment">// 当前线程休眠 2 秒</span><br>        System.out.println(<span class="hljs-string">&quot;线程结束&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-interrupt"><a href="#2-interrupt" class="headerlink" title="(2) interrupt()"></a><strong>(2) <code>interrupt()</code></strong></h3><ul><li><strong>作用</strong>：中断当前线程，设置线程的中断标志为 <code>true</code>。  </li><li><strong>注意</strong>：如果线程在 <code>sleep()</code>、<code>wait()</code> 或 <code>join()</code> 等方法上被阻塞，调用 <code>interrupt()</code> 会抛出 <code>InterruptedException</code>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        Thread.sleep(<span class="hljs-number">5000</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        System.out.println(<span class="hljs-string">&quot;线程被中断&quot;</span>);<br>    &#125;<br>&#125;);<br>thread.start();<br><br><span class="hljs-comment">// 中断线程</span><br>thread.interrupt();<br></code></pre></td></tr></table></figure><hr><h2 id="✅-3-获取线程状态和信息的方法"><a href="#✅-3-获取线程状态和信息的方法" class="headerlink" title="✅ 3. 获取线程状态和信息的方法"></a>✅ <strong>3. 获取线程状态和信息的方法</strong></h2><h3 id="1-getId"><a href="#1-getId" class="headerlink" title="(1) getId()"></a><strong>(1) <code>getId()</code></strong></h3><ul><li><strong>作用</strong>：返回当前线程的唯一标识符（ID）。  </li><li><strong>返回类型</strong>：<code>long</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>();<br>System.out.println(<span class="hljs-string">&quot;线程ID: &quot;</span> + thread.getId());<br></code></pre></td></tr></table></figure><h3 id="2-getName"><a href="#2-getName" class="headerlink" title="(2) getName()"></a><strong>(2) <code>getName()</code></strong></h3><ul><li><strong>作用</strong>：返回当前线程的名称。默认名称是 <code>Thread-0</code>、<code>Thread-1</code> 等，可以通过构造方法修改。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>();<br>System.out.println(<span class="hljs-string">&quot;线程名称: &quot;</span> + thread.getName());<br></code></pre></td></tr></table></figure><h3 id="3-getState"><a href="#3-getState" class="headerlink" title="(3) getState()"></a><strong>(3) <code>getState()</code></strong></h3><ul><li><strong>作用</strong>：获取当前线程的状态。返回值是 <code>Thread.State</code> 枚举类型，可能的状态有：  <ul><li><code>NEW</code>：线程已创建，但未启动。  </li><li><code>RUNNABLE</code>：线程可以执行（即使线程正在等待 CPU 时间片）。  </li><li><code>BLOCKED</code>：线程在等待锁。  </li><li><code>WAITING</code>：线程正在等待其他线程的通知。  </li><li><code>TIMED_WAITING</code>：线程在等待指定时间后继续执行。  </li><li><code>TERMINATED</code>：线程已完成执行。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>();<br>System.out.println(<span class="hljs-string">&quot;线程状态: &quot;</span> + thread.getState());<br></code></pre></td></tr></table></figure><h3 id="4-isAlive"><a href="#4-isAlive" class="headerlink" title="(4) isAlive()"></a><strong>(4) <code>isAlive()</code></strong></h3><ul><li><strong>作用</strong>：判断线程是否仍在运行。返回 <code>true</code> 如果线程已启动并且尚未终止。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>();<br>thread.start();<br>System.out.println(<span class="hljs-string">&quot;线程是否活着: &quot;</span> + thread.isAlive());<br></code></pre></td></tr></table></figure><h3 id="5-setName-String-name"><a href="#5-setName-String-name" class="headerlink" title="(5) setName(String name)"></a><strong>(5) <code>setName(String name)</code></strong></h3><ul><li><strong>作用</strong>：设置当前线程的名称。  </li><li><strong>说明</strong>：默认线程名称是 <code>Thread-0</code>、<code>Thread-1</code> 等，可以通过 <code>setName()</code> 方法修改线程名称，便于识别和调试。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>();<br>thread.setName(<span class="hljs-string">&quot;自定义线程名称&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;当前线程名称: &quot;</span> + thread.getName());<br></code></pre></td></tr></table></figure><hr><h2 id="✅-4-线程的控制方法"><a href="#✅-4-线程的控制方法" class="headerlink" title="✅ 4. 线程的控制方法"></a>✅ <strong>4. 线程的控制方法</strong></h2><h3 id="1-join"><a href="#1-join" class="headerlink" title="(1) join()"></a><strong>(1) <code>join()</code></strong></h3><ul><li><strong>作用</strong>：使当前线程等待目标线程完成（终止），即当前线程会阻塞直到目标线程终止为止。</li><li><strong>注意</strong>：<code>join()</code> 可以带上等待时间，表示等待目标线程最多执行指定的时间。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">thread1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    System.out.println(<span class="hljs-string">&quot;线程1执行&quot;</span>);<br>&#125;);<br><span class="hljs-type">Thread</span> <span class="hljs-variable">thread2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    System.out.println(<span class="hljs-string">&quot;线程2执行&quot;</span>);<br>&#125;);<br><br>thread1.start();<br>thread2.start();<br><br><span class="hljs-keyword">try</span> &#123;<br>    thread1.join(); <span class="hljs-comment">// 等待线程1结束</span><br>    thread2.join(); <span class="hljs-comment">// 等待线程2结束</span><br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="✅-5-线程的优先级方法"><a href="#✅-5-线程的优先级方法" class="headerlink" title="✅ 5. 线程的优先级方法"></a>✅ <strong>5. 线程的优先级方法</strong></h2><h3 id="1-setPriority-int-newPriority"><a href="#1-setPriority-int-newPriority" class="headerlink" title="(1) setPriority(int newPriority)"></a><strong>(1) <code>setPriority(int newPriority)</code></strong></h3><ul><li><strong>作用</strong>：设置线程的优先级。线程优先级是一个整数，范围从 <code>Thread.MIN_PRIORITY</code>（1）到 <code>Thread.MAX_PRIORITY</code>（10），默认优先级是 <code>Thread.NORM_PRIORITY</code>（5）。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>();<br>thread.setPriority(Thread.MAX_PRIORITY); <span class="hljs-comment">// 设置为最大优先级</span><br></code></pre></td></tr></table></figure><h3 id="2-getPriority"><a href="#2-getPriority" class="headerlink" title="(2) getPriority()"></a><strong>(2) <code>getPriority()</code></strong></h3><ul><li><strong>作用</strong>：获取当前线程的优先级。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>();<br>System.out.println(<span class="hljs-string">&quot;线程优先级: &quot;</span> + thread.getPriority());<br></code></pre></td></tr></table></figure><hr><h2 id="✅-6-其他常用线程方法"><a href="#✅-6-其他常用线程方法" class="headerlink" title="✅ 6. 其他常用线程方法"></a>✅ <strong>6. 其他常用线程方法</strong></h2><h3 id="1-yield"><a href="#1-yield" class="headerlink" title="(1) yield()"></a><strong>(1) <code>yield()</code></strong></h3><ul><li><strong>作用</strong>：使当前线程主动让出 CPU 时间片，允许其他线程有机会执行。它并不会挂起线程，只是让当前线程回到可运行状态，其他线程可能获得执行机会。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Thread.<span class="hljs-keyword">yield</span>(); <span class="hljs-comment">// 当前线程让步</span><br></code></pre></td></tr></table></figure><h3 id="2-currentThread"><a href="#2-currentThread" class="headerlink" title="(2) currentThread()"></a><strong>(2) <code>currentThread()</code></strong></h3><ul><li><strong>作用</strong>：返回当前正在执行的线程对象。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">currentThread</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>System.out.println(<span class="hljs-string">&quot;当前线程名称: &quot;</span> + currentThread.getName());<br></code></pre></td></tr></table></figure><hr><h2 id="✅-7-Thread-常用方法总结"><a href="#✅-7-Thread-常用方法总结" class="headerlink" title="✅ 7.Thread 常用方法总结"></a>✅ <strong>7.<code>Thread</code> 常用方法总结</strong></h2><table><thead><tr><th><strong>方法</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td><code>start()</code></td><td>启动线程并执行 <code>run()</code> 方法</td></tr><tr><td><code>run()</code></td><td>线程的执行逻辑</td></tr><tr><td><code>sleep(long millis)</code></td><td>使线程休眠指定时间</td></tr><tr><td><code>interrupt()</code></td><td>中断线程</td></tr><tr><td><code>getId()</code></td><td>获取线程的唯一标识符</td></tr><tr><td><code>getName()</code></td><td>获取线程的名称</td></tr><tr><td><code>setName(String name)</code></td><td>设置线程的名称</td></tr><tr><td><code>getState()</code></td><td>获取线程的当前状态</td></tr><tr><td><code>isAlive()</code></td><td>判断线程是否仍在运行</td></tr><tr><td><code>join()</code></td><td>当前线程等待目标线程完成</td></tr><tr><td><code>setPriority(int)</code></td><td>设置线程的优先级</td></tr><tr><td><code>getPriority()</code></td><td>获取线程的优先级</td></tr><tr><td><code>yield()</code></td><td>当前线程让出 CPU 时间片</td></tr><tr><td><code>currentThread()</code></td><td>获取当前正在执行的线程对象</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程的创建方法</title>
      <link href="/2025/04/02/javaBasics/5.1%20%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E6%96%B9%E6%B3%95/"/>
      <url>/2025/04/02/javaBasics/5.1%20%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<ul><li><p>在 <strong>Java</strong> 中，有三种常用的方法来创建线程：  </p><ol><li><strong>继承 <code>Thread</code> 类</strong>  </li><li><strong>实现 <code>Runnable</code> 接口</strong>  </li><li><strong>使用 <code>Callable</code> 和 <code>Future</code></strong></li></ol><hr><h2 id="✅-方法一：继承-Thread-类"><a href="#✅-方法一：继承-Thread-类" class="headerlink" title="✅ 方法一：继承 Thread 类"></a>✅ <strong>方法一：继承 <code>Thread</code> 类</strong></h2><p><strong>特点：</strong>  </p><ul><li>直接继承 <code>Thread</code> 类并重写 <code>run()</code> 方法。  </li><li>使用 <code>start()</code> 方法启动线程。</li></ul><p><strong>示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;线程 &quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot; 正在运行&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">MyThread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>();<br>        <span class="hljs-type">MyThread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>();<br>        t1.start();<br>        t2.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>优点：</strong> 简单直观，直接创建线程对象。<br><strong>缺点：</strong> Java 不支持多继承，继承 <code>Thread</code> 后不能继承其他类。  </p><hr><h2 id="✅-方法二：实现-Runnable-接口"><a href="#✅-方法二：实现-Runnable-接口" class="headerlink" title="✅ 方法二：实现 Runnable 接口"></a>✅ <strong>方法二：实现 <code>Runnable</code> 接口</strong></h2><p><strong>特点：</strong>  </p><ul><li>实现 <code>Runnable</code> 接口，并重写 <code>run()</code> 方法。  </li><li>使用 <code>Thread</code> 类包装 <code>Runnable</code> 对象。</li></ul><p><strong>示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;线程 &quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot; 正在运行&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRunnable</span>());<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRunnable</span>());<br>        t1.start();<br>        t2.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>优点：</strong>  </p><ul><li>更灵活，适合需要共享资源的场景。  </li><li>可以通过实现接口避免 Java 的单继承限制。</li></ul><p><strong>缺点：</strong> 代码稍微复杂一点，需要通过 <code>Thread</code> 对象启动。  </p><hr><h2 id="✅-方法三：使用-Callable-和-Future"><a href="#✅-方法三：使用-Callable-和-Future" class="headerlink" title="✅ 方法三：使用 Callable 和 Future"></a>✅ <strong>方法三：使用 <code>Callable</code> 和 <code>Future</code></strong></h2><p><strong>特点：</strong>  </p><ul><li>使用 <code>Callable</code> 接口，可以有返回值，并抛出异常。  </li><li>使用 <code>FutureTask</code> 获取线程的执行结果。</li></ul><p><strong>示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.*;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCallable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span>&lt;String&gt; &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;线程 &quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot; 执行完成&quot;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">MyCallable</span> <span class="hljs-variable">callable</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCallable</span>();<br>        FutureTask&lt;String&gt; futureTask = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;&gt;(callable);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(futureTask);<br>        thread.start();<br><br>        <span class="hljs-comment">// 获取线程执行结果</span><br>        System.out.println(<span class="hljs-string">&quot;结果: &quot;</span> + futureTask.get());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>优点：</strong>  </p><ul><li>有返回值，可以获取任务执行结果。  </li><li>可以捕获异常，进行更好的异常处理。</li></ul><p><strong>缺点：</strong> 代码较复杂，需要额外处理 <code>FutureTask</code>。  </p><hr><h2 id="✅-总结：选择哪种方式？"><a href="#✅-总结：选择哪种方式？" class="headerlink" title="✅ 总结：选择哪种方式？"></a>✅ <strong>总结：选择哪种方式？</strong></h2><table><thead><tr><th><strong>场景</strong></th><th><strong>推荐方法</strong></th><th><strong>原因</strong></th></tr></thead><tbody><tr><td>简单任务，无需返回结果</td><td><code>Thread</code> 类</td><td>代码简单，适合一次性任务</td></tr><tr><td>需要共享资源或避免继承限制</td><td><code>Runnable</code> 接口</td><td>更加灵活，推荐优先使用</td></tr><tr><td>需要获取线程执行结果，或可能抛异常</td><td><code>Callable + Future</code></td><td>支持返回值和异常处理</td></tr></tbody></table></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Commons-IO框架</title>
      <link href="/2025/04/01/javaBasics/4.4.4%20IO%E6%A1%86%E6%9E%B6/"/>
      <url>/2025/04/01/javaBasics/4.4.4%20IO%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="Commons-IO-框架详解"><a href="#Commons-IO-框架详解" class="headerlink" title="Commons IO 框架详解"></a><strong>Commons IO 框架详解</strong></h1><p><code>Commons IO</code> 是 Apache 提供的 <strong>Java IO 工具库</strong>，它简化了 <strong>文件</strong>、<strong>流</strong> 和 <strong>路径</strong> 的操作，提高开发效率，减少 <code>try-catch-finally</code> 代码。</p><hr><h2 id="✅-1-依赖导入"><a href="#✅-1-依赖导入" class="headerlink" title="✅ 1. 依赖导入"></a>✅ <strong>1. 依赖导入</strong></h2><h3 id="📌-1-1-Maven-依赖"><a href="#📌-1-1-Maven-依赖" class="headerlink" title="📌 1.1 Maven 依赖"></a><strong>📌 1.1 Maven 依赖</strong></h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>commons-io<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-io<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.15.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="📌-1-2-手动下载"><a href="#📌-1-2-手动下载" class="headerlink" title="📌 1.2 手动下载"></a><strong>📌 1.2 手动下载</strong></h3><p>从 <a href="https://commons.apache.org/proper/commons-io/">Apache 官网</a> 下载 JAR 包，添加到 <code>lib</code> 目录。</p><ol><li>在项目中创建一个文件夹：lib</li><li>将commons-io-2.6.jar文件复制到lib文件夹</li><li>在jar文件上点右键，选择“Add as library”，点击OK</li><li>在类中导包使用</li></ol><hr><h2 id="✅-2-Commons-IO-核心工具类"><a href="#✅-2-Commons-IO-核心工具类" class="headerlink" title="✅ 2. Commons IO 核心工具类"></a>✅ <strong>2. Commons IO 核心工具类</strong></h2><p>以下是 <code>Commons IO</code> 提供的 <strong>核心工具类</strong> 及其作用：</p><table><thead><tr><th><strong>工具类</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td><code>FileUtils</code></td><td><strong>文件操作</strong>（复制、删除、读取、写入等）</td></tr><tr><td><code>IOUtils</code></td><td><strong>流操作</strong>（复制、关闭、转换等）</td></tr><tr><td><code>FilenameUtils</code></td><td><strong>文件路径操作</strong>（获取扩展名、文件名等）</td></tr><tr><td><code>FileSystemUtils</code></td><td><strong>磁盘空间信息</strong></td></tr><tr><td><code>LineIterator</code></td><td><strong>逐行读取文件</strong></td></tr></tbody></table><hr><h2 id="✅-3-FileUtils（文件操作）"><a href="#✅-3-FileUtils（文件操作）" class="headerlink" title="✅ 3. FileUtils（文件操作）"></a>✅ <strong>3. FileUtils（文件操作）</strong></h2><table><thead><tr><th><strong>方法</strong></th><th><strong>作用</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td><code>copyFile(File src, File dest)</code></td><td>复制文件</td><td><code>FileUtils.copyFile(new File(&quot;a.txt&quot;), new File(&quot;b.txt&quot;));</code></td></tr><tr><td><code>copyDirectory(File src, File dest)</code></td><td>复制目录</td><td><code>FileUtils.copyDirectory(new File(&quot;D:/source&quot;), new File(&quot;D:/dest&quot;));</code></td></tr><tr><td><code>readFileToString(File file, String encoding)</code></td><td>读取文件内容</td><td><code>String content = FileUtils.readFileToString(new File(&quot;test.txt&quot;), &quot;UTF-8&quot;);</code></td></tr><tr><td><code>write(File file, String data, String encoding)</code></td><td>写入文件</td><td><code>FileUtils.write(new File(&quot;output.txt&quot;), &quot;Hello&quot;, &quot;UTF-8&quot;);</code></td></tr><tr><td><code>forceDelete(File file)</code></td><td>删除文件或目录</td><td><code>FileUtils.forceDelete(new File(&quot;unwanted.txt&quot;));</code></td></tr><tr><td><code>deleteDirectory(File directory)</code></td><td>删除整个目录</td><td><code>FileUtils.deleteDirectory(new File(&quot;D:/oldFolder&quot;));</code></td></tr></tbody></table><hr><h2 id="✅-4-IOUtils（流操作）"><a href="#✅-4-IOUtils（流操作）" class="headerlink" title="✅ 4. IOUtils（流操作）"></a>✅ <strong>4. IOUtils（流操作）</strong></h2><table><thead><tr><th><strong>方法</strong></th><th><strong>作用</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td><code>toString(InputStream in, String encoding)</code></td><td>读取输入流</td><td><code>String content = IOUtils.toString(new FileInputStream(&quot;test.txt&quot;), &quot;UTF-8&quot;);</code></td></tr><tr><td><code>copy(InputStream in, OutputStream out)</code></td><td>复制流</td><td><code>IOUtils.copy(new FileInputStream(&quot;a.txt&quot;), new FileOutputStream(&quot;b.txt&quot;));</code></td></tr><tr><td><code>closeQuietly(Closeable closeable)</code></td><td>关闭流（不抛异常）</td><td><code>IOUtils.closeQuietly(inputStream);</code></td></tr></tbody></table><hr><h2 id="✅-5-FilenameUtils（文件路径操作）"><a href="#✅-5-FilenameUtils（文件路径操作）" class="headerlink" title="✅ 5. FilenameUtils（文件路径操作）"></a>✅ <strong>5. FilenameUtils（文件路径操作）</strong></h2><table><thead><tr><th><strong>方法</strong></th><th><strong>作用</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td><code>getExtension(String filename)</code></td><td>获取文件扩展名</td><td><code>String ext = FilenameUtils.getExtension(&quot;test.txt&quot;); // txt</code></td></tr><tr><td><code>getBaseName(String filename)</code></td><td>获取文件名（无扩展名）</td><td><code>String name = FilenameUtils.getBaseName(&quot;test.txt&quot;); // test</code></td></tr><tr><td><code>getFullPath(String filename)</code></td><td>获取完整路径</td><td><code>String path = FilenameUtils.getFullPath(&quot;D:/folder/test.txt&quot;); // D:/folder/</code></td></tr></tbody></table><hr><h2 id="✅-6-FileSystemUtils（磁盘空间信息）"><a href="#✅-6-FileSystemUtils（磁盘空间信息）" class="headerlink" title="✅ 6. FileSystemUtils（磁盘空间信息）"></a>✅ <strong>6. FileSystemUtils（磁盘空间信息）</strong></h2><table><thead><tr><th><strong>方法</strong></th><th><strong>作用</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td><code>freeSpaceKb(String path)</code></td><td>获取磁盘剩余空间（KB）</td><td><code>long space = FileSystemUtils.freeSpaceKb(&quot;C:&quot;);</code></td></tr></tbody></table><hr><h2 id="✅-7-LineIterator（逐行读取文件）"><a href="#✅-7-LineIterator（逐行读取文件）" class="headerlink" title="✅ 7. LineIterator（逐行读取文件）"></a>✅ <strong>7. LineIterator（逐行读取文件）</strong></h2><table><thead><tr><th><strong>方法</strong></th><th><strong>作用</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td><code>FileUtils.lineIterator(File file, String encoding)</code></td><td>逐行读取大文件</td><td>见下方示例</td></tr></tbody></table><h3 id="📌-逐行读取示例"><a href="#📌-逐行读取示例" class="headerlink" title="📌 逐行读取示例"></a><strong>📌 逐行读取示例</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.apache.commons.io.FileUtils;<br><span class="hljs-keyword">import</span> org.apache.commons.io.LineIterator;<br><span class="hljs-keyword">import</span> java.io.File;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LineIteratorExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;largeFile.txt&quot;</span>);<br>        <span class="hljs-type">LineIterator</span> <span class="hljs-variable">it</span> <span class="hljs-operator">=</span> FileUtils.lineIterator(file, <span class="hljs-string">&quot;UTF-8&quot;</span>);<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span> (it.hasNext()) &#123;<br>                System.out.println(it.nextLine());<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            it.close(); <span class="hljs-comment">// 关闭迭代器，释放资源</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>🔹 适用场景</strong>：</p><ul><li><strong>适合读取大文件</strong>，防止 <code>OutOfMemoryError</code>。</li><li><strong>替代 <code>BufferedReader</code></strong>，代码更简洁。</li></ul><hr><h2 id="✅-8-总结"><a href="#✅-8-总结" class="headerlink" title="✅ 8. 总结"></a>✅ <strong>8. 总结</strong></h2><table><thead><tr><th><strong>工具类</strong></th><th><strong>功能</strong></th></tr></thead><tbody><tr><td><code>FileUtils</code></td><td><strong>文件操作（复制、删除、读取、写入）</strong></td></tr><tr><td><code>IOUtils</code></td><td><strong>流操作（复制、关闭、转换）</strong></td></tr><tr><td><code>FilenameUtils</code></td><td><strong>路径解析（获取文件名、扩展名）</strong></td></tr><tr><td><code>FileSystemUtils</code></td><td><strong>磁盘空间查询</strong></td></tr><tr><td><code>LineIterator</code></td><td><strong>逐行读取大文件</strong></td></tr></tbody></table><p>📌 <strong><code>Commons IO</code> 极大简化了 Java IO 操作，是 Java 开发的必备工具！</strong> 🚀</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> File-IO流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>其他流</title>
      <link href="/2025/04/01/javaBasics/4.4.3%20%E5%85%B6%E4%BB%96%E6%B5%81/"/>
      <url>/2025/04/01/javaBasics/4.4.3%20%E5%85%B6%E4%BB%96%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-其他流（常见特殊流）详解"><a href="#Java-其他流（常见特殊流）详解" class="headerlink" title="Java 其他流（常见特殊流）详解"></a><strong>Java 其他流（常见特殊流）详解</strong></h1><p>除了 <strong>文件流（FileInputStream&#x2F;FileOutputStream、FileReader&#x2F;FileWriter）</strong> 和 <strong>缓冲流（BufferedInputStream&#x2F;BufferedOutputStream、BufferedReader&#x2F;BufferedWriter）</strong>，Java 还提供了许多 <strong>特殊的流</strong> 来满足不同的需求，如 <strong>数据流、转换流、对象流、打印流、标准输入输出流等</strong>。</p><hr><h2 id="✅-1-数据流（DataInputStream-DataOutputStream）"><a href="#✅-1-数据流（DataInputStream-DataOutputStream）" class="headerlink" title="✅ 1. 数据流（DataInputStream &#x2F; DataOutputStream）"></a>✅ <strong>1. 数据流（DataInputStream &#x2F; DataOutputStream）</strong></h2><p><strong>作用</strong>：  </p><ul><li>让 Java 可以 <strong>读写基本数据类型（int、double、boolean等）</strong> 和 <strong>字符串</strong>，而不仅仅是字节或字符。</li><li>适用于 <strong>存储二进制数据</strong>（如数据库文件、序列化数据等）。</li></ul><h3 id="📌-1-1-DataOutputStream（数据输出流）"><a href="#📌-1-1-DataOutputStream（数据输出流）" class="headerlink" title="📌 1.1 DataOutputStream（数据输出流）"></a><strong>📌 1.1 DataOutputStream（数据输出流）</strong></h3><p>用于 <strong>写入基本数据类型</strong> 到文件，保证数据的格式不会丢失。</p><h4 id="示例：使用-DataOutputStream-写入基本数据"><a href="#示例：使用-DataOutputStream-写入基本数据" class="headerlink" title="示例：使用 DataOutputStream 写入基本数据"></a><strong>示例：使用 <code>DataOutputStream</code> 写入基本数据</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DataOutputStreamExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">DataOutputStream</span> <span class="hljs-variable">dos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;data.bin&quot;</span>))) &#123;<br>            dos.writeInt(<span class="hljs-number">100</span>);  <span class="hljs-comment">// 写入 int 类型</span><br>            dos.writeDouble(<span class="hljs-number">99.99</span>);  <span class="hljs-comment">// 写入 double 类型</span><br>            dos.writeBoolean(<span class="hljs-literal">true</span>);  <span class="hljs-comment">// 写入 boolean 类型</span><br>            dos.writeUTF(<span class="hljs-string">&quot;Hello, DataOutputStream!&quot;</span>);  <span class="hljs-comment">// 写入字符串（UTF-8 编码）</span><br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="📌-1-2-DataInputStream（数据输入流）"><a href="#📌-1-2-DataInputStream（数据输入流）" class="headerlink" title="📌 1.2 DataInputStream（数据输入流）"></a><strong>📌 1.2 DataInputStream（数据输入流）</strong></h3><p>用于 <strong>读取基本数据类型</strong>，确保读取的数据与 <code>DataOutputStream</code> 写入的格式一致。</p><h4 id="示例：使用-DataInputStream-读取基本数据"><a href="#示例：使用-DataInputStream-读取基本数据" class="headerlink" title="示例：使用 DataInputStream 读取基本数据"></a><strong>示例：使用 <code>DataInputStream</code> 读取基本数据</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DataInputStreamExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">DataInputStream</span> <span class="hljs-variable">dis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;data.bin&quot;</span>))) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> dis.readInt();<br>            <span class="hljs-type">double</span> <span class="hljs-variable">price</span> <span class="hljs-operator">=</span> dis.readDouble();<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">isAvailable</span> <span class="hljs-operator">=</span> dis.readBoolean();<br>            <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> dis.readUTF();<br><br>            System.out.println(<span class="hljs-string">&quot;读取数据：&quot;</span> + num + <span class="hljs-string">&quot;, &quot;</span> + price + <span class="hljs-string">&quot;, &quot;</span> + isAvailable + <span class="hljs-string">&quot;, &quot;</span> + message);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>🔹 适用场景</strong>：</p><ul><li>读写 <strong>二进制数据</strong>（如数据库存储、网络传输）。</li><li>避免 <strong>数据类型转换错误</strong>（如直接用 <code>FileWriter</code> 可能导致数据变成字符串格式）。</li></ul><hr><h2 id="✅-2-转换流（InputStreamReader-OutputStreamWriter）"><a href="#✅-2-转换流（InputStreamReader-OutputStreamWriter）" class="headerlink" title="✅ 2. 转换流（InputStreamReader &#x2F; OutputStreamWriter）"></a>✅ <strong>2. 转换流（InputStreamReader &#x2F; OutputStreamWriter）</strong></h2><p><strong>作用</strong>：  </p><ul><li><strong>字节流 ↔ 字符流</strong> 转换，主要用于 <strong>解决编码问题</strong>（如 <code>GBK</code> 转 <code>UTF-8</code>）。</li><li><strong>适用于处理文本数据</strong>，如从 <strong>网络流或文件流读取文本</strong>，并希望指定字符编码。</li></ul><h3 id="📌-2-1-InputStreamReader（字节流-字符流）"><a href="#📌-2-1-InputStreamReader（字节流-字符流）" class="headerlink" title="📌 2.1 InputStreamReader（字节流 -&gt; 字符流）"></a><strong>📌 2.1 InputStreamReader（字节流 -&gt; 字符流）</strong></h3><h4 id="示例：读取文件并指定编码格式"><a href="#示例：读取文件并指定编码格式" class="headerlink" title="示例：读取文件并指定编码格式"></a><strong>示例：读取文件并指定编码格式</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InputStreamReaderExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">InputStreamReader</span> <span class="hljs-variable">isr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;test.txt&quot;</span>), <span class="hljs-string">&quot;UTF-8&quot;</span>);<br>             <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(isr)) &#123;<br>            String line;<br>            <span class="hljs-keyword">while</span> ((line = br.readLine()) != <span class="hljs-literal">null</span>) &#123;<br>                System.out.println(line);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="📌-2-2-OutputStreamWriter（字符流-字节流）"><a href="#📌-2-2-OutputStreamWriter（字符流-字节流）" class="headerlink" title="📌 2.2 OutputStreamWriter（字符流 -&gt; 字节流）"></a><strong>📌 2.2 OutputStreamWriter（字符流 -&gt; 字节流）</strong></h3><h4 id="示例：写入文件并指定编码格式"><a href="#示例：写入文件并指定编码格式" class="headerlink" title="示例：写入文件并指定编码格式"></a><strong>示例：写入文件并指定编码格式</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OutputStreamWriterExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">OutputStreamWriter</span> <span class="hljs-variable">osw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OutputStreamWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;output.txt&quot;</span>), <span class="hljs-string">&quot;GBK&quot;</span>);<br>             <span class="hljs-type">BufferedWriter</span> <span class="hljs-variable">bw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedWriter</span>(osw)) &#123;<br>            bw.write(<span class="hljs-string">&quot;你好，Java IO!&quot;</span>);<br>            bw.newLine();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>🔹 适用场景</strong>：</p><ul><li><strong>读取非 UTF-8 编码的文件</strong>（如 <code>GBK</code>、<code>ISO-8859-1</code>）。</li><li><strong>解决字符编码问题</strong>，保证不同编码的文件正确读写。</li></ul><hr><h2 id="✅-3-对象流（ObjectInputStream-ObjectOutputStream）"><a href="#✅-3-对象流（ObjectInputStream-ObjectOutputStream）" class="headerlink" title="✅ 3. 对象流（ObjectInputStream &#x2F; ObjectOutputStream）"></a>✅ <strong>3. 对象流（ObjectInputStream &#x2F; ObjectOutputStream）</strong></h2><p><strong>作用</strong>：  </p><ul><li><strong>序列化（Serialize）</strong>：将 <strong>Java 对象保存到文件</strong> 或 <strong>传输到网络</strong>。</li><li><strong>反序列化（Deserialize）</strong>：将 <strong>文件或网络中的数据恢复为 Java 对象</strong>。</li></ul><h3 id="📌-3-1-ObjectOutputStream（对象序列化）"><a href="#📌-3-1-ObjectOutputStream（对象序列化）" class="headerlink" title="📌 3.1 ObjectOutputStream（对象序列化）"></a><strong>📌 3.1 ObjectOutputStream（对象序列化）</strong></h3><h4 id="示例：将对象保存到文件"><a href="#示例：将对象保存到文件" class="headerlink" title="示例：将对象保存到文件"></a><strong>示例：将对象保存到文件</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;  <span class="hljs-comment">// 必须实现 Serializable 接口</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">1L</span>; <span class="hljs-comment">// 避免反序列化失败</span><br>    String name;<br>    <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ObjectOutputStreamExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;person.dat&quot;</span>))) &#123;<br>            <span class="hljs-type">Person</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">25</span>);<br>            oos.writeObject(p);  <span class="hljs-comment">// 序列化对象</span><br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="📌-3-2-ObjectInputStream（对象反序列化）"><a href="#📌-3-2-ObjectInputStream（对象反序列化）" class="headerlink" title="📌 3.2 ObjectInputStream（对象反序列化）"></a><strong>📌 3.2 ObjectInputStream（对象反序列化）</strong></h3><h4 id="示例：从文件读取对象"><a href="#示例：从文件读取对象" class="headerlink" title="示例：从文件读取对象"></a><strong>示例：从文件读取对象</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ObjectInputStreamExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;person.dat&quot;</span>))) &#123;<br>            <span class="hljs-type">Person</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> (Person) ois.readObject();  <span class="hljs-comment">// 反序列化对象</span><br>            System.out.println(<span class="hljs-string">&quot;姓名: &quot;</span> + p.name + <span class="hljs-string">&quot;, 年龄: &quot;</span> + p.age);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException | ClassNotFoundException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>🔹 适用场景</strong>：</p><ul><li><strong>保存对象到文件</strong>，如用户数据、游戏存档等。</li><li><strong>网络传输 Java 对象</strong>（如 RMI 远程调用）。</li></ul><hr><h2 id="✅-4-标准输入-输出流（System-in-System-out）"><a href="#✅-4-标准输入-输出流（System-in-System-out）" class="headerlink" title="✅ 4. 标准输入&#x2F;输出流（System.in &#x2F; System.out）"></a>✅ <strong>4. 标准输入&#x2F;输出流（System.in &#x2F; System.out）</strong></h2><p><strong>作用</strong>：</p><ul><li><code>System.in</code> <strong>标准输入流</strong>，通常是 <strong>键盘输入</strong>。</li><li><code>System.out</code> <strong>标准输出流</strong>，通常是 <strong>控制台输出</strong>。</li></ul><h3 id="📌-4-1-使用-Scanner-读取标准输入"><a href="#📌-4-1-使用-Scanner-读取标准输入" class="headerlink" title="📌 4.1 使用 Scanner 读取标准输入"></a><strong>📌 4.1 使用 <code>Scanner</code> 读取标准输入</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StandardInputExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        System.out.print(<span class="hljs-string">&quot;请输入你的名字：&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> scanner.nextLine();<br>        System.out.println(<span class="hljs-string">&quot;你好, &quot;</span> + name + <span class="hljs-string">&quot;!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="✅-5-打印流（PrintStream-PrintWriter）"><a href="#✅-5-打印流（PrintStream-PrintWriter）" class="headerlink" title="✅ 5. 打印流（PrintStream &#x2F; PrintWriter）"></a>✅ <strong>5. 打印流（PrintStream &#x2F; PrintWriter）</strong></h2><p><strong>作用</strong>：</p><ul><li><code>PrintStream</code> 和 <code>PrintWriter</code> 用于 <strong>格式化打印</strong>（如 <code>System.out.println()</code>）。</li><li><strong>自动刷新</strong>，适用于 <strong>日志记录、控制台输出等</strong>。</li></ul><h3 id="📌-5-1-使用-PrintWriter-写入文件"><a href="#📌-5-1-使用-PrintWriter-写入文件" class="headerlink" title="📌 5.1 使用 PrintWriter 写入文件"></a><strong>📌 5.1 使用 <code>PrintWriter</code> 写入文件</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PrintWriterExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">PrintWriter</span> <span class="hljs-variable">pw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(<span class="hljs-string">&quot;log.txt&quot;</span>), <span class="hljs-literal">true</span>)) &#123;<br>            pw.println(<span class="hljs-string">&quot;日志信息: 程序启动...&quot;</span>);<br>            pw.println(<span class="hljs-string">&quot;日志信息: 运行中...&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>🔹 适用场景</strong>：</p><ul><li><strong>日志文件</strong>（比 <code>FileWriter</code> 更方便）。</li><li><strong>格式化输出</strong>，如 <code>printf()</code>。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> File-IO流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>缓冲流</title>
      <link href="/2025/04/01/javaBasics/4.4.2%20%E7%BC%93%E5%86%B2%E6%B5%81/"/>
      <url>/2025/04/01/javaBasics/4.4.2%20%E7%BC%93%E5%86%B2%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-缓冲流（Buffered-Stream）详解"><a href="#Java-缓冲流（Buffered-Stream）详解" class="headerlink" title="Java 缓冲流（Buffered Stream）详解"></a><strong>Java 缓冲流（Buffered Stream）详解</strong></h1><p>在 Java IO 中，<strong>缓冲流（Buffered Stream）</strong> 是对基本 IO 流的 <strong>增强</strong>，它提供 <strong>缓冲区</strong> 来减少直接与硬盘或网络交互的次数，从而提高 <strong>读写效率</strong>。</p><p>Java 提供了 <strong>字节缓冲流</strong> 和 <strong>字符缓冲流</strong> 两大类，用于字节流（InputStream&#x2F;OutputStream）和字符流（Reader&#x2F;Writer）的优化。</p><hr><h2 id="✅-1-缓冲流的作用"><a href="#✅-1-缓冲流的作用" class="headerlink" title="✅ 1. 缓冲流的作用"></a>✅ <strong>1. 缓冲流的作用</strong></h2><ul><li><strong>减少 IO 操作次数</strong>：普通流每次 <code>read()</code> 或 <code>write()</code> 操作都会进行 <strong>一次磁盘 IO</strong>，而缓冲流会 <strong>一次性读取&#x2F;写入多个字节或字符</strong>，提高性能。</li><li><strong>提高读写效率</strong>：缓存数据到 <strong>内存缓冲区</strong>，减少对底层物理设备的直接访问，提高程序性能。</li><li><strong>提供更方便的方法</strong>：如 <code>BufferedReader.readLine()</code> 可直接 <strong>读取一整行</strong>，比 <code>FileReader.read()</code> 逐个字符读取更高效。</li></ul><hr><h2 id="✅-2-缓冲流的分类"><a href="#✅-2-缓冲流的分类" class="headerlink" title="✅ 2. 缓冲流的分类"></a>✅ <strong>2. 缓冲流的分类</strong></h2><p>缓冲流分为 <strong>字节缓冲流</strong> 和 <strong>字符缓冲流</strong>：</p><table><thead><tr><th><strong>流类型</strong></th><th><strong>对应的普通流</strong></th><th><strong>缓冲流</strong></th></tr></thead><tbody><tr><td><strong>字节输入流</strong></td><td><code>FileInputStream</code></td><td><code>BufferedInputStream</code></td></tr><tr><td><strong>字节输出流</strong></td><td><code>FileOutputStream</code></td><td><code>BufferedOutputStream</code></td></tr><tr><td><strong>字符输入流</strong></td><td><code>FileReader</code></td><td><code>BufferedReader</code></td></tr><tr><td><strong>字符输出流</strong></td><td><code>FileWriter</code></td><td><code>BufferedWriter</code></td></tr></tbody></table><hr><h2 id="✅-3-字节缓冲流（BufferedInputStream-BufferedOutputStream）"><a href="#✅-3-字节缓冲流（BufferedInputStream-BufferedOutputStream）" class="headerlink" title="✅ 3. 字节缓冲流（BufferedInputStream &#x2F; BufferedOutputStream）"></a>✅ <strong>3. 字节缓冲流（BufferedInputStream &#x2F; BufferedOutputStream）</strong></h2><h3 id="📌-3-1-字节缓冲输入流-BufferedInputStream"><a href="#📌-3-1-字节缓冲输入流-BufferedInputStream" class="headerlink" title="📌 3.1 字节缓冲输入流 BufferedInputStream"></a>📌 <strong>3.1 字节缓冲输入流 <code>BufferedInputStream</code></strong></h3><p>用于 <strong>加快字节读取速度</strong>，它会 <strong>一次性读取较大块数据到缓冲区</strong>，然后从缓冲区按需提供数据，而不是每次都直接访问文件。</p><h4 id="示例：使用-BufferedInputStream-读取文件"><a href="#示例：使用-BufferedInputStream-读取文件" class="headerlink" title="示例：使用 BufferedInputStream 读取文件"></a><strong>示例：使用 <code>BufferedInputStream</code> 读取文件</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BufferedInputStreamExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">BufferedInputStream</span> <span class="hljs-variable">bis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;test.txt&quot;</span>))) &#123;<br>            <span class="hljs-type">int</span> data;<br>            <span class="hljs-keyword">while</span> ((data = bis.read()) != -<span class="hljs-number">1</span>) &#123;<br>                System.out.print((<span class="hljs-type">char</span>) data);  <span class="hljs-comment">// 逐字节读取</span><br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>🔹 <strong>和 <code>FileInputStream</code> 的区别</strong>：</p><ul><li><code>FileInputStream.read()</code> 每次 <strong>读取一个字节</strong>，如果文件很大，会频繁访问磁盘，效率低。</li><li><code>BufferedInputStream</code> <strong>一次性读取多个字节</strong>，减少磁盘访问次数，提高效率。</li></ul><hr><h3 id="📌-3-2-字节缓冲输出流-BufferedOutputStream"><a href="#📌-3-2-字节缓冲输出流-BufferedOutputStream" class="headerlink" title="📌 3.2 字节缓冲输出流 BufferedOutputStream"></a>📌 <strong>3.2 字节缓冲输出流 <code>BufferedOutputStream</code></strong></h3><p>用于 <strong>加快字节写入速度</strong>，它会 <strong>先写入缓冲区</strong>，当缓冲区满了或 <code>flush()</code> 被调用时，才会将数据写入目标文件。</p><h4 id="示例：使用-BufferedOutputStream-写入文件"><a href="#示例：使用-BufferedOutputStream-写入文件" class="headerlink" title="示例：使用 BufferedOutputStream 写入文件"></a><strong>示例：使用 <code>BufferedOutputStream</code> 写入文件</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BufferedOutputStreamExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">BufferedOutputStream</span> <span class="hljs-variable">bos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;output.txt&quot;</span>))) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello, Java IO!&quot;</span>;<br>            bos.write(data.getBytes());  <span class="hljs-comment">// 先写入缓冲区</span><br>            bos.flush();  <span class="hljs-comment">// 强制刷新缓冲区，确保数据写入文件</span><br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>🔹 <strong>重点：</strong></p><ul><li><code>flush()</code> 方法 <strong>强制写出缓冲区数据</strong>，确保数据及时保存到文件。</li><li><strong>若不调用 <code>flush()</code> 或 <code>close()</code>，可能导致部分数据未写入文件</strong>。</li></ul><hr><h2 id="✅-4-字符缓冲流（BufferedReader-BufferedWriter）"><a href="#✅-4-字符缓冲流（BufferedReader-BufferedWriter）" class="headerlink" title="✅ 4. 字符缓冲流（BufferedReader &#x2F; BufferedWriter）"></a>✅ <strong>4. 字符缓冲流（BufferedReader &#x2F; BufferedWriter）</strong></h2><p><strong>字符缓冲流</strong> 用于 <strong>文本文件</strong> 的高效读写，它基于 <code>Reader</code> &#x2F; <code>Writer</code>，支持 <strong>整行读取、写入</strong>。</p><hr><h3 id="📌-4-1-字符缓冲输入流-BufferedReader"><a href="#📌-4-1-字符缓冲输入流-BufferedReader" class="headerlink" title="📌 4.1 字符缓冲输入流 BufferedReader"></a>📌 <strong>4.1 字符缓冲输入流 <code>BufferedReader</code></strong></h3><p>相比 <code>FileReader</code>，<code>BufferedReader</code> 提供了 <strong>按行读取</strong> 的方法，适用于读取 <strong>文本文件</strong>。</p><h4 id="示例：使用-BufferedReader-按行读取文件"><a href="#示例：使用-BufferedReader-按行读取文件" class="headerlink" title="示例：使用 BufferedReader 按行读取文件"></a><strong>示例：使用 <code>BufferedReader</code> 按行读取文件</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BufferedReaderExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">&quot;test.txt&quot;</span>))) &#123;<br>            String line;<br>            <span class="hljs-keyword">while</span> ((line = br.readLine()) != <span class="hljs-literal">null</span>) &#123;  <span class="hljs-comment">// 按行读取，提高效率</span><br>                System.out.println(line);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>🔹 <strong>为什么 <code>BufferedReader</code> 比 <code>FileReader</code> 更高效？</strong></p><ul><li><code>BufferedReader.readLine()</code> <strong>一次性读取一整行</strong>，避免多次调用 <code>read()</code>，减少 IO 操作。</li><li><strong>适用于读取大文本文件</strong>，如日志分析、配置文件解析等。</li></ul><hr><h3 id="📌-4-2-字符缓冲输出流-BufferedWriter"><a href="#📌-4-2-字符缓冲输出流-BufferedWriter" class="headerlink" title="📌 4.2 字符缓冲输出流 BufferedWriter"></a>📌 <strong>4.2 字符缓冲输出流 <code>BufferedWriter</code></strong></h3><p>用于 <strong>高效写入文本文件</strong>，支持 <strong>写入换行</strong>（<code>newLine()</code> 方法）。</p><h4 id="示例：使用-BufferedWriter-写入文本"><a href="#示例：使用-BufferedWriter-写入文本" class="headerlink" title="示例：使用 BufferedWriter 写入文本"></a><strong>示例：使用 <code>BufferedWriter</code> 写入文本</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BufferedWriterExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">BufferedWriter</span> <span class="hljs-variable">bw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(<span class="hljs-string">&quot;output.txt&quot;</span>))) &#123;<br>            bw.write(<span class="hljs-string">&quot;Hello, Java IO!&quot;</span>);<br>            bw.newLine();  <span class="hljs-comment">// 写入换行符</span><br>            bw.write(<span class="hljs-string">&quot;This is a new line.&quot;</span>);<br>            bw.flush();  <span class="hljs-comment">// 刷新缓冲区</span><br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>🔹 <strong>重点：</strong></p><ul><li><code>newLine()</code> <strong>写入换行符</strong>，兼容不同操作系统（Windows: <code>\r\n</code>，Linux: <code>\n</code>）。</li><li><code>flush()</code> <strong>强制将数据从缓冲区写入文件</strong>，保证数据不会丢失。</li></ul><hr><h2 id="✅-5-缓冲流-vs-普通流-性能对比"><a href="#✅-5-缓冲流-vs-普通流-性能对比" class="headerlink" title="✅ 5. 缓冲流 vs 普通流 性能对比"></a>✅ <strong>5. 缓冲流 vs 普通流 性能对比</strong></h2><h3 id="普通流-vs-缓冲流"><a href="#普通流-vs-缓冲流" class="headerlink" title="普通流 vs 缓冲流"></a><strong>普通流 vs 缓冲流</strong></h3><table><thead><tr><th><strong>操作</strong></th><th><strong>普通流（FileInputStream）</strong></th><th><strong>缓冲流（BufferedInputStream）</strong></th></tr></thead><tbody><tr><td><strong>读取方式</strong></td><td>逐字节读取，每次访问磁盘</td><td>先读入缓冲区，再批量返回</td></tr><tr><td><strong>写入方式</strong></td><td>逐字节写入，每次写入磁盘</td><td>先写入缓冲区，满了再写入磁盘</td></tr><tr><td><strong>适用场景</strong></td><td>小文件、零散数据读写</td><td>大文件、高频读写</td></tr><tr><td><strong>性能</strong></td><td>低效</td><td>高效</td></tr></tbody></table><p>如果 <strong>文件较大</strong> 或 <strong>读写操作频繁</strong>，<strong>建议使用缓冲流</strong> 来提升性能。</p><hr><h2 id="✅-6-总结"><a href="#✅-6-总结" class="headerlink" title="✅ 6. 总结"></a>✅ <strong>6. 总结</strong></h2><table><thead><tr><th><strong>流类型</strong></th><th><strong>用于</strong></th><th><strong>适用场景</strong></th><th><strong>常用方法</strong></th></tr></thead><tbody><tr><td><code>BufferedInputStream</code></td><td><strong>字节输入</strong>（加快读取）</td><td>读取二进制文件（图片、视频）</td><td><code>read()</code></td></tr><tr><td><code>BufferedOutputStream</code></td><td><strong>字节输出</strong>（加快写入）</td><td>写入二进制文件</td><td><code>write()</code>、<code>flush()</code></td></tr><tr><td><code>BufferedReader</code></td><td><strong>字符输入</strong>（按行读取）</td><td>读取文本文件（日志、CSV）</td><td><code>readLine()</code></td></tr><tr><td><code>BufferedWriter</code></td><td><strong>字符输出</strong>（高效写入）</td><td>写入文本文件</td><td><code>write()</code>、<code>newLine()</code></td></tr></tbody></table><p>💡 <strong>推荐使用缓冲流！</strong> 在 <strong>处理大文件、提高 IO 效率</strong> 方面，缓冲流是 <strong>优先选择</strong>。🚀</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> File-IO流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IO流概述</title>
      <link href="/2025/04/01/javaBasics/4.4.1%20IO%E6%B5%81/"/>
      <url>/2025/04/01/javaBasics/4.4.1%20IO%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-IO-流详解"><a href="#Java-IO-流详解" class="headerlink" title="Java IO 流详解"></a><strong>Java IO 流详解</strong></h1><p><strong>IO（Input&#x2F;Output，输入&#x2F;输出）流</strong> 是 Java 处理数据读取和写入的基础，广泛用于文件操作、网络通信、数据传输等场景。Java 的 IO 主要分为 <strong>字节流</strong> 和 <strong>字符流</strong>，并且提供了 <strong>缓冲流</strong>、<strong>数据流</strong>、<strong>对象流</strong> 等高级流来提高效率和扩展功能。</p><hr><h2 id="✅-1-Java-IO-流的基本分类"><a href="#✅-1-Java-IO-流的基本分类" class="headerlink" title="✅ 1. Java IO 流的基本分类"></a>✅ <strong>1. Java IO 流的基本分类</strong></h2><p>Java 的 IO 流可以从不同维度进行分类：</p><h3 id="按数据类型分类"><a href="#按数据类型分类" class="headerlink" title="按数据类型分类"></a><strong>按数据类型分类</strong></h3><table><thead><tr><th><strong>流类型</strong></th><th><strong>作用</strong></th><th><strong>常用类</strong></th></tr></thead><tbody><tr><td><strong>字节流</strong></td><td>以 <strong>字节（8bit）</strong> 方式操作数据，适用于所有类型文件（文本、图片、视频）</td><td><code>InputStream</code> &#x2F; <code>OutputStream</code></td></tr><tr><td><strong>字符流</strong></td><td>以 <strong>字符（16bit）</strong> 方式操作数据，适用于文本文件（txt、csv、json）</td><td><code>Reader</code> &#x2F; <code>Writer</code></td></tr></tbody></table><h3 id="按数据流向分类"><a href="#按数据流向分类" class="headerlink" title="按数据流向分类"></a><strong>按数据流向分类</strong></h3><table><thead><tr><th><strong>方向</strong></th><th><strong>作用</strong></th><th><strong>字节流</strong></th><th><strong>字符流</strong></th></tr></thead><tbody><tr><td><strong>输入流</strong></td><td>从外部（文件、网络）读数据</td><td><code>InputStream</code></td><td><code>Reader</code></td></tr><tr><td><strong>输出流</strong></td><td>向外部（文件、网络）写数据</td><td><code>OutputStream</code></td><td><code>Writer</code></td></tr></tbody></table><hr><h2 id="✅-2-字节流（InputStream-OutputStream）"><a href="#✅-2-字节流（InputStream-OutputStream）" class="headerlink" title="✅ 2. 字节流（InputStream &#x2F; OutputStream）"></a>✅ <strong>2. 字节流（InputStream &#x2F; OutputStream）</strong></h2><p><strong>字节流（Byte Stream）</strong> 适用于处理所有类型的数据，如 <strong>图片、音频、视频、二进制文件</strong>，它不会对数据进行编码转换。</p><h3 id="📌-2-1-字节输入流（InputStream）"><a href="#📌-2-1-字节输入流（InputStream）" class="headerlink" title="📌 2.1 字节输入流（InputStream）"></a><strong>📌 2.1 字节输入流（InputStream）</strong></h3><p>用于 <strong>读取</strong> 字节数据，常见的子类有：</p><ul><li><code>FileInputStream</code>  —— 读取文件</li><li><code>BufferedInputStream</code>  —— 带缓冲，提高读取效率</li><li><code>DataInputStream</code>  —— 读取基本数据类型（<code>int</code>、<code>double</code> 等）</li></ul><h4 id="示例：使用-FileInputStream-读取文件"><a href="#示例：使用-FileInputStream-读取文件" class="headerlink" title="示例：使用 FileInputStream 读取文件"></a><strong>示例：使用 <code>FileInputStream</code> 读取文件</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.FileInputStream;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileInputStreamExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;test.txt&quot;</span>)) &#123;<br>            <span class="hljs-type">int</span> data;<br>            <span class="hljs-keyword">while</span> ((data = fis.read()) != -<span class="hljs-number">1</span>) &#123;<br>                System.out.print((<span class="hljs-type">char</span>) data);  <span class="hljs-comment">// 逐字节读取并转换为字符</span><br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>🔹 <code>read()</code> 方法 <strong>每次读取 1 个字节</strong>，<code>-1</code> 表示文件读取结束。</p><hr><h3 id="📌-2-2-字节输出流（OutputStream）"><a href="#📌-2-2-字节输出流（OutputStream）" class="headerlink" title="📌 2.2 字节输出流（OutputStream）"></a><strong>📌 2.2 字节输出流（OutputStream）</strong></h3><p>用于 <strong>写入</strong> 字节数据，常见的子类有：</p><ul><li><code>FileOutputStream</code>  —— 写入文件</li><li><code>BufferedOutputStream</code>  —— 带缓冲，提高写入效率</li><li><code>DataOutputStream</code>  —— 写入基本数据类型</li></ul><h4 id="示例：使用-FileOutputStream-写入文件"><a href="#示例：使用-FileOutputStream-写入文件" class="headerlink" title="示例：使用 FileOutputStream 写入文件"></a><strong>示例：使用 <code>FileOutputStream</code> 写入文件</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.FileOutputStream;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileOutputStreamExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;output.txt&quot;</span>)) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello, Java IO!&quot;</span>;<br>            fos.write(data.getBytes());  <span class="hljs-comment">// 将字符串转换为字节数组写入</span><br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>🔹 <code>getBytes()</code> 方法将字符串转换为 <strong>字节数组</strong> 后写入文件。</p><hr><h2 id="✅-3-字符流（Reader-Writer）"><a href="#✅-3-字符流（Reader-Writer）" class="headerlink" title="✅ 3. 字符流（Reader &#x2F; Writer）"></a>✅ <strong>3. 字符流（Reader &#x2F; Writer）</strong></h2><p><strong>字符流（Character Stream）</strong> 适用于处理 <strong>文本文件</strong>，它使用 <strong>Unicode 编码</strong>，自动处理字符编码转换。</p><h3 id="📌-3-1-字符输入流（Reader）"><a href="#📌-3-1-字符输入流（Reader）" class="headerlink" title="📌 3.1 字符输入流（Reader）"></a><strong>📌 3.1 字符输入流（Reader）</strong></h3><p>用于 <strong>读取</strong> 字符数据，常见的子类有：</p><ul><li><code>FileReader</code>  —— 读取文件</li><li><code>BufferedReader</code>  —— 带缓冲，提高读取效率</li><li><code>InputStreamReader</code>  —— <strong>字节流转字符流</strong>（可指定编码）</li></ul><h4 id="示例：使用-BufferedReader-逐行读取文本"><a href="#示例：使用-BufferedReader-逐行读取文本" class="headerlink" title="示例：使用 BufferedReader 逐行读取文本"></a><strong>示例：使用 <code>BufferedReader</code> 逐行读取文本</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.BufferedReader;<br><span class="hljs-keyword">import</span> java.io.FileReader;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BufferedReaderExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">&quot;test.txt&quot;</span>))) &#123;<br>            String line;<br>            <span class="hljs-keyword">while</span> ((line = br.readLine()) != <span class="hljs-literal">null</span>) &#123;<br>                System.out.println(line);  <span class="hljs-comment">// 按行读取，提高效率</span><br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>🔹 <code>readLine()</code> 方法每次 <strong>读取一整行</strong>，比 <code>read()</code> 更高效。</p><hr><h3 id="📌-3-2-字符输出流（Writer）"><a href="#📌-3-2-字符输出流（Writer）" class="headerlink" title="📌 3.2 字符输出流（Writer）"></a><strong>📌 3.2 字符输出流（Writer）</strong></h3><p>用于 <strong>写入</strong> 字符数据，常见的子类有：</p><ul><li><code>FileWriter</code>  —— 写入文件</li><li><code>BufferedWriter</code>  —— 带缓冲，提高写入效率</li><li><code>OutputStreamWriter</code>  —— <strong>字节流转字符流</strong>（可指定编码）</li></ul><h4 id="示例：使用-BufferedWriter-写入文本"><a href="#示例：使用-BufferedWriter-写入文本" class="headerlink" title="示例：使用 BufferedWriter 写入文本"></a><strong>示例：使用 <code>BufferedWriter</code> 写入文本</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.BufferedWriter;<br><span class="hljs-keyword">import</span> java.io.FileWriter;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BufferedWriterExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">BufferedWriter</span> <span class="hljs-variable">bw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(<span class="hljs-string">&quot;output.txt&quot;</span>))) &#123;<br>            bw.write(<span class="hljs-string">&quot;Hello, Java IO!&quot;</span>);<br>            bw.newLine();  <span class="hljs-comment">// 写入换行符</span><br>            bw.write(<span class="hljs-string">&quot;This is a new line.&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>🔹 <code>newLine()</code> 方法写入 <strong>换行符</strong>，适用于多行文本文件。</p><hr><h2 id="✅-4-高级-IO-流"><a href="#✅-4-高级-IO-流" class="headerlink" title="✅ 4. 高级 IO 流"></a>✅ <strong>4. 高级 IO 流</strong></h2><p>除了基本的 <code>InputStream</code> 和 <code>Reader</code>，Java 还提供了 <strong>高级流</strong> 以提高性能和扩展功能。</p><table><thead><tr><th><strong>流类型</strong></th><th><strong>作用</strong></th><th><strong>常用类</strong></th></tr></thead><tbody><tr><td><strong>缓冲流</strong></td><td>提高读写效率</td><td><code>BufferedInputStream</code> &#x2F; <code>BufferedReader</code></td></tr><tr><td><strong>数据流</strong></td><td>读写基本数据类型（<code>int</code>、<code>double</code>）</td><td><code>DataInputStream</code> &#x2F; <code>DataOutputStream</code></td></tr><tr><td><strong>对象流</strong></td><td>读写对象（序列化）</td><td><code>ObjectInputStream</code> &#x2F; <code>ObjectOutputStream</code></td></tr><tr><td><strong>转换流</strong>（字节→字符）</td><td>处理不同编码格式的文本</td><td><code>InputStreamReader</code> &#x2F; <code>OutputStreamWriter</code></td></tr></tbody></table><h4 id="示例：对象流（对象序列化与反序列化）"><a href="#示例：对象流（对象序列化与反序列化）" class="headerlink" title="示例：对象流（对象序列化与反序列化）"></a><strong>示例：对象流（对象序列化与反序列化）</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;  <span class="hljs-comment">// 必须实现 Serializable 接口</span><br>    String name;<br>    <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ObjectStreamExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">25</span>);<br><br>        <span class="hljs-comment">// 序列化对象</span><br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;person.dat&quot;</span>))) &#123;<br>            oos.writeObject(person);<br>        &#125;<br><br>        <span class="hljs-comment">// 反序列化对象</span><br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;person.dat&quot;</span>))) &#123;<br>            <span class="hljs-type">Person</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> (Person) ois.readObject();<br>            System.out.println(<span class="hljs-string">&quot;姓名: &quot;</span> + p.name + <span class="hljs-string">&quot;, 年龄: &quot;</span> + p.age);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="✅-5-总结"><a href="#✅-5-总结" class="headerlink" title="✅ 5. 总结"></a>✅ <strong>5. 总结</strong></h2><ul><li><strong>字节流</strong>（InputStream &#x2F; OutputStream）：适用于 <strong>二进制文件</strong>（图片、视频）。</li><li><strong>字符流</strong>（Reader &#x2F; Writer）：适用于 <strong>文本文件</strong>（txt、json）。</li><li><strong>缓冲流</strong>（BufferedReader &#x2F; BufferedWriter）：提高 IO <strong>性能</strong>。</li><li><strong>对象流</strong>（ObjectInputStream &#x2F; ObjectOutputStream）：<strong>对象序列化</strong> 和 反序列化。</li></ul><p>理解这些流的区别和应用场景，可以帮助你更高效地进行文件处理和数据流操作！🚀</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> File-IO流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符集</title>
      <link href="/2025/04/01/javaBasics/4.3%20%E5%AD%97%E7%AC%A6%E9%9B%86/"/>
      <url>/2025/04/01/javaBasics/4.3%20%E5%AD%97%E7%AC%A6%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h1 id="字符集（Character-Set）详解"><a href="#字符集（Character-Set）详解" class="headerlink" title="字符集（Character Set）详解"></a><strong>字符集（Character Set）详解</strong></h1><p>字符集是计算机存储、表示和处理文本的重要基础。在 Java 和许多编程语言中，正确理解字符集对于处理国际化、多语言文本至关重要。本文将介绍字符集的基本概念、常见字符集类型，以及 Java 中的字符集处理。</p><hr><h2 id="✅-1-什么是字符集？"><a href="#✅-1-什么是字符集？" class="headerlink" title="✅ 1. 什么是字符集？"></a>✅ <strong>1. 什么是字符集？</strong></h2><p>字符集（Character Set，简称 Charset）是一种映射规则，它将 <strong>字符（human-readable）</strong> 映射到 <strong>字节（machine-readable）</strong>。常见的字符集包括 <code>ASCII</code>、<code>ISO-8859-1</code>、<code>UTF-8</code>、<code>GBK</code> 等。</p><p>在计算机存储和传输文本时，字符必须转换为 <strong>字节</strong>。字符集定义了 <strong>字符与字节之间的映射关系</strong>，不同的字符集可能会导致同样的字符对应不同的字节序列。</p><hr><h2 id="✅-2-常见的字符集"><a href="#✅-2-常见的字符集" class="headerlink" title="✅ 2. 常见的字符集"></a>✅ <strong>2. 常见的字符集</strong></h2><table><thead><tr><th><strong>字符集</strong></th><th><strong>字节数</strong></th><th><strong>编码特点</strong></th></tr></thead><tbody><tr><td><strong>ASCII</strong></td><td>1 字节</td><td>仅支持英文，范围 <code>0-127</code>，最基础的字符集</td></tr><tr><td><strong>ISO-8859-1</strong></td><td>1 字节</td><td>兼容 ASCII，支持西欧语言（拉丁字母）</td></tr><tr><td><strong>GB2312</strong></td><td>2 字节</td><td>早期的简体中文字符集</td></tr><tr><td><strong>GBK</strong></td><td>2 字节</td><td><code>GB2312</code> 的扩展，支持更多汉字</td></tr><tr><td><strong>GB18030</strong></td><td>1-4 字节</td><td>GBK 的升级版，支持所有汉字</td></tr><tr><td><strong>UTF-8</strong></td><td>1-4 字节</td><td>变长编码，广泛使用，兼容 ASCII</td></tr><tr><td><strong>UTF-16</strong></td><td>2 或 4 字节</td><td>统一编码所有字符，不同系统对高低字节存储有不同</td></tr><tr><td><strong>UTF-32</strong></td><td>4 字节</td><td>固定 4 字节编码，空间占用较大</td></tr></tbody></table><hr><h2 id="✅-3-字符编码与解码"><a href="#✅-3-字符编码与解码" class="headerlink" title="✅ 3. 字符编码与解码"></a>✅ <strong>3. 字符编码与解码</strong></h2><p>字符编码（Encoding）是将字符转换为字节，而字符解码（Decoding）是将字节还原为字符。字符集的错误使用可能导致 <strong>乱码</strong>。</p><h3 id="示例：字符编码"><a href="#示例：字符编码" class="headerlink" title="示例：字符编码"></a><strong>示例：字符编码</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.nio.charset.Charset;<br><span class="hljs-keyword">import</span> java.nio.charset.StandardCharsets;<br><span class="hljs-keyword">import</span> java.util.Arrays;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CharsetExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">text</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;你好&quot;</span>; <span class="hljs-comment">// Unicode 字符</span><br><br>        <span class="hljs-comment">// 按不同字符集编码</span><br>        <span class="hljs-type">byte</span>[] utf8Bytes = text.getBytes(StandardCharsets.UTF_8);<br>        <span class="hljs-type">byte</span>[] gbkBytes = text.getBytes(<span class="hljs-string">&quot;GBK&quot;</span>);<br><br>        System.out.println(<span class="hljs-string">&quot;UTF-8 编码: &quot;</span> + Arrays.toString(utf8Bytes));<br>        System.out.println(<span class="hljs-string">&quot;GBK 编码: &quot;</span> + Arrays.toString(gbkBytes));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="示例：字符解码"><a href="#示例：字符解码" class="headerlink" title="示例：字符解码"></a><strong>示例：字符解码</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CharsetDecoding</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">byte</span>[] gbkBytes = &#123;-<span class="hljs-number">60</span>, -<span class="hljs-number">29</span>, -<span class="hljs-number">70</span>, -<span class="hljs-number">61</span>&#125;;  <span class="hljs-comment">// &quot;你好&quot; 的 GBK 编码</span><br><br>        <span class="hljs-comment">// 使用 GBK 解码</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">decodedText</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(gbkBytes, <span class="hljs-string">&quot;GBK&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;GBK 解码: &quot;</span> + decodedText);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果使用 <strong>错误的字符集解码</strong>，可能会出现乱码，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">wrongDecoded</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(gbkBytes, StandardCharsets.UTF_8);<br>System.out.println(<span class="hljs-string">&quot;错误解码: &quot;</span> + wrongDecoded);  <span class="hljs-comment">// 乱码</span><br></code></pre></td></tr></table></figure><hr><h2 id="✅-4-Java-中的字符集支持"><a href="#✅-4-Java-中的字符集支持" class="headerlink" title="✅ 4. Java 中的字符集支持"></a>✅ <strong>4. Java 中的字符集支持</strong></h2><p>Java 提供了 <code>java.nio.charset.Charset</code> 类来处理字符集，支持的方法包括：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Charset</span> <span class="hljs-variable">utf8</span> <span class="hljs-operator">=</span> Charset.forName(<span class="hljs-string">&quot;UTF-8&quot;</span>);<br><span class="hljs-type">Charset</span> <span class="hljs-variable">gbk</span> <span class="hljs-operator">=</span> Charset.forName(<span class="hljs-string">&quot;GBK&quot;</span>);<br><br><span class="hljs-comment">// 获取所有可用字符集</span><br>System.out.println(Charset.availableCharsets());<br></code></pre></td></tr></table></figure><p>Java 推荐使用 <strong>标准字符集</strong>（<code>StandardCharsets</code>）来避免拼写错误：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">byte</span>[] bytes = <span class="hljs-string">&quot;Hello&quot;</span>.getBytes(StandardCharsets.UTF_8);<br></code></pre></td></tr></table></figure><hr><h2 id="✅-5-乱码的原因与解决"><a href="#✅-5-乱码的原因与解决" class="headerlink" title="✅ 5. 乱码的原因与解决"></a>✅ <strong>5. 乱码的原因与解决</strong></h2><h3 id="乱码的常见原因"><a href="#乱码的常见原因" class="headerlink" title="乱码的常见原因"></a><strong>乱码的常见原因</strong></h3><ol><li><p><strong>编码与解码字符集不一致</strong></p><ul><li>例如：使用 GBK 编码却用 UTF-8 解码。</li></ul></li><li><p><strong>文件&#x2F;网络传输过程中字符集不匹配</strong></p><ul><li>例如：浏览器显示网页时未指定 <code>Content-Type</code>，导致浏览器误解编码。</li></ul></li><li><p><strong>程序默认字符集不一致</strong></p><ul><li>例如：Windows 默认 <code>GBK</code>，而 Mac&#x2F;Linux 默认 <code>UTF-8</code>。</li></ul></li></ol><h3 id="如何解决乱码"><a href="#如何解决乱码" class="headerlink" title="如何解决乱码"></a><strong>如何解决乱码</strong></h3><ul><li><strong>统一字符集</strong>：整个系统（数据库、代码、文件存储）统一使用 <code>UTF-8</code>。</li><li><strong>显式指定字符集</strong>：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">text</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(bytes, StandardCharsets.UTF_8);<br></code></pre></td></tr></table></figure></li><li><strong>文件读取时指定字符集</strong>：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BufferedReader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;file.txt&quot;</span>), <span class="hljs-string">&quot;UTF-8&quot;</span>));<br></code></pre></td></tr></table></figure></li></ul><hr><h2 id="✅-6-结论"><a href="#✅-6-结论" class="headerlink" title="✅ 6. 结论"></a>✅ <strong>6. 结论</strong></h2><ul><li><strong>字符集决定字符如何转换为字节</strong>，不同字符集的编码方式不同。</li><li><strong>Java 推荐使用 <code>UTF-8</code></strong>，因为它支持多语言，兼容 ASCII。</li><li><strong>避免乱码的关键是编码和解码一致</strong>，确保传输和存储数据时字符集匹配。</li></ul><p>正确理解字符集，能够帮助我们更好地处理跨语言、跨平台的文本数据！🚀</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> File-IO流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>方法递归搜索文件</title>
      <link href="/2025/04/01/javaBasics/4.2.2%20%E6%96%B9%E6%B3%95%E9%80%92%E5%BD%92%E6%90%9C%E7%B4%A2%E6%96%87%E4%BB%B6/"/>
      <url>/2025/04/01/javaBasics/4.2.2%20%E6%96%B9%E6%B3%95%E9%80%92%E5%BD%92%E6%90%9C%E7%B4%A2%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="使用递归方法查找文件"><a href="#使用递归方法查找文件" class="headerlink" title="使用递归方法查找文件"></a><strong>使用递归方法查找文件</strong></h1><p>在许多应用场景中，我们需要遍历目录及其子目录，查找特定的文件。使用递归方法可以简洁高效地解决此类问题。通过递归，我们能够遍历整个文件系统，逐级深入查找目标文件。</p><p>本文将通过一个例子，展示如何使用 Java 递归方法查找文件。</p><hr><h2 id="✅-递归查找文件的基本思路"><a href="#✅-递归查找文件的基本思路" class="headerlink" title="✅ 递归查找文件的基本思路"></a>✅ <strong>递归查找文件的基本思路</strong></h2><p>递归方法的核心思想是让方法不断地调用自己，以解决同类问题。对于文件查找，我们的任务是遍历目录并检查每个文件或子目录：</p><ul><li><strong>判断当前路径是否是文件</strong>：如果是文件，则检查文件名是否与目标文件名匹配。</li><li><strong>判断当前路径是否是目录</strong>：如果是目录，则进入该目录继续查找。</li></ul><p>这种方法通过递归调用来处理每个子目录，直到找到目标文件或遍历完整个文件树。</p><hr><h2 id="✅-实现步骤"><a href="#✅-实现步骤" class="headerlink" title="✅ 实现步骤"></a>✅ <strong>实现步骤</strong></h2><h3 id="1-判断当前路径是否是有效的目录或文件"><a href="#1-判断当前路径是否是有效的目录或文件" class="headerlink" title="1. 判断当前路径是否是有效的目录或文件"></a><strong>1. 判断当前路径是否是有效的目录或文件</strong></h3><p>首先，检查当前传入的目录是否存在且是一个有效的目录。如果不是，直接返回。</p><h3 id="2-获取当前目录下的所有文件和子目录"><a href="#2-获取当前目录下的所有文件和子目录" class="headerlink" title="2. 获取当前目录下的所有文件和子目录"></a><strong>2. 获取当前目录下的所有文件和子目录</strong></h3><p>通过 <code>File</code> 类的 <code>listFiles()</code> 方法获取当前目录下的所有文件和子目录。</p><h3 id="3-遍历当前目录的每个文件或子目录"><a href="#3-遍历当前目录的每个文件或子目录" class="headerlink" title="3. 遍历当前目录的每个文件或子目录"></a><strong>3. 遍历当前目录的每个文件或子目录</strong></h3><p>对于目录中的每个文件和子目录：</p><ul><li>如果是文件，判断文件名是否与目标文件名匹配。</li><li>如果是目录，则递归调用查找函数，进入子目录继续查找。</li></ul><h3 id="4-找到目标文件后执行操作"><a href="#4-找到目标文件后执行操作" class="headerlink" title="4. 找到目标文件后执行操作"></a><strong>4. 找到目标文件后执行操作</strong></h3><p>一旦找到目标文件，可以执行一些操作，例如打印文件路径，或者使用 <code>Runtime</code> 类打开该文件。</p><hr><h2 id="✅-示例：递归查找文件"><a href="#✅-示例：递归查找文件" class="headerlink" title="✅ 示例：递归查找文件"></a>✅ <strong>示例：递归查找文件</strong></h2><p>以下是一个 Java 程序，演示如何递归查找 <code>D:</code> 盘下的 <code>QQ.exe</code> 文件，并启动该文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.File;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileSearchTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 目标：完成文件搜索，找出 D: 盘下的 QQ.exe 的位置</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">File</span> <span class="hljs-variable">dir</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;D:/&quot;</span>);  <span class="hljs-comment">// 指定根目录 D:</span><br>            searchFile(dir, <span class="hljs-string">&quot;QQ.exe&quot;</span>);   <span class="hljs-comment">// 递归查找目标文件</span><br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 搜索文件</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> dir 搜索的目录</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> fileName 搜索的文件名称</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">searchFile</span><span class="hljs-params">(File dir, String fileName)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 1、判断极端情况：如果目录无效或是文件，直接返回</span><br>        <span class="hljs-keyword">if</span> (dir == <span class="hljs-literal">null</span> || !dir.exists() || dir.isFile()) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 2、获取当前目录下的所有文件和子目录</span><br>        File[] files = dir.listFiles();<br><br>        <span class="hljs-comment">// 3、判断当前目录下是否存在文件对象，若存在才可以遍历</span><br>        <span class="hljs-keyword">if</span> (files != <span class="hljs-literal">null</span> &amp;&amp; files.length &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 4、遍历当前目录中的每个文件或子目录</span><br>            <span class="hljs-keyword">for</span> (File file : files) &#123;<br>                <span class="hljs-comment">// 5、判断当前项是否是文件</span><br>                <span class="hljs-keyword">if</span> (file.isFile()) &#123;<br>                    <span class="hljs-comment">// 6、如果是文件，检查是否匹配目标文件名</span><br>                    <span class="hljs-keyword">if</span> (file.getName().contains(fileName)) &#123;<br>                        System.out.println(<span class="hljs-string">&quot;找到目标文件：&quot;</span> + file.getAbsolutePath()); <span class="hljs-comment">// 输出文件路径</span><br>                        <span class="hljs-comment">// 7、使用 Runtime 来打开文件，模拟启动该文件（例如启动 QQ.exe）</span><br>                        <span class="hljs-type">Runtime</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> Runtime.getRuntime();<br>                        r.exec(file.getAbsolutePath()); <span class="hljs-comment">// 启动目标文件</span><br>                    &#125;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// 8、如果是目录，递归调用 searchFile 方法继续查找</span><br>                    searchFile(file, fileName);  <span class="hljs-comment">// 递归查找子目录</span><br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a><strong>代码分析</strong></h3><ul><li><p><strong><code>main</code> 方法</strong>：首先在 <code>main</code> 方法中指定了根目录 <code>D:/</code>，并调用了 <code>searchFile</code> 方法开始递归查找 <code>QQ.exe</code> 文件。</p></li><li><p><strong><code>searchFile</code> 方法</strong>：</p><ul><li><strong>递归终止条件</strong>：如果传入的目录无效或是文件（非目录），直接返回。</li><li><strong><code>listFiles()</code> 方法</strong>：通过 <code>File</code> 类的 <code>listFiles()</code> 方法获取当前目录下的所有文件和子目录。</li><li><strong>递归过程</strong>：遍历目录中的每个文件和子目录。如果是文件且文件名包含目标文件名，则打印出文件路径并启动该文件；如果是子目录，则递归调用 <code>searchFile</code> 方法继续查找。</li></ul></li><li><p><strong><code>Runtime.getRuntime().exec()</code></strong>：当找到目标文件时，我们通过 <code>Runtime.getRuntime().exec()</code> 方法来模拟启动该文件，本例中启动了 <code>QQ.exe</code>。</p></li></ul><hr><h2 id="✅-递归查找过程"><a href="#✅-递归查找过程" class="headerlink" title="✅ 递归查找过程"></a>✅ <strong>递归查找过程</strong></h2><ol><li><strong>遍历根目录</strong>：首先会遍历 <code>D:/</code> 根目录下的所有文件和子目录。</li><li><strong>进入子目录</strong>：如果是子目录，递归进入该子目录，继续查找。</li><li><strong>匹配文件名</strong>：在每个文件中，检查其文件名是否包含 <code>QQ.exe</code>，如果匹配则打印文件路径并启动文件。</li></ol><hr><h2 id="✅-注意事项"><a href="#✅-注意事项" class="headerlink" title="✅ 注意事项"></a>✅ <strong>注意事项</strong></h2><ol><li><strong>路径问题</strong>：在实际操作中，需要确保传入的目录路径是正确的，尤其是跨平台时，路径的分隔符可能会不同（Windows 使用 <code>\</code>，而 Linux&#x2F;Mac 使用 <code>/</code>）。</li><li><strong>递归深度</strong>：如果目录层级过深，可能会出现栈溢出的情况。如果出现这种情况，可以考虑使用非递归的方法（例如栈结构）来避免栈溢出。</li><li><strong>权限问题</strong>：在某些目录中，程序可能没有足够的权限进行文件操作，需要处理权限问题。</li></ol><hr><h2 id="✅-总结"><a href="#✅-总结" class="headerlink" title="✅ 总结"></a>✅ <strong>总结</strong></h2><ul><li><strong>递归查找</strong>：递归是一种非常适合处理树形结构（如文件系统）的问题的技术。通过递归遍历目录，可以有效地查找文件或执行其他操作。</li><li><strong>目录与文件的判断</strong>：在递归过程中，使用 <code>File</code> 类的 <code>isFile()</code> 和 <code>isDirectory()</code> 方法判断文件或目录的类型，确保操作的正确性。</li><li><strong><code>Runtime</code> 类</strong>：通过 <code>Runtime.getRuntime().exec()</code> 可以执行外部命令或启动文件，本例中用来模拟启动一个程序。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> File-IO流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>方法递归</title>
      <link href="/2025/04/01/javaBasics/4.2.1%20%E6%96%B9%E6%B3%95%E9%80%92%E5%BD%92/"/>
      <url>/2025/04/01/javaBasics/4.2.1%20%E6%96%B9%E6%B3%95%E9%80%92%E5%BD%92/</url>
      
        <content type="html"><![CDATA[<h1 id="方法递归详解"><a href="#方法递归详解" class="headerlink" title="方法递归详解"></a><strong>方法递归详解</strong></h1><p><strong>递归</strong> 是一种在程序设计中非常常见的技术，它通过让一个方法调用自身来解决问题。递归通常用于那些可以分解成相同子问题的任务，如树形结构遍历、阶乘计算、斐波那契数列、深度优先搜索等。</p><p>在 Java 中，递归方法是指一个方法直接或间接地调用自己。递归必须具备两个基本要素：</p><ol><li><strong>递归条件</strong>：停止递归的条件。</li><li><strong>递归过程</strong>：方法调用自己并逐步解决问题。</li></ol><h3 id="递归的基本结构"><a href="#递归的基本结构" class="headerlink" title="递归的基本结构"></a><strong>递归的基本结构</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> returnType <span class="hljs-title function_">methodName</span><span class="hljs-params">(parameters)</span> &#123;<br>    <span class="hljs-comment">// 递归终止条件</span><br>    <span class="hljs-keyword">if</span> (terminationCondition) &#123;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 递归调用</span><br>    <span class="hljs-keyword">return</span> methodName(newParameters);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="✅-1-递归的经典示例"><a href="#✅-1-递归的经典示例" class="headerlink" title="✅ 1. 递归的经典示例"></a>✅ <strong>1. 递归的经典示例</strong></h2><h3 id="1-1-计算阶乘（Factorial）"><a href="#1-1-计算阶乘（Factorial）" class="headerlink" title="1.1 计算阶乘（Factorial）"></a><strong>1.1 计算阶乘（Factorial）</strong></h3><p>阶乘是指一个正整数及其所有小于它的正整数的积。比如，<code>5! = 5 * 4 * 3 * 2 * 1</code>。</p><h4 id="递归实现阶乘"><a href="#递归实现阶乘" class="headerlink" title="递归实现阶乘"></a><strong>递归实现阶乘</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RecursionExample</span> &#123;<br><br>    <span class="hljs-comment">// 递归计算阶乘</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">factorial</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-comment">// 递归终止条件</span><br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">// 递归过程</span><br>        <span class="hljs-keyword">return</span> n * factorial(n - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;5! = &quot;</span> + factorial(<span class="hljs-number">5</span>)); <span class="hljs-comment">// 输出 120</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>解释：</strong></p><ul><li><strong>递归终止条件</strong>：当 <code>n == 0</code> 时，返回 <code>1</code>，这是阶乘的基本情况。</li><li><strong>递归调用</strong>：通过 <code>n * factorial(n - 1)</code> 来逐步求解。</li></ul><h3 id="1-2-斐波那契数列（Fibonacci-Sequence）"><a href="#1-2-斐波那契数列（Fibonacci-Sequence）" class="headerlink" title="1.2 斐波那契数列（Fibonacci Sequence）"></a><strong>1.2 斐波那契数列（Fibonacci Sequence）</strong></h3><p>斐波那契数列是由 0 和 1 开始，之后的每个数都是前两个数的和。例如：<code>0, 1, 1, 2, 3, 5, 8, 13, ...</code></p><h4 id="递归实现斐波那契数列"><a href="#递归实现斐波那契数列" class="headerlink" title="递归实现斐波那契数列"></a><strong>递归实现斐波那契数列</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RecursionExample</span> &#123;<br><br>    <span class="hljs-comment">// 递归计算斐波那契数列</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fibonacci</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-comment">// 递归终止条件</span><br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">// 递归过程</span><br>        <span class="hljs-keyword">return</span> fibonacci(n - <span class="hljs-number">1</span>) + fibonacci(n - <span class="hljs-number">2</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Fibonacci(5) = &quot;</span> + fibonacci(<span class="hljs-number">5</span>)); <span class="hljs-comment">// 输出 5</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>解释：</strong></p><ul><li><strong>递归终止条件</strong>：当 <code>n == 0</code> 或 <code>n == 1</code> 时，返回对应的值。</li><li><strong>递归调用</strong>：通过 <code>fibonacci(n - 1) + fibonacci(n - 2)</code> 来计算当前斐波那契数。</li></ul><h3 id="1-3-计算数组的总和"><a href="#1-3-计算数组的总和" class="headerlink" title="1.3 计算数组的总和"></a><strong>1.3 计算数组的总和</strong></h3><p>递归也可以用来解决数组的处理问题，比如计算数组中所有元素的总和。</p><h4 id="递归计算数组的总和"><a href="#递归计算数组的总和" class="headerlink" title="递归计算数组的总和"></a><strong>递归计算数组的总和</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RecursionExample</span> &#123;<br><br>    <span class="hljs-comment">// 递归计算数组的总和</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-comment">// 递归终止条件</span><br>        <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-comment">// 递归过程</span><br>        <span class="hljs-keyword">return</span> arr[n - <span class="hljs-number">1</span>] + sum(arr, n - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>        System.out.println(<span class="hljs-string">&quot;数组总和 = &quot;</span> + sum(arr, arr.length)); <span class="hljs-comment">// 输出 15</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>解释：</strong></p><ul><li><strong>递归终止条件</strong>：当数组长度为 0 时，返回 <code>0</code>。</li><li><strong>递归调用</strong>：通过 <code>arr[n - 1] + sum(arr, n - 1)</code> 来逐步计算数组的总和。</li></ul><hr><h2 id="✅-2-递归的注意事项"><a href="#✅-2-递归的注意事项" class="headerlink" title="✅ 2. 递归的注意事项"></a>✅ <strong>2. 递归的注意事项</strong></h2><ol><li><p><strong>递归深度限制</strong>：每次递归调用都会占用栈空间，如果递归太深，可能会导致 <strong>StackOverflowError</strong>。对于一些问题，可以通过 <strong>尾递归</strong> 或 <strong>迭代</strong> 来避免栈溢出。</p></li><li><p><strong>递归的性能问题</strong>：某些递归问题（如斐波那契数列）可以通过 <strong>动态规划</strong> 或 <strong>记忆化递归</strong> 来优化，避免重复计算。</p></li></ol><hr><h2 id="✅-3-递归的优化：尾递归"><a href="#✅-3-递归的优化：尾递归" class="headerlink" title="✅ 3. 递归的优化：尾递归"></a>✅ <strong>3. 递归的优化：尾递归</strong></h2><p>尾递归是指递归调用出现在函数的最后一步，而且其返回值直接是递归调用的返回值。尾递归可以优化为迭代，避免占用过多的栈空间。</p><h3 id="3-1-尾递归示例"><a href="#3-1-尾递归示例" class="headerlink" title="3.1 尾递归示例"></a><strong>3.1 尾递归示例</strong></h3><p>假设我们要计算阶乘，如果实现是尾递归的，它就可以减少递归调用的栈空间占用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RecursionExample</span> &#123;<br><br>    <span class="hljs-comment">// 尾递归计算阶乘</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">factorialTailRecursion</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> accumulator)</span> &#123;<br>        <span class="hljs-comment">// 递归终止条件</span><br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> accumulator;<br>        &#125;<br>        <span class="hljs-comment">// 递归过程，直接在递归调用中传递结果</span><br>        <span class="hljs-keyword">return</span> factorialTailRecursion(n - <span class="hljs-number">1</span>, n * accumulator);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;5! = &quot;</span> + factorialTailRecursion(<span class="hljs-number">5</span>, <span class="hljs-number">1</span>)); <span class="hljs-comment">// 输出 120</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>解释：</strong></p><ul><li>通过 <code>accumulator</code> 累积计算结果，使得递归调用不需要保存多个栈帧，从而避免栈溢出。</li><li>这种方式可以通过 <strong>尾调用优化</strong>（Tail Call Optimization）在一些语言中得到优化（Java 不直接支持，但其他语言如 Scala 会进行尾递归优化）。</li></ul><hr><h2 id="✅-4-递归的应用场景"><a href="#✅-4-递归的应用场景" class="headerlink" title="✅ 4. 递归的应用场景"></a>✅ <strong>4. 递归的应用场景</strong></h2><ol><li><strong>树形结构的遍历</strong>：例如，遍历文件夹和文件系统（如前面提到的递归查找文件的例子）。</li><li><strong>图的深度优先搜索（DFS）</strong>：递归可以用来实现图的深度优先搜索。</li><li><strong>回溯算法</strong>：如排列组合问题、迷宫问题等。</li><li><strong>分治算法</strong>：如快速排序、归并排序等。</li></ol><hr><h2 id="✅-5-总结"><a href="#✅-5-总结" class="headerlink" title="✅ 5. 总结"></a>✅ <strong>5. 总结</strong></h2><ul><li><strong>递归</strong> 是一种通过自我调用解决问题的编程技术，适用于可以分解成相同子问题的场景。</li><li>递归的关键在于设计递归终止条件和递归过程。</li><li><strong>递归的效率</strong>：需要避免不必要的重复计算，并考虑递归深度对性能的影响。</li><li><strong>尾递归优化</strong>：尾递归可以减少栈的占用，但 Java 本身不支持尾递归优化。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> File-IO流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>File</title>
      <link href="/2025/04/01/javaBasics/4.1%20File/"/>
      <url>/2025/04/01/javaBasics/4.1%20File/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-中的-File-类详解"><a href="#Java-中的-File-类详解" class="headerlink" title="Java 中的 File 类详解"></a><strong>Java 中的 <code>File</code> 类详解</strong></h1><p>在 Java 中，<code>File</code> 类是用于与文件和目录进行交互的核心类。通过 <code>File</code> 类，你可以进行文件的创建、删除、重命名、路径获取等操作。<code>File</code> 类并不直接用于文件内容的读写，而是用来表示文件和目录的路径，它允许你对文件系统进行操作。</p><p><code>File</code> 类位于 <code>java.io</code> 包下。</p><hr><h2 id="✅-1-File-类的基本构造函数"><a href="#✅-1-File-类的基本构造函数" class="headerlink" title="✅ 1. File 类的基本构造函数"></a>✅ <strong>1. <code>File</code> 类的基本构造函数</strong></h2><p><code>File</code> 类有多个构造方法，主要有以下几种：</p><h3 id="1-1-使用文件路径创建-File-对象"><a href="#1-1-使用文件路径创建-File-对象" class="headerlink" title="1.1 使用文件路径创建 File 对象"></a><strong>1.1 使用文件路径创建 <code>File</code> 对象</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;path/to/file.txt&quot;</span>);<br></code></pre></td></tr></table></figure><ul><li><strong>解释</strong>：通过指定文件的路径（可以是绝对路径或相对路径）来创建 <code>File</code> 对象。</li></ul><h3 id="1-2-使用文件路径和父目录创建-File-对象"><a href="#1-2-使用文件路径和父目录创建-File-对象" class="headerlink" title="1.2 使用文件路径和父目录创建 File 对象"></a><strong>1.2 使用文件路径和父目录创建 <code>File</code> 对象</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;path/to&quot;</span>, <span class="hljs-string">&quot;file.txt&quot;</span>);<br></code></pre></td></tr></table></figure><ul><li><strong>解释</strong>：第一个参数是父目录路径，第二个参数是文件名。</li></ul><h3 id="1-3-使用-URI-创建-File-对象"><a href="#1-3-使用-URI-创建-File-对象" class="headerlink" title="1.3 使用 URI 创建 File 对象"></a><strong>1.3 使用 <code>URI</code> 创建 <code>File</code> 对象</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">URI</span>(<span class="hljs-string">&quot;file:///path/to/file.txt&quot;</span>));<br></code></pre></td></tr></table></figure><ul><li><strong>解释</strong>：通过 URI 创建 <code>File</code> 对象。</li></ul><hr><h2 id="✅-2-File-类的常用方法"><a href="#✅-2-File-类的常用方法" class="headerlink" title="✅ 2. File 类的常用方法"></a>✅ <strong>2. <code>File</code> 类的常用方法</strong></h2><h3 id="2-1-获取文件或目录的路径"><a href="#2-1-获取文件或目录的路径" class="headerlink" title="2.1 获取文件或目录的路径"></a><strong>2.1 获取文件或目录的路径</strong></h3><ul><li><strong><code>getAbsolutePath()</code></strong>：返回文件或目录的绝对路径。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;file.txt&quot;</span>);<br>System.out.println(file.getAbsolutePath()); <span class="hljs-comment">// 输出：C:\Users\user\file.txt</span><br></code></pre></td></tr></table></figure><ul><li><strong><code>getCanonicalPath()</code></strong>：返回文件的规范路径。与 <code>getAbsolutePath()</code> 的区别在于，它会去除多余的路径（如 <code>.</code> 和 <code>..</code>）。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;file.txt&quot;</span>);<br>System.out.println(file.getCanonicalPath()); <span class="hljs-comment">// 输出：C:\Users\user\file.txt</span><br></code></pre></td></tr></table></figure><ul><li><strong><code>getName()</code></strong>：返回文件的名称。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(file.getName()); <span class="hljs-comment">// 输出：file.txt</span><br></code></pre></td></tr></table></figure><ul><li><strong><code>getParent()</code></strong>：返回文件的父目录路径。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(file.getParent()); <span class="hljs-comment">// 输出：C:\Users\user</span><br></code></pre></td></tr></table></figure><h3 id="2-2-文件存在性检查"><a href="#2-2-文件存在性检查" class="headerlink" title="2.2 文件存在性检查"></a><strong>2.2 文件存在性检查</strong></h3><ul><li><strong><code>exists()</code></strong>：判断文件或目录是否存在。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;file.txt&quot;</span>);<br>System.out.println(file.exists()); <span class="hljs-comment">// 如果文件存在，返回 true</span><br></code></pre></td></tr></table></figure><ul><li><strong><code>isFile()</code></strong>：判断是否是一个文件。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(file.isFile()); <span class="hljs-comment">// 如果是文件，返回 true</span><br></code></pre></td></tr></table></figure><ul><li><strong><code>isDirectory()</code></strong>：判断是否是一个目录。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">File</span> <span class="hljs-variable">dir</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;path/to/dir&quot;</span>);<br>System.out.println(dir.isDirectory()); <span class="hljs-comment">// 如果是目录，返回 true</span><br></code></pre></td></tr></table></figure><ul><li><strong><code>canRead()</code></strong>：检查是否可读。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(file.canRead()); <span class="hljs-comment">// 如果文件可读，返回 true</span><br></code></pre></td></tr></table></figure><ul><li><strong><code>canWrite()</code></strong>：检查是否可写。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(file.canWrite()); <span class="hljs-comment">// 如果文件可写，返回 true</span><br></code></pre></td></tr></table></figure><ul><li><strong><code>canExecute()</code></strong>：检查文件是否可执行。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(file.canExecute()); <span class="hljs-comment">// 如果文件可执行，返回 true</span><br></code></pre></td></tr></table></figure><h3 id="2-3-文件-目录操作"><a href="#2-3-文件-目录操作" class="headerlink" title="2.3 文件&#x2F;目录操作"></a><strong>2.3 文件&#x2F;目录操作</strong></h3><ul><li><strong><code>createNewFile()</code></strong>：创建一个新文件。如果文件已经存在，返回 <code>false</code>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;newfile.txt&quot;</span>);<br><span class="hljs-keyword">if</span> (file.createNewFile()) &#123;<br>    System.out.println(<span class="hljs-string">&quot;文件创建成功！&quot;</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;文件已存在！&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong><code>mkdir()</code></strong>：创建一个单一的目录。如果目录已存在，返回 <code>false</code>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">File</span> <span class="hljs-variable">dir</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;newdir&quot;</span>);<br><span class="hljs-keyword">if</span> (dir.mkdir()) &#123;<br>    System.out.println(<span class="hljs-string">&quot;目录创建成功！&quot;</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;目录已存在！&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong><code>mkdirs()</code></strong>：创建目录及其所有必要的父目录。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">File</span> <span class="hljs-variable">dir</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;parent/newdir&quot;</span>);<br><span class="hljs-keyword">if</span> (dir.mkdirs()) &#123;<br>    System.out.println(<span class="hljs-string">&quot;目录创建成功！&quot;</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;目录已存在！&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong><code>delete()</code></strong>：删除文件或目录。若是目录，则必须为空才能删除。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;file.txt&quot;</span>);<br><span class="hljs-keyword">if</span> (file.delete()) &#123;<br>    System.out.println(<span class="hljs-string">&quot;文件删除成功！&quot;</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;文件删除失败！&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong><code>renameTo(File dest)</code></strong>：将文件或目录重命名或移动到另一个路径。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">File</span> <span class="hljs-variable">oldFile</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;oldfile.txt&quot;</span>);<br><span class="hljs-type">File</span> <span class="hljs-variable">newFile</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;newfile.txt&quot;</span>);<br><span class="hljs-keyword">if</span> (oldFile.renameTo(newFile)) &#123;<br>    System.out.println(<span class="hljs-string">&quot;文件重命名成功！&quot;</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;文件重命名失败！&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-4-获取文件信息"><a href="#2-4-获取文件信息" class="headerlink" title="2.4 获取文件信息"></a><strong>2.4 获取文件信息</strong></h3><ul><li><strong><code>length()</code></strong>：返回文件的大小（以字节为单位）。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(file.length()); <span class="hljs-comment">// 输出：文件的字节大小</span><br></code></pre></td></tr></table></figure><ul><li><strong><code>lastModified()</code></strong>：返回文件最后修改的时间（以毫秒为单位）。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(file.lastModified()); <span class="hljs-comment">// 输出：最后修改时间（时间戳）</span><br></code></pre></td></tr></table></figure><ul><li><strong><code>list()</code></strong>：列出目录中所有文件和目录的名称。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">File</span> <span class="hljs-variable">dir</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;path/to/dir&quot;</span>);<br>String[] files = dir.list();<br><span class="hljs-keyword">for</span> (String file : files) &#123;<br>    System.out.println(file);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong><code>listFiles()</code></strong>：列出目录中的所有文件和目录，返回 <code>File</code> 数组。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">File</span> <span class="hljs-variable">dir</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;path/to/dir&quot;</span>);<br>File[] files = dir.listFiles();<br><span class="hljs-keyword">for</span> (File f : files) &#123;<br>    System.out.println(f.getName());<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-5-判断文件权限"><a href="#2-5-判断文件权限" class="headerlink" title="2.5 判断文件权限"></a><strong>2.5 判断文件权限</strong></h3><ul><li><strong><code>setReadable(boolean readable)</code></strong>：设置文件是否可读。</li><li><strong><code>setWritable(boolean writable)</code></strong>：设置文件是否可写。</li><li><strong><code>setExecutable(boolean executable)</code></strong>：设置文件是否可执行。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">file.setReadable(<span class="hljs-literal">true</span>); <span class="hljs-comment">// 设置文件为可读</span><br>file.setWritable(<span class="hljs-literal">true</span>); <span class="hljs-comment">// 设置文件为可写</span><br>file.setExecutable(<span class="hljs-literal">true</span>); <span class="hljs-comment">// 设置文件为可执行</span><br></code></pre></td></tr></table></figure><hr><h2 id="✅-3-File-类与其他-I-O-类的区别"><a href="#✅-3-File-类与其他-I-O-类的区别" class="headerlink" title="✅ 3. File 类与其他 I&#x2F;O 类的区别"></a>✅ <strong>3. File 类与其他 I&#x2F;O 类的区别</strong></h2><p><code>File</code> 类主要用于对文件系统进行操作（如创建、删除、查询文件），而对于文件内容的读取和写入，我们通常使用其他 I&#x2F;O 类，如 <code>FileInputStream</code>、<code>FileOutputStream</code>、<code>BufferedReader</code>、<code>BufferedWriter</code> 等。</p><hr><h2 id="✅-4-总结"><a href="#✅-4-总结" class="headerlink" title="✅ 4. 总结"></a>✅ <strong>4. 总结</strong></h2><ul><li><strong><code>File</code> 类</strong> 用于操作文件和目录，但不处理文件的内容。</li><li>通过 <code>File</code> 类，可以检查文件的存在性、获取文件信息、创建文件&#x2F;目录、删除文件、重命名文件等。</li><li><code>File</code> 类操作通常涉及与文件系统进行交互，因此它是 <code>java.io</code> 中最基本的类之一。</li><li>文件内容的读写需要结合使用其他 I&#x2F;O 类，如 <code>FileInputStream</code>、<code>FileOutputStream</code> 等。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> File-IO流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Map</title>
      <link href="/2025/03/31/javaBasics/3.5%20Map/"/>
      <url>/2025/03/31/javaBasics/3.5%20Map/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-Map-集合详解"><a href="#Java-Map-集合详解" class="headerlink" title="Java Map 集合详解"></a><strong>Java Map 集合详解</strong></h1><p><code>Map</code> 是 Java 集合框架中的一个接口，它并不继承自 <code>Collection</code>，而是用于存储 <strong>键值对</strong>（Key-Value），其中每个键（Key）对应一个值（Value）。<code>Map</code> 是一个 <strong>无序</strong> 集合，不允许键重复，但值（Value）可以重复。</p><hr><h2 id="✅-1-Map-的特点"><a href="#✅-1-Map-的特点" class="headerlink" title="✅ 1. Map 的特点"></a>✅ <strong>1. Map 的特点</strong></h2><ul><li><strong>无序性</strong>：<code>Map</code> 的键值对没有固定的顺序，具体顺序由实现类决定。</li><li><strong>键唯一性</strong>：<code>Map</code> 中的每个键都是唯一的。如果插入具有相同键的条目，后插入的值会替代之前的值。</li><li><strong>值可重复</strong>：<code>Map</code> 中的值（Value）可以重复，但键（Key）不可重复。</li></ul><hr><h2 id="✅-2-Map-的主要实现类"><a href="#✅-2-Map-的主要实现类" class="headerlink" title="✅ 2. Map 的主要实现类"></a>✅ <strong>2. Map 的主要实现类</strong></h2><table><thead><tr><th><strong>实现类</strong></th><th><strong>底层数据结构</strong></th><th><strong>特点</strong></th></tr></thead><tbody><tr><td><code>HashMap</code></td><td><strong>哈希表</strong>（<code>HashMap</code>）</td><td><strong>无序</strong>，查询、插入、删除时间复杂度 O(1)</td></tr><tr><td><code>LinkedHashMap</code></td><td><strong>哈希表 + 双向链表</strong></td><td><strong>有序</strong>（按插入顺序）</td></tr><tr><td><code>TreeMap</code></td><td><strong>红黑树（自平衡二叉树）</strong></td><td><strong>有序</strong>（按自然排序或比较器排序）</td></tr><tr><td><code>Hashtable</code></td><td><strong>哈希表</strong></td><td><strong>线程安全</strong>，性能较低（已废弃）</td></tr><tr><td><code>ConcurrentHashMap</code></td><td><strong>哈希表</strong>（线程安全）</td><td><strong>线程安全</strong>，高性能</td></tr></tbody></table><hr><h2 id="✅-3-Map-的常用方法"><a href="#✅-3-Map-的常用方法" class="headerlink" title="✅ 3. Map 的常用方法"></a>✅ <strong>3. Map 的常用方法</strong></h2><table><thead><tr><th><strong>方法</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td><code>put(K key, V value)</code></td><td>添加键值对（如果键已存在，会替换对应的值）</td></tr><tr><td><code>get(Object key)</code></td><td>获取指定键对应的值</td></tr><tr><td><code>remove(Object key)</code></td><td>删除指定键对应的键值对</td></tr><tr><td><code>containsKey(Object key)</code></td><td>判断 <code>Map</code> 是否包含指定键</td></tr><tr><td><code>containsValue(Object value)</code></td><td>判断 <code>Map</code> 是否包含指定值</td></tr><tr><td><code>size()</code></td><td>获取 <code>Map</code> 中键值对的数量</td></tr><tr><td><code>isEmpty()</code></td><td>判断 <code>Map</code> 是否为空</td></tr><tr><td><code>clear()</code></td><td>清空 <code>Map</code> 中所有的键值对</td></tr><tr><td><code>keySet()</code></td><td>获取 <code>Map</code> 中所有的键，返回一个 <code>Set</code></td></tr><tr><td><code>values()</code></td><td>获取 <code>Map</code> 中所有的值，返回一个 <code>Collection</code></td></tr><tr><td><code>entrySet()</code></td><td>获取 <code>Map</code> 中所有的键值对，返回一个 <code>Set</code></td></tr></tbody></table><hr><h2 id="✅-4-HashMap-用法"><a href="#✅-4-HashMap-用法" class="headerlink" title="✅ 4. HashMap 用法"></a>✅ <strong>4. <code>HashMap</code> 用法</strong></h2><p><code>HashMap</code> 基于 <strong>哈希表</strong> 实现，<strong>无序</strong>，<strong>线程不安全</strong>，查询和插入的时间复杂度为 <strong>O(1)</strong>。</p><h3 id="4-1-HashMap-示例"><a href="#4-1-HashMap-示例" class="headerlink" title="4.1 HashMap 示例"></a><strong>4.1 <code>HashMap</code> 示例</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HashMapExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Map&lt;String, String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>        <span class="hljs-comment">// 添加键值对</span><br>        map.put(<span class="hljs-string">&quot;Java&quot;</span>, <span class="hljs-string">&quot;OOP Language&quot;</span>);<br>        map.put(<span class="hljs-string">&quot;Python&quot;</span>, <span class="hljs-string">&quot;Scripting Language&quot;</span>);<br>        map.put(<span class="hljs-string">&quot;C++&quot;</span>, <span class="hljs-string">&quot;Compiled Language&quot;</span>);<br><br>        System.out.println(map); <span class="hljs-comment">// &#123;Java=OOP Language, Python=Scripting Language, C++=Compiled Language&#125;</span><br><br>        <span class="hljs-comment">// 获取值</span><br>        System.out.println(<span class="hljs-string">&quot;Java&#x27;s description: &quot;</span> + map.get(<span class="hljs-string">&quot;Java&quot;</span>)); <span class="hljs-comment">// OOP Language</span><br><br>        <span class="hljs-comment">// 删除键值对</span><br>        map.remove(<span class="hljs-string">&quot;Python&quot;</span>);<br>        System.out.println(map); <span class="hljs-comment">// &#123;Java=OOP Language, C++=Compiled Language&#125;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-2-遍历-HashMap"><a href="#4-2-遍历-HashMap" class="headerlink" title="4.2 遍历 HashMap"></a><strong>4.2 遍历 <code>HashMap</code></strong></h3><h4 id="方式-1：通过-keySet-遍历键"><a href="#方式-1：通过-keySet-遍历键" class="headerlink" title="方式 1：通过 keySet() 遍历键"></a><strong>方式 1：通过 <code>keySet()</code> 遍历键</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (String key : map.keySet()) &#123;<br>    System.out.println(key + <span class="hljs-string">&quot;: &quot;</span> + map.get(key));<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="方式-2：通过-entrySet-遍历键值对"><a href="#方式-2：通过-entrySet-遍历键值对" class="headerlink" title="方式 2：通过 entrySet() 遍历键值对"></a><strong>方式 2：通过 <code>entrySet()</code> 遍历键值对</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (Map.Entry&lt;String, String&gt; entry : map.entrySet()) &#123;<br>    System.out.println(entry.getKey() + <span class="hljs-string">&quot;: &quot;</span> + entry.getValue());<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="方式-3：通过-forEach（Java-8-Lambda）"><a href="#方式-3：通过-forEach（Java-8-Lambda）" class="headerlink" title="方式 3：通过 forEach（Java 8 Lambda）"></a><strong>方式 3：通过 <code>forEach</code>（Java 8 Lambda）</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">map.forEach((key, value) -&gt; System.out.println(key + <span class="hljs-string">&quot;: &quot;</span> + value));<br></code></pre></td></tr></table></figure><hr><h2 id="✅-5-LinkedHashMap-用法"><a href="#✅-5-LinkedHashMap-用法" class="headerlink" title="✅ 5. LinkedHashMap 用法"></a>✅ <strong>5. <code>LinkedHashMap</code> 用法</strong></h2><p><code>LinkedHashMap</code> 基于 <strong>哈希表 + 双向链表</strong> 实现，<strong>保持元素的插入顺序</strong>。</p><h3 id="5-1-LinkedHashMap-示例"><a href="#5-1-LinkedHashMap-示例" class="headerlink" title="5.1 LinkedHashMap 示例"></a><strong>5.1 <code>LinkedHashMap</code> 示例</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.LinkedHashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkedHashMapExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Map&lt;String, String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashMap</span>&lt;&gt;();<br><br>        map.put(<span class="hljs-string">&quot;Java&quot;</span>, <span class="hljs-string">&quot;OOP Language&quot;</span>);<br>        map.put(<span class="hljs-string">&quot;Python&quot;</span>, <span class="hljs-string">&quot;Scripting Language&quot;</span>);<br>        map.put(<span class="hljs-string">&quot;C++&quot;</span>, <span class="hljs-string">&quot;Compiled Language&quot;</span>);<br><br>        System.out.println(map); <span class="hljs-comment">// &#123;Java=OOP Language, Python=Scripting Language, C++=Compiled Language&#125;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-2-按访问顺序排序"><a href="#5-2-按访问顺序排序" class="headerlink" title="5.2 按访问顺序排序"></a><strong>5.2 按访问顺序排序</strong></h3><p><code>LinkedHashMap</code> 还可以根据访问顺序排序，使用构造函数 <code>LinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder)</code> 中的 <code>accessOrder</code> 参数设置为 <code>true</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.LinkedHashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkedHashMapAccessOrderExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Map&lt;String, String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashMap</span>&lt;&gt;(<span class="hljs-number">16</span>, <span class="hljs-number">0.75f</span>, <span class="hljs-literal">true</span>);<br><br>        map.put(<span class="hljs-string">&quot;Java&quot;</span>, <span class="hljs-string">&quot;OOP Language&quot;</span>);<br>        map.put(<span class="hljs-string">&quot;Python&quot;</span>, <span class="hljs-string">&quot;Scripting Language&quot;</span>);<br>        map.put(<span class="hljs-string">&quot;C++&quot;</span>, <span class="hljs-string">&quot;Compiled Language&quot;</span>);<br><br>        <span class="hljs-comment">// 访问某个元素</span><br>        map.get(<span class="hljs-string">&quot;Python&quot;</span>);<br><br>        <span class="hljs-comment">// 访问顺序会发生变化</span><br>        System.out.println(map); <span class="hljs-comment">// &#123;Java=OOP Language, C++=Compiled Language, Python=Scripting Language&#125;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="✅-6-TreeMap-用法"><a href="#✅-6-TreeMap-用法" class="headerlink" title="✅ 6. TreeMap 用法"></a>✅ <strong>6. <code>TreeMap</code> 用法</strong></h2><p><code>TreeMap</code> 基于 <strong>红黑树</strong> 实现，<strong>按照键的自然顺序</strong>或根据提供的比较器排序，增删查的时间复杂度为 <strong>O(log n)</strong>。</p><h3 id="6-1-TreeMap-示例"><a href="#6-1-TreeMap-示例" class="headerlink" title="6.1 TreeMap 示例"></a><strong>6.1 <code>TreeMap</code> 示例</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Map;<br><span class="hljs-keyword">import</span> java.util.TreeMap;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeMapExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Map&lt;String, String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeMap</span>&lt;&gt;();<br><br>        map.put(<span class="hljs-string">&quot;Java&quot;</span>, <span class="hljs-string">&quot;OOP Language&quot;</span>);<br>        map.put(<span class="hljs-string">&quot;Python&quot;</span>, <span class="hljs-string">&quot;Scripting Language&quot;</span>);<br>        map.put(<span class="hljs-string">&quot;C++&quot;</span>, <span class="hljs-string">&quot;Compiled Language&quot;</span>);<br><br>        System.out.println(map); <span class="hljs-comment">// &#123;C++=Compiled Language, Java=OOP Language, Python=Scripting Language&#125;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-2-自定义排序"><a href="#6-2-自定义排序" class="headerlink" title="6.2 自定义排序"></a><strong>6.2 自定义排序</strong></h3><p>可以通过 <code>Comparator</code> 来指定排序规则：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Comparator;<br><span class="hljs-keyword">import</span> java.util.Map;<br><span class="hljs-keyword">import</span> java.util.TreeMap;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomTreeMap</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Map&lt;String, String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeMap</span>&lt;&gt;(Comparator.reverseOrder());<br><br>        map.put(<span class="hljs-string">&quot;Java&quot;</span>, <span class="hljs-string">&quot;OOP Language&quot;</span>);<br>        map.put(<span class="hljs-string">&quot;Python&quot;</span>, <span class="hljs-string">&quot;Scripting Language&quot;</span>);<br>        map.put(<span class="hljs-string">&quot;C++&quot;</span>, <span class="hljs-string">&quot;Compiled Language&quot;</span>);<br><br>        System.out.println(map); <span class="hljs-comment">// &#123;Python=Scripting Language, Java=OOP Language, C++=Compiled Language&#125;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="✅-7-Hashtable-和-ConcurrentHashMap"><a href="#✅-7-Hashtable-和-ConcurrentHashMap" class="headerlink" title="✅ 7. Hashtable 和 ConcurrentHashMap"></a>✅ <strong>7. <code>Hashtable</code> 和 <code>ConcurrentHashMap</code></strong></h2><ul><li><strong><code>Hashtable</code></strong>：基于哈希表实现的线程安全的 <code>Map</code>，它的所有方法都是同步的，性能较差，已被废弃，建议使用 <code>ConcurrentHashMap</code>。</li><li><strong><code>ConcurrentHashMap</code></strong>：基于哈希表实现的 <strong>线程安全</strong> <code>Map</code>，具有更好的性能，因为它采用了分段锁的机制，允许多个线程并发操作。</li></ul><hr><h2 id="✅-8-Map-vs-Set-vs-List-对比"><a href="#✅-8-Map-vs-Set-vs-List-对比" class="headerlink" title="✅ 8. Map vs Set vs List 对比"></a>✅ <strong>8. Map vs Set vs List 对比</strong></h2><table><thead><tr><th><strong>特性</strong></th><th><strong>Map</strong></th><th><strong>Set</strong></th><th><strong>List</strong></th></tr></thead><tbody><tr><td><strong>存储元素</strong></td><td>键值对（Key-Value）</td><td>单个元素</td><td>单个元素</td></tr><tr><td><strong>是否允许重复</strong></td><td>键不可重复，值可以重复</td><td>不允许重复</td><td>允许重复</td></tr><tr><td><strong>是否有序</strong></td><td>无序（<code>HashMap</code>）有序（<code>LinkedHashMap</code>, <code>TreeMap</code>）</td><td>无序（<code>HashSet</code>）有序（<code>LinkedHashSet</code>, <code>TreeSet</code>）</td><td>保持插入顺序</td></tr><tr><td><strong>是否支持索引</strong></td><td>❌</td><td>❌</td><td>✅</td></tr></tbody></table><hr><h2 id="✅-9-总结"><a href="#✅-9-总结" class="headerlink" title="✅ 9. 总结"></a>✅ <strong>9. 总结</strong></h2><ul><li><strong><code>HashMap</code></strong>：无序，查询插入删除快，线程不安全。</li><li><strong><code>LinkedHashMap</code></strong>：保持插入顺序，有序，查询插入删除较快。</li><li><strong><code>TreeMap</code></strong>：有序，按自然顺序或自</li></ul><p>定义顺序排序，性能较低。</p><ul><li><strong><code>Hashtable</code></strong>：线程安全，但性能较差，已被弃用。</li><li><strong><code>ConcurrentHashMap</code></strong>：线程安全，性能优越，适用于并发环境。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Stream</title>
      <link href="/2025/03/31/javaBasics/3.6%20Stream%E6%B5%81/"/>
      <url>/2025/03/31/javaBasics/3.6%20Stream%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-Stream-流详解"><a href="#Java-Stream-流详解" class="headerlink" title="Java Stream 流详解"></a><strong>Java Stream 流详解</strong></h1><p>Java 8 引入了 <code>Stream</code> API，它是一种 <strong>声明式</strong> 处理数据的方式，旨在简化集合类的操作。<code>Stream</code> 允许你以声明性方式处理集合、数组、I&#x2F;O 通道等的数据流，支持并行处理，并能简洁地执行过滤、映射、排序等操作。</p><hr><h2 id="✅-1-什么是-Stream"><a href="#✅-1-什么是-Stream" class="headerlink" title="✅ 1. 什么是 Stream"></a>✅ <strong>1. 什么是 Stream</strong></h2><p><code>Stream</code> 是一种 <strong>数据流</strong>，不是数据存储结构。它允许你以一种 <strong>函数式</strong> 的方式处理集合中的数据，通过流水线方式进行操作，支持 <strong>惰性计算</strong>（即只有在最终操作时才会执行）。<code>Stream</code> 操作通常分为两大类：</p><ul><li><strong>中间操作</strong>（Intermediate Operations）：返回一个新的流，支持链式调用，操作是惰性求值的。</li><li><strong>终止操作</strong>（Terminal Operations）：触发流的计算，并产生一个结果（如聚合、输出等），一旦执行终止操作，流就不可再被使用。</li></ul><hr><h2 id="✅-2-Stream-的常见创建方式"><a href="#✅-2-Stream-的常见创建方式" class="headerlink" title="✅ 2. Stream 的常见创建方式"></a>✅ <strong>2. Stream 的常见创建方式</strong></h2><p>Stream 可以通过以下几种方式创建：</p><h3 id="2-1-从集合中创建-Stream"><a href="#2-1-从集合中创建-Stream" class="headerlink" title="2.1 从集合中创建 Stream"></a><strong>2.1 从集合中创建 Stream</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.stream.Stream;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StreamExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;String&gt; list = Arrays.asList(<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-string">&quot;cherry&quot;</span>);<br><br>        <span class="hljs-comment">// 通过集合创建流</span><br>        Stream&lt;String&gt; stream = list.stream();<br>        stream.forEach(System.out::println);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-从数组中创建-Stream"><a href="#2-2-从数组中创建-Stream" class="headerlink" title="2.2 从数组中创建 Stream"></a><strong>2.2 从数组中创建 Stream</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">String[] arr = &#123;<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-string">&quot;cherry&quot;</span>&#125;;<br>Stream&lt;String&gt; stream = Arrays.stream(arr);<br>stream.forEach(System.out::println);<br></code></pre></td></tr></table></figure><h3 id="2-3-创建无限流"><a href="#2-3-创建无限流" class="headerlink" title="2.3 创建无限流"></a><strong>2.3 创建无限流</strong></h3><p>使用 <code>Stream</code> 的 <code>generate</code> 或 <code>iterate</code> 方法可以创建无限流。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 使用 generate 创建无限流</span><br>Stream&lt;Double&gt; randomNumbers = Stream.generate(Math::random);<br>randomNumbers.limit(<span class="hljs-number">5</span>).forEach(System.out::println);<br><br><span class="hljs-comment">// 使用 iterate 创建无限流</span><br>Stream&lt;Integer&gt; numbers = Stream.iterate(<span class="hljs-number">0</span>, n -&gt; n + <span class="hljs-number">2</span>);<br>numbers.limit(<span class="hljs-number">5</span>).forEach(System.out::println); <span class="hljs-comment">// 0, 2, 4, 6, 8</span><br></code></pre></td></tr></table></figure><hr><h2 id="✅-3-Stream-中的常见中间操作"><a href="#✅-3-Stream-中的常见中间操作" class="headerlink" title="✅ 3. Stream 中的常见中间操作"></a>✅ <strong>3. Stream 中的常见中间操作</strong></h2><p>中间操作是惰性计算的，即它们只会在终止操作触发时被执行。常见的中间操作包括：</p><h3 id="3-1-filter"><a href="#3-1-filter" class="headerlink" title="3.1 filter()"></a><strong>3.1 <code>filter()</code></strong></h3><p>根据条件过滤流中的元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = Arrays.asList(<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-string">&quot;cherry&quot;</span>, <span class="hljs-string">&quot;date&quot;</span>);<br>list.stream()<br>    .filter(s -&gt; s.startsWith(<span class="hljs-string">&quot;a&quot;</span>))<br>    .forEach(System.out::println); <span class="hljs-comment">// 输出：apple</span><br></code></pre></td></tr></table></figure><h3 id="3-2-map"><a href="#3-2-map" class="headerlink" title="3.2 map()"></a><strong>3.2 <code>map()</code></strong></h3><p>对流中的每个元素应用转换函数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = Arrays.asList(<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-string">&quot;cherry&quot;</span>);<br>list.stream()<br>    .map(String::toUpperCase)<br>    .forEach(System.out::println); <span class="hljs-comment">// 输出：APPLE BANANA CHERRY</span><br></code></pre></td></tr></table></figure><h3 id="3-3-distinct"><a href="#3-3-distinct" class="headerlink" title="3.3 distinct()"></a><strong>3.3 <code>distinct()</code></strong></h3><p>去重，返回一个没有重复元素的新流。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; list = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>);<br>list.stream()<br>    .distinct()<br>    .forEach(System.out::println); <span class="hljs-comment">// 输出：1 2 3 4 5</span><br></code></pre></td></tr></table></figure><h3 id="3-4-sorted"><a href="#3-4-sorted" class="headerlink" title="3.4 sorted()"></a><strong>3.4 <code>sorted()</code></strong></h3><p>排序，默认按自然顺序排序，或者传入自定义的比较器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; list = Arrays.asList(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>);<br>list.stream()<br>    .sorted()<br>    .forEach(System.out::println); <span class="hljs-comment">// 输出：1 1 3 4 5</span><br></code></pre></td></tr></table></figure><h3 id="3-5-limit"><a href="#3-5-limit" class="headerlink" title="3.5 limit()"></a><strong>3.5 <code>limit()</code></strong></h3><p>限制流的元素数量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; list = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>);<br>list.stream()<br>    .limit(<span class="hljs-number">3</span>)<br>    .forEach(System.out::println); <span class="hljs-comment">// 输出：1 2 3</span><br></code></pre></td></tr></table></figure><h3 id="3-6-skip"><a href="#3-6-skip" class="headerlink" title="3.6 skip()"></a><strong>3.6 <code>skip()</code></strong></h3><p>跳过流中的前 N 个元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; list = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>);<br>list.stream()<br>    .skip(<span class="hljs-number">2</span>)<br>    .forEach(System.out::println); <span class="hljs-comment">// 输出：3 4 5</span><br></code></pre></td></tr></table></figure><h3 id="3-7-flatMap"><a href="#3-7-flatMap" class="headerlink" title="3.7 flatMap()"></a><strong>3.7 <code>flatMap()</code></strong></h3><p>扁平化流，将一个流中的元素映射为多个元素，并将这些元素扁平化成一个流。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;List&lt;String&gt;&gt; list = Arrays.asList(<br>    Arrays.asList(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>), Arrays.asList(<span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-string">&quot;d&quot;</span>));<br>list.stream()<br>    .flatMap(List::stream)<br>    .forEach(System.out::println); <span class="hljs-comment">// 输出：a b c d</span><br></code></pre></td></tr></table></figure><hr><h2 id="✅-4-Stream-中的常见终止操作"><a href="#✅-4-Stream-中的常见终止操作" class="headerlink" title="✅ 4. Stream 中的常见终止操作"></a>✅ <strong>4. Stream 中的常见终止操作</strong></h2><p>终止操作会触发整个流的计算，且终止操作执行后，流将无法再使用。</p><h3 id="4-1-forEach"><a href="#4-1-forEach" class="headerlink" title="4.1 forEach()"></a><strong>4.1 <code>forEach()</code></strong></h3><p>对流中的每个元素执行指定的操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = Arrays.asList(<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-string">&quot;cherry&quot;</span>);<br>list.stream()<br>    .forEach(System.out::println); <span class="hljs-comment">// 输出：apple banana cherry</span><br></code></pre></td></tr></table></figure><h3 id="4-2-collect"><a href="#4-2-collect" class="headerlink" title="4.2 collect()"></a><strong>4.2 <code>collect()</code></strong></h3><p>将流中的元素收集到集合中。常用的收集器有 <code>Collectors.toList()</code>、<code>Collectors.toSet()</code>、<code>Collectors.joining()</code> 等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = Arrays.asList(<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-string">&quot;cherry&quot;</span>);<br>List&lt;String&gt; result = list.stream()<br>    .filter(s -&gt; s.startsWith(<span class="hljs-string">&quot;a&quot;</span>))<br>    .collect(Collectors.toList());<br>System.out.println(result); <span class="hljs-comment">// 输出：[apple]</span><br></code></pre></td></tr></table></figure><h3 id="4-3-reduce"><a href="#4-3-reduce" class="headerlink" title="4.3 reduce()"></a><strong>4.3 <code>reduce()</code></strong></h3><p>将流中的元素反复结合起来，得到一个值。通常用于计算总和、乘积等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; list = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>);<br><span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> list.stream()<br>    .reduce(<span class="hljs-number">0</span>, Integer::sum);<br>System.out.println(sum); <span class="hljs-comment">// 输出：10</span><br></code></pre></td></tr></table></figure><h3 id="4-4-anyMatch"><a href="#4-4-anyMatch" class="headerlink" title="4.4 anyMatch()"></a><strong>4.4 <code>anyMatch()</code></strong></h3><p>判断流中是否有任何一个元素满足给定条件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = Arrays.asList(<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-string">&quot;cherry&quot;</span>);<br><span class="hljs-type">boolean</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> list.stream()<br>    .anyMatch(s -&gt; s.startsWith(<span class="hljs-string">&quot;b&quot;</span>));<br>System.out.println(result); <span class="hljs-comment">// 输出：true</span><br></code></pre></td></tr></table></figure><h3 id="4-5-allMatch"><a href="#4-5-allMatch" class="headerlink" title="4.5 allMatch()"></a><strong>4.5 <code>allMatch()</code></strong></h3><p>判断流中是否所有元素都满足给定条件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = Arrays.asList(<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-string">&quot;cherry&quot;</span>);<br><span class="hljs-type">boolean</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> list.stream()<br>    .allMatch(s -&gt; s.length() &gt; <span class="hljs-number">4</span>);<br>System.out.println(result); <span class="hljs-comment">// 输出：true</span><br></code></pre></td></tr></table></figure><h3 id="4-6-noneMatch"><a href="#4-6-noneMatch" class="headerlink" title="4.6 noneMatch()"></a><strong>4.6 <code>noneMatch()</code></strong></h3><p>判断流中是否没有任何元素满足给定条件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = Arrays.asList(<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-string">&quot;cherry&quot;</span>);<br><span class="hljs-type">boolean</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> list.stream()<br>    .noneMatch(s -&gt; s.startsWith(<span class="hljs-string">&quot;z&quot;</span>));<br>System.out.println(result); <span class="hljs-comment">// 输出：true</span><br></code></pre></td></tr></table></figure><hr><h2 id="✅-5-并行流"><a href="#✅-5-并行流" class="headerlink" title="✅ 5. 并行流"></a>✅ <strong>5. 并行流</strong></h2><p><code>Stream</code> 还支持并行处理数据，通过 <code>parallelStream()</code> 或 <code>parallel()</code> 方法，可以实现多核处理，提升性能（尤其是在处理大量数据时）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; list = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>);<br>list.stream()<br>    .parallel()<br>    .forEach(System.out::println); <span class="hljs-comment">// 使用并行流输出</span><br></code></pre></td></tr></table></figure><p>注意：并行流并不总是适合所有情况，对于小数据集，可能反而会导致性能下降。</p><hr><h2 id="✅-6-总结"><a href="#✅-6-总结" class="headerlink" title="✅ 6. 总结"></a>✅ <strong>6. 总结</strong></h2><ul><li><strong>中间操作</strong>：如 <code>filter()</code>、<code>map()</code>、<code>sorted()</code> 等，是惰性求值的，返回一个新的流。</li><li><strong>终止操作</strong>：如 <code>forEach()</code>、<code>collect()</code>、<code>reduce()</code> 等，触发流的计算并产生结果。</li><li><strong>并行流</strong>：<code>Stream</code> 支持并行处理，适合大数据量的处理。</li><li><strong>流的特点</strong>：流是一次性的，一旦消费后就无法重用。</li></ul><p>通过 Stream API，我们可以更加简洁地处理集合数据，同时支持函数式编程风格。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Set</title>
      <link href="/2025/03/31/javaBasics/3.4%20Set/"/>
      <url>/2025/03/31/javaBasics/3.4%20Set/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-Set-集合详解"><a href="#Java-Set-集合详解" class="headerlink" title="Java Set 集合详解"></a><strong>Java Set 集合详解</strong></h1><p><code>Set</code> 是 Java 集合框架中的一个接口，继承自 <code>Collection</code>，它的<strong>特点是不允许存储重复元素</strong>，并且可以<strong>根据不同实现类选择是否保证元素的顺序</strong>。</p><hr><h2 id="✅-1-Set-的特点"><a href="#✅-1-Set-的特点" class="headerlink" title="✅ 1. Set 的特点"></a>✅ <strong>1. Set 的特点</strong></h2><ul><li><strong>不允许重复元素</strong>：如果向 <code>Set</code> 中添加一个已存在的元素，添加操作会被忽略。</li><li><strong>无索引</strong>：不像 <code>List</code>，<code>Set</code> <strong>不支持索引访问</strong>，只能通过迭代器或增强 <code>for</code> 循环遍历。</li><li><strong>允许存储 <code>null</code></strong>（但只能有一个 <code>null</code>）。</li><li><strong>元素顺序不固定</strong>（具体顺序由实现类决定）。</li></ul><hr><h2 id="✅-2-Set-的主要实现类"><a href="#✅-2-Set-的主要实现类" class="headerlink" title="✅ 2. Set 的主要实现类"></a>✅ <strong>2. Set 的主要实现类</strong></h2><table><thead><tr><th><strong>实现类</strong></th><th><strong>底层数据结构</strong></th><th><strong>特点</strong></th></tr></thead><tbody><tr><td><code>HashSet</code></td><td><strong>哈希表</strong>（<code>HashMap</code>）</td><td><strong>无序</strong>，增删查快（<code>O(1)</code>）</td></tr><tr><td><code>LinkedHashSet</code></td><td><strong>哈希表 + 双向链表</strong></td><td><strong>有序</strong>（按插入顺序）</td></tr><tr><td><code>TreeSet</code></td><td><strong>红黑树（自平衡二叉树）</strong></td><td><strong>有序</strong>（按<strong>自然排序</strong>或<strong>比较器排序</strong>）</td></tr></tbody></table><hr><h2 id="✅-3-Set-的常用方法"><a href="#✅-3-Set-的常用方法" class="headerlink" title="✅ 3. Set 的常用方法"></a>✅ <strong>3. Set 的常用方法</strong></h2><p><code>Set</code> 继承了 <code>Collection</code> 接口的方法，没有额外的方法，常见操作包括：</p><table><thead><tr><th><strong>方法</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td><code>add(E e)</code></td><td>添加元素（如果存在则不添加）</td></tr><tr><td><code>remove(Object o)</code></td><td>删除指定元素</td></tr><tr><td><code>contains(Object o)</code></td><td>判断是否包含指定元素</td></tr><tr><td><code>size()</code></td><td>获取集合大小</td></tr><tr><td><code>isEmpty()</code></td><td>判断集合是否为空</td></tr><tr><td><code>clear()</code></td><td>清空集合</td></tr><tr><td><code>iterator()</code></td><td>获取迭代器</td></tr></tbody></table><hr><h2 id="✅-4-HashSet-用法"><a href="#✅-4-HashSet-用法" class="headerlink" title="✅ 4. HashSet 用法"></a>✅ <strong>4. <code>HashSet</code> 用法</strong></h2><p><code>HashSet</code> 基于 <strong>哈希表</strong> 实现，<strong>不保证元素顺序</strong>，插入、删除、查找的时间复杂度 <strong>O(1)</strong>。</p><h3 id="4-1-HashSet-示例"><a href="#4-1-HashSet-示例" class="headerlink" title="4.1 HashSet 示例"></a><strong>4.1 <code>HashSet</code> 示例</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.HashSet;<br><span class="hljs-keyword">import</span> java.util.Set;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HashSetExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Set&lt;String&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br><br>        set.add(<span class="hljs-string">&quot;Java&quot;</span>);<br>        set.add(<span class="hljs-string">&quot;Python&quot;</span>);<br>        set.add(<span class="hljs-string">&quot;C++&quot;</span>);<br>        set.add(<span class="hljs-string">&quot;Java&quot;</span>); <span class="hljs-comment">// 重复元素不会被添加</span><br><br>        System.out.println(set); <span class="hljs-comment">// [C++, Java, Python]（无序）</span><br>        System.out.println(<span class="hljs-string">&quot;是否包含 Java: &quot;</span> + set.contains(<span class="hljs-string">&quot;Java&quot;</span>)); <span class="hljs-comment">// true</span><br><br>        set.remove(<span class="hljs-string">&quot;Python&quot;</span>);<br>        System.out.println(set); <span class="hljs-comment">// [C++, Java]</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-2-遍历-HashSet"><a href="#4-2-遍历-HashSet" class="headerlink" title="4.2 遍历 HashSet"></a><strong>4.2 遍历 <code>HashSet</code></strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 方式 1：增强 for 循环</span><br><span class="hljs-keyword">for</span> (String item : set) &#123;<br>    System.out.println(item);<br>&#125;<br><br><span class="hljs-comment">// 方式 2：迭代器遍历</span><br>Iterator&lt;String&gt; iterator = set.iterator();<br><span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>    System.out.println(iterator.next());<br>&#125;<br><br><span class="hljs-comment">// 方式 3：Lambda 表达式</span><br>set.forEach(System.out::println);<br></code></pre></td></tr></table></figure><hr><h2 id="✅-5-LinkedHashSet-用法"><a href="#✅-5-LinkedHashSet-用法" class="headerlink" title="✅ 5. LinkedHashSet 用法"></a>✅ <strong>5. <code>LinkedHashSet</code> 用法</strong></h2><p><code>LinkedHashSet</code> 继承自 <code>HashSet</code>，<strong>但它保留了元素的插入顺序</strong>。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.LinkedHashSet;<br><span class="hljs-keyword">import</span> java.util.Set;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkedHashSetExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Set&lt;String&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashSet</span>&lt;&gt;();<br><br>        set.add(<span class="hljs-string">&quot;Java&quot;</span>);<br>        set.add(<span class="hljs-string">&quot;Python&quot;</span>);<br>        set.add(<span class="hljs-string">&quot;C++&quot;</span>);<br><br>        System.out.println(set); <span class="hljs-comment">// [Java, Python, C++]（有序）</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="✅-6-TreeSet-用法"><a href="#✅-6-TreeSet-用法" class="headerlink" title="✅ 6. TreeSet 用法"></a>✅ <strong>6. <code>TreeSet</code> 用法</strong></h2><p><code>TreeSet</code> 基于 <strong>红黑树</strong> 实现，<strong>保证元素按照自然顺序（默认升序）排序</strong>，增删查的时间复杂度 <strong>O(log n)</strong>。</p><h3 id="6-1-TreeSet-示例"><a href="#6-1-TreeSet-示例" class="headerlink" title="6.1 TreeSet 示例"></a><strong>6.1 <code>TreeSet</code> 示例</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Set;<br><span class="hljs-keyword">import</span> java.util.TreeSet;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeSetExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeSet</span>&lt;&gt;();<br><br>        set.add(<span class="hljs-number">10</span>);<br>        set.add(<span class="hljs-number">5</span>);<br>        set.add(<span class="hljs-number">20</span>);<br>        set.add(<span class="hljs-number">15</span>);<br><br>        System.out.println(set); <span class="hljs-comment">// [5, 10, 15, 20]（自动排序）</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-2-自定义排序"><a href="#6-2-自定义排序" class="headerlink" title="6.2 自定义排序"></a><strong>6.2 自定义排序</strong></h3><p>可以使用 <code>Comparator</code> 来指定排序规则：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Comparator;<br><span class="hljs-keyword">import</span> java.util.Set;<br><span class="hljs-keyword">import</span> java.util.TreeSet;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomTreeSet</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 按降序排序</span><br>        Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeSet</span>&lt;&gt;(Comparator.reverseOrder());<br><br>        set.add(<span class="hljs-number">10</span>);<br>        set.add(<span class="hljs-number">5</span>);<br>        set.add(<span class="hljs-number">20</span>);<br>        set.add(<span class="hljs-number">15</span>);<br><br>        System.out.println(set); <span class="hljs-comment">// [20, 15, 10, 5]</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="✅-7-Set-常见问题"><a href="#✅-7-Set-常见问题" class="headerlink" title="✅ 7. Set 常见问题"></a>✅ <strong>7. <code>Set</code> 常见问题</strong></h2><h3 id="7-1-HashSet-为什么无序？"><a href="#7-1-HashSet-为什么无序？" class="headerlink" title="7.1 HashSet 为什么无序？"></a><strong>7.1 <code>HashSet</code> 为什么无序？</strong></h3><p><code>HashSet</code> 基于 <code>HashMap</code>，元素存储在 <strong>哈希桶（Hash Bucket）</strong> 里，顺序依赖于哈希值，<strong>不会按插入顺序排列</strong>。</p><h3 id="7-2-如何让-Set-保持顺序？"><a href="#7-2-如何让-Set-保持顺序？" class="headerlink" title="7.2 如何让 Set 保持顺序？"></a><strong>7.2 如何让 <code>Set</code> 保持顺序？</strong></h3><ul><li><strong>按插入顺序</strong>：使用 <code>LinkedHashSet</code></li><li><strong>按大小排序</strong>：使用 <code>TreeSet</code></li></ul><h3 id="7-3-TreeSet-为什么不能存-null？"><a href="#7-3-TreeSet-为什么不能存-null？" class="headerlink" title="7.3 TreeSet 为什么不能存 null？"></a><strong>7.3 <code>TreeSet</code> 为什么不能存 <code>null</code>？</strong></h3><p><code>TreeSet</code> 依赖 <code>compareTo()</code> 进行排序，而 <code>null</code> 不能参与比较，因此 <code>TreeSet</code> <strong>不允许 <code>null</code> 元素</strong>。</p><hr><h2 id="✅-8-Set-vs-List-对比"><a href="#✅-8-Set-vs-List-对比" class="headerlink" title="✅ 8. Set vs List 对比"></a>✅ <strong>8. Set vs List 对比</strong></h2><table><thead><tr><th><strong>特性</strong></th><th><strong>Set</strong></th><th><strong>List</strong></th></tr></thead><tbody><tr><td><strong>是否允许重复</strong></td><td>❌ 不允许</td><td>✅ 允许</td></tr><tr><td><strong>是否有序</strong></td><td>❌（<code>HashSet</code>）✅（<code>LinkedHashSet</code>、<code>TreeSet</code>）</td><td>✅ 保持插入顺序</td></tr><tr><td><strong>是否支持索引访问</strong></td><td>❌</td><td>✅</td></tr><tr><td><strong>查询效率</strong></td><td>✅ <code>HashSet</code> O(1)</td><td>❌ O(n)</td></tr><tr><td><strong>插入&#x2F;删除效率</strong></td><td>✅ <code>HashSet</code> O(1)</td><td>❌ O(n)</td></tr></tbody></table><hr><h2 id="✅-9-总结"><a href="#✅-9-总结" class="headerlink" title="✅ 9. 总结"></a>✅ <strong>9. 总结</strong></h2><table><thead><tr><th><strong>实现类</strong></th><th><strong>特点</strong></th></tr></thead><tbody><tr><td><code>HashSet</code></td><td>无序，查询快，适用于去重</td></tr><tr><td><code>LinkedHashSet</code></td><td>保持插入顺序</td></tr><tr><td><code>TreeSet</code></td><td>按自然顺序或自定义排序</td></tr></tbody></table><p>如果需要<strong>唯一性 + 高效查询</strong>，使用 <code>HashSet</code>。<br>如果需要<strong>唯一性 + 顺序</strong>，使用 <code>LinkedHashSet</code>。<br>如果需要<strong>唯一性 + 排序</strong>，使用 <code>TreeSet</code>。  </p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>List</title>
      <link href="/2025/03/31/javaBasics/3.3%20List/"/>
      <url>/2025/03/31/javaBasics/3.3%20List/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-List-集合详解"><a href="#Java-List-集合详解" class="headerlink" title="Java List 集合详解"></a><strong>Java List 集合详解</strong></h1><p><code>List</code> 是 Java 集合框架中的一个接口，继承自 <code>Collection</code>，<strong>允许存储重复元素</strong>，并且<strong>保持元素的插入顺序</strong>。它是<strong>有序</strong>的，并提供了<strong>基于索引的操作</strong>，可以随时访问、插入或删除元素。</p><hr><h2 id="✅-1-List-的特点"><a href="#✅-1-List-的特点" class="headerlink" title="✅ 1. List 的特点"></a>✅ <strong>1. List 的特点</strong></h2><ul><li><strong>有序性</strong>：<code>List</code> 保证元素的存储顺序与插入顺序相同。</li><li><strong>允许重复元素</strong>：<code>List</code> 允许多个元素具有相同的值。</li><li><strong>索引访问</strong>：可以使用 <code>get(int index)</code> 通过索引访问元素。</li><li><strong>支持 <code>null</code> 值</strong>：可以存储 <code>null</code>。</li></ul><hr><h2 id="✅-2-List-的主要实现类"><a href="#✅-2-List-的主要实现类" class="headerlink" title="✅ 2. List 的主要实现类"></a>✅ <strong>2. List 的主要实现类</strong></h2><table><thead><tr><th><strong>实现类</strong></th><th><strong>底层数据结构</strong></th><th><strong>特点</strong></th></tr></thead><tbody><tr><td><code>ArrayList</code></td><td>动态数组</td><td>读取快，增删慢（基于数组）</td></tr><tr><td><code>LinkedList</code></td><td>双向链表</td><td>增删快，读取慢（基于链表）</td></tr><tr><td><code>Vector</code></td><td>动态数组（线程安全）</td><td>线程安全，但性能较低</td></tr><tr><td><code>Stack</code></td><td>栈（继承 <code>Vector</code>）</td><td>先进后出（LIFO）</td></tr></tbody></table><hr><h2 id="✅-3-List-的常用方法"><a href="#✅-3-List-的常用方法" class="headerlink" title="✅ 3. List 的常用方法"></a>✅ <strong>3. List 的常用方法</strong></h2><p><code>List</code> 继承了 <code>Collection</code> 的方法，并额外提供了一些基于索引的操作方法：</p><table><thead><tr><th><strong>方法</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td><code>add(E e)</code></td><td>添加元素</td></tr><tr><td><code>add(int index, E element)</code></td><td>在指定位置插入元素</td></tr><tr><td><code>remove(int index)</code></td><td>根据索引删除元素</td></tr><tr><td><code>remove(Object o)</code></td><td>删除匹配的第一个元素</td></tr><tr><td><code>set(int index, E element)</code></td><td>修改指定索引位置的元素</td></tr><tr><td><code>get(int index)</code></td><td>获取指定索引的元素</td></tr><tr><td><code>indexOf(Object o)</code></td><td>返回元素的索引（首次出现）</td></tr><tr><td><code>lastIndexOf(Object o)</code></td><td>返回元素的索引（最后出现）</td></tr><tr><td><code>subList(int fromIndex, int toIndex)</code></td><td>获取子列表</td></tr><tr><td><code>sort(Comparator&lt;? super E&gt; c)</code></td><td>对 <code>List</code> 进行排序</td></tr><tr><td><code>replaceAll(UnaryOperator&lt;E&gt; operator)</code></td><td>替换所有元素</td></tr></tbody></table><hr><h2 id="✅-4-ArrayList-用法"><a href="#✅-4-ArrayList-用法" class="headerlink" title="✅ 4. ArrayList 用法"></a>✅ <strong>4. <code>ArrayList</code> 用法</strong></h2><h3 id="4-1-创建-ArrayList"><a href="#4-1-创建-ArrayList" class="headerlink" title="4.1 创建 ArrayList"></a><strong>4.1 创建 <code>ArrayList</code></strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayListExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <br>        <span class="hljs-comment">// 添加元素</span><br>        list.add(<span class="hljs-string">&quot;Java&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;Python&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;C++&quot;</span>);<br><br>        System.out.println(list); <span class="hljs-comment">// [Java, Python, C++]</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="4-2-按索引操作"><a href="#4-2-按索引操作" class="headerlink" title="4.2 按索引操作"></a><strong>4.2 按索引操作</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayListIndexExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        list.add(<span class="hljs-string">&quot;Java&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;Python&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;C++&quot;</span>);<br><br>        <span class="hljs-comment">// 通过索引访问元素</span><br>        System.out.println(list.get(<span class="hljs-number">1</span>)); <span class="hljs-comment">// Python</span><br><br>        <span class="hljs-comment">// 修改元素</span><br>        list.set(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;JavaScript&quot;</span>);<br>        System.out.println(list); <span class="hljs-comment">// [Java, JavaScript, C++]</span><br><br>        <span class="hljs-comment">// 删除元素</span><br>        list.remove(<span class="hljs-number">2</span>);<br>        System.out.println(list); <span class="hljs-comment">// [Java, JavaScript]</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="4-3-遍历-ArrayList"><a href="#4-3-遍历-ArrayList" class="headerlink" title="4.3 遍历 ArrayList"></a><strong>4.3 遍历 <code>ArrayList</code></strong></h3><h4 id="方式-1：普通-for-循环"><a href="#方式-1：普通-for-循环" class="headerlink" title="方式 1：普通 for 循环"></a><strong>方式 1：普通 <code>for</code> 循环</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; list.size(); i++) &#123;<br>    System.out.println(list.get(i));<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="方式-2：增强-for-循环"><a href="#方式-2：增强-for-循环" class="headerlink" title="方式 2：增强 for 循环"></a><strong>方式 2：增强 <code>for</code> 循环</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (String item : list) &#123;<br>    System.out.println(item);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="方式-3：Iterator-遍历"><a href="#方式-3：Iterator-遍历" class="headerlink" title="方式 3：Iterator 遍历"></a><strong>方式 3：<code>Iterator</code> 遍历</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Iterator;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IteratorExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        list.add(<span class="hljs-string">&quot;Java&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;Python&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;C++&quot;</span>);<br><br>        Iterator&lt;String&gt; iterator = list.iterator();<br>        <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>            System.out.println(iterator.next());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="方式-4：Lambda-表达式"><a href="#方式-4：Lambda-表达式" class="headerlink" title="方式 4：Lambda 表达式"></a><strong>方式 4：Lambda 表达式</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">list.forEach(System.out::println);<br></code></pre></td></tr></table></figure><hr><h3 id="4-4-排序-ArrayList"><a href="#4-4-排序-ArrayList" class="headerlink" title="4.4 排序 ArrayList"></a><strong>4.4 排序 <code>ArrayList</code></strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Collections;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ListSortExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        list.add(<span class="hljs-number">5</span>);<br>        list.add(<span class="hljs-number">2</span>);<br>        list.add(<span class="hljs-number">8</span>);<br>        list.add(<span class="hljs-number">1</span>);<br><br>        <span class="hljs-comment">// 升序排序</span><br>        Collections.sort(list);<br>        System.out.println(list); <span class="hljs-comment">// [1, 2, 5, 8]</span><br><br>        <span class="hljs-comment">// 降序排序</span><br>        list.sort(Collections.reverseOrder());<br>        System.out.println(list); <span class="hljs-comment">// [8, 5, 2, 1]</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="✅-5-LinkedList-用法"><a href="#✅-5-LinkedList-用法" class="headerlink" title="✅ 5. LinkedList 用法"></a>✅ <strong>5. <code>LinkedList</code> 用法</strong></h2><p><code>LinkedList</code> 适用于频繁的插入和删除操作。</p><h3 id="5-1-LinkedList-特性"><a href="#5-1-LinkedList-特性" class="headerlink" title="5.1 LinkedList 特性"></a><strong>5.1 <code>LinkedList</code> 特性</strong></h3><ul><li><strong>基于双向链表</strong>，插入&#x2F;删除操作比 <code>ArrayList</code> 更快。</li><li><strong>适用于队列（FIFO）和栈（LIFO）结构</strong>。</li><li><strong>支持头尾操作</strong>（<code>addFirst()</code>、<code>addLast()</code>、<code>removeFirst()</code>、<code>removeLast()</code>）。</li></ul><h3 id="5-2-LinkedList-示例"><a href="#5-2-LinkedList-示例" class="headerlink" title="5.2 LinkedList 示例"></a><strong>5.2 <code>LinkedList</code> 示例</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.LinkedList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkedListExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        list.add(<span class="hljs-string">&quot;Java&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;Python&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;C++&quot;</span>);<br><br>        <span class="hljs-comment">// 头部插入</span><br>        ((LinkedList&lt;String&gt;) list).addFirst(<span class="hljs-string">&quot;Go&quot;</span>);<br>        <span class="hljs-comment">// 尾部插入</span><br>        ((LinkedList&lt;String&gt;) list).addLast(<span class="hljs-string">&quot;Rust&quot;</span>);<br><br>        System.out.println(list); <span class="hljs-comment">// [Go, Java, Python, C++, Rust]</span><br><br>        <span class="hljs-comment">// 删除头部和尾部元素</span><br>        ((LinkedList&lt;String&gt;) list).removeFirst();<br>        ((LinkedList&lt;String&gt;) list).removeLast();<br>        System.out.println(list); <span class="hljs-comment">// [Java, Python, C++]</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="✅-6-Vector-和-Stack"><a href="#✅-6-Vector-和-Stack" class="headerlink" title="✅ 6. Vector 和 Stack"></a>✅ <strong>6. <code>Vector</code> 和 <code>Stack</code></strong></h2><h3 id="6-1-Vector（线程安全的-ArrayList）"><a href="#6-1-Vector（线程安全的-ArrayList）" class="headerlink" title="6.1 Vector（线程安全的 ArrayList）"></a><strong>6.1 <code>Vector</code>（线程安全的 <code>ArrayList</code>）</strong></h3><p><code>Vector</code> 和 <code>ArrayList</code> 类似，但它的方法是 <strong>线程安全</strong> 的（使用 <code>synchronized</code> 进行同步）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Vector;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VectorExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Vector&lt;String&gt; vector = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vector</span>&lt;&gt;();<br>        vector.add(<span class="hljs-string">&quot;Java&quot;</span>);<br>        vector.add(<span class="hljs-string">&quot;Python&quot;</span>);<br>        vector.add(<span class="hljs-string">&quot;C++&quot;</span>);<br><br>        System.out.println(vector); <span class="hljs-comment">// [Java, Python, C++]</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-2-Stack（栈，先进后出）"><a href="#6-2-Stack（栈，先进后出）" class="headerlink" title="6.2 Stack（栈，先进后出）"></a><strong>6.2 <code>Stack</code>（栈，先进后出）</strong></h3><p><code>Stack</code> 继承 <code>Vector</code>，是一个**后进先出（LIFO）**的集合，常用方法：</p><ul><li><code>push(E e)</code>：压栈</li><li><code>pop()</code>：弹栈</li><li><code>peek()</code>：查看栈顶元素</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Stack;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StackExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Stack&lt;String&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        stack.push(<span class="hljs-string">&quot;Java&quot;</span>);<br>        stack.push(<span class="hljs-string">&quot;Python&quot;</span>);<br>        stack.push(<span class="hljs-string">&quot;C++&quot;</span>);<br><br>        System.out.println(stack.pop()); <span class="hljs-comment">// C++</span><br>        System.out.println(stack.peek()); <span class="hljs-comment">// Python</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="✅-7-总结"><a href="#✅-7-总结" class="headerlink" title="✅ 7. 总结"></a>✅ <strong>7. 总结</strong></h2><ul><li><code>ArrayList</code>：查询快，增删慢，适用于<strong>读多写少</strong>的场景。</li><li><code>LinkedList</code>：增删快，查询慢，适用于<strong>频繁插入删除</strong>的场景。</li><li><code>Vector</code>：线程安全，但性能较低。</li><li><code>Stack</code>：后进先出（LIFO）。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发修改异常问题——三种遍历方式的区别</title>
      <link href="/2025/03/31/javaBasics/3.2%20%E5%B9%B6%E5%8F%91%E4%BF%AE%E6%94%B9%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98/"/>
      <url>/2025/03/31/javaBasics/3.2%20%E5%B9%B6%E5%8F%91%E4%BF%AE%E6%94%B9%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-并发修改异常（ConcurrentModificationException）问题详解"><a href="#Java-并发修改异常（ConcurrentModificationException）问题详解" class="headerlink" title="Java 并发修改异常（ConcurrentModificationException）问题详解"></a><strong>Java 并发修改异常（ConcurrentModificationException）问题详解</strong></h1><p>在多线程环境中，<strong>并发修改异常（<code>ConcurrentModificationException</code>）</strong> 是一种常见的运行时异常，通常发生在我们在遍历集合时，集合的结构被同时修改。这个问题通常出现在使用 <strong><code>Iterator</code></strong> 或增强型 <code>for</code> 循环（foreach）时，集合在遍历的过程中被结构性修改（如添加、删除元素）。</p><hr><h2 id="✅-1-什么是并发修改异常"><a href="#✅-1-什么是并发修改异常" class="headerlink" title="✅ 1. 什么是并发修改异常"></a>✅ <strong>1. 什么是并发修改异常</strong></h2><p><code>ConcurrentModificationException</code> 是 Java 集合类中的一个异常，它表示在 <strong>遍历集合的同时修改</strong> 集合结构（例如添加、删除元素），而这种修改操作与遍历操作之间没有同步机制时，抛出的异常。</p><h3 id="典型场景："><a href="#典型场景：" class="headerlink" title="典型场景："></a><strong>典型场景：</strong></h3><ul><li>使用 <strong><code>Iterator</code></strong> 或增强型 <code>for</code> 循环遍历集合时，修改集合（例如 <code>remove()</code> 或 <code>add()</code>）会导致并发修改异常。</li></ul><hr><h2 id="✅-2-引发-ConcurrentModificationException-的场景"><a href="#✅-2-引发-ConcurrentModificationException-的场景" class="headerlink" title="✅ 2. 引发 ConcurrentModificationException 的场景"></a>✅ <strong>2. 引发 <code>ConcurrentModificationException</code> 的场景</strong></h2><h3 id="2-1-使用增强型-for-循环遍历集合时修改集合"><a href="#2-1-使用增强型-for-循环遍历集合时修改集合" class="headerlink" title="2.1 使用增强型 for 循环遍历集合时修改集合"></a><strong>2.1 使用增强型 <code>for</code> 循环遍历集合时修改集合</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcurrentModificationExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        list.add(<span class="hljs-string">&quot;Java&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;Python&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;C++&quot;</span>);<br><br>        <span class="hljs-keyword">for</span> (String lang : list) &#123;<br>            <span class="hljs-comment">// 在遍历过程中修改集合</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;Python&quot;</span>.equals(lang)) &#123;<br>                list.remove(lang); <span class="hljs-comment">// 这里会抛出 ConcurrentModificationException</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-使用-Iterator-遍历集合时修改集合"><a href="#2-2-使用-Iterator-遍历集合时修改集合" class="headerlink" title="2.2 使用 Iterator 遍历集合时修改集合"></a><strong>2.2 使用 <code>Iterator</code> 遍历集合时修改集合</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Iterator;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IteratorConcurrentModificationExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        list.add(<span class="hljs-string">&quot;Java&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;Python&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;C++&quot;</span>);<br><br>        Iterator&lt;String&gt; iterator = list.iterator();<br>        <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">lang</span> <span class="hljs-operator">=</span> iterator.next();<br>            <span class="hljs-comment">// 在迭代过程中修改集合</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;Python&quot;</span>.equals(lang)) &#123;<br>                list.remove(lang); <span class="hljs-comment">// 这里会抛出 ConcurrentModificationException</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>解释</strong>：在以上两个例子中，集合的结构在遍历过程中被修改。<code>ArrayList</code> 会维护一个 <strong>modCount</strong> 字段来记录结构的修改次数，当 <code>Iterator</code> 或增强型 <code>for</code> 循环的迭代器检测到集合的修改次数和它的 <strong>modCount</strong> 不一致时，就会抛出 <code>ConcurrentModificationException</code>。</p></blockquote><hr><h2 id="✅-3-如何避免并发修改异常"><a href="#✅-3-如何避免并发修改异常" class="headerlink" title="✅ 3. 如何避免并发修改异常"></a>✅ <strong>3. 如何避免并发修改异常</strong></h2><h3 id="3-1-使用-Iterator-的-remove-方法"><a href="#3-1-使用-Iterator-的-remove-方法" class="headerlink" title="3.1 使用 Iterator 的 remove() 方法"></a><strong>3.1 使用 <code>Iterator</code> 的 <code>remove()</code> 方法</strong></h3><p>如果在遍历集合时需要删除元素，可以使用 <code>Iterator</code> 提供的 <code>remove()</code> 方法。这种方法会在删除元素时保持迭代器的状态一致，从而避免并发修改异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Iterator;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IteratorRemoveExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        list.add(<span class="hljs-string">&quot;Java&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;Python&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;C++&quot;</span>);<br><br>        Iterator&lt;String&gt; iterator = list.iterator();<br>        <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">lang</span> <span class="hljs-operator">=</span> iterator.next();<br>            <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;Python&quot;</span>.equals(lang)) &#123;<br>                iterator.remove(); <span class="hljs-comment">// 使用 iterator.remove() 删除元素</span><br>            &#125;<br>        &#125;<br><br>        System.out.println(list); <span class="hljs-comment">// [Java, C++]</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-2-使用-CopyOnWriteArrayList-等线程安全集合"><a href="#3-2-使用-CopyOnWriteArrayList-等线程安全集合" class="headerlink" title="3.2 使用 CopyOnWriteArrayList 等线程安全集合"></a><strong>3.2 使用 <code>CopyOnWriteArrayList</code> 等线程安全集合</strong></h3><p>如果你需要在多线程环境中进行集合的修改操作，可以使用线程安全的集合类，如 <strong><code>CopyOnWriteArrayList</code></strong> 和 <strong><code>ConcurrentHashMap</code></strong>。这些类在修改集合时会创建集合的副本，因此不会发生并发修改异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.CopyOnWriteArrayList;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcurrentModificationSafeExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        CopyOnWriteArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CopyOnWriteArrayList</span>&lt;&gt;();<br>        list.add(<span class="hljs-string">&quot;Java&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;Python&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;C++&quot;</span>);<br><br>        <span class="hljs-keyword">for</span> (String lang : list) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;Python&quot;</span>.equals(lang)) &#123;<br>                list.remove(lang); <span class="hljs-comment">// 使用线程安全的 CopyOnWriteArrayList，删除时不会抛出异常</span><br>            &#125;<br>        &#125;<br><br>        System.out.println(list); <span class="hljs-comment">// [Java, C++]</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>解释</strong>：<code>CopyOnWriteArrayList</code> 是线程安全的，它通过在修改集合时创建一个副本来确保在遍历时不会出现并发修改异常。它适用于遍历频繁但修改较少的场景。</p></blockquote><h3 id="3-3-使用-forEachRemaining-方法"><a href="#3-3-使用-forEachRemaining-方法" class="headerlink" title="3.3 使用 forEachRemaining() 方法"></a><strong>3.3 使用 <code>forEachRemaining()</code> 方法</strong></h3><p><code>Iterator</code> 提供了 <code>forEachRemaining()</code> 方法，可以在遍历时修改集合的元素。通过这种方式，可以避免在迭代时直接修改集合的结构。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Iterator;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IteratorForEachRemainingExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        list.add(<span class="hljs-string">&quot;Java&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;Python&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;C++&quot;</span>);<br><br>        Iterator&lt;String&gt; iterator = list.iterator();<br>        iterator.forEachRemaining(lang -&gt; &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;Python&quot;</span>.equals(lang)) &#123;<br>                iterator.remove(); <span class="hljs-comment">// 正确的删除方式</span><br>            &#125;<br>        &#125;);<br><br>        System.out.println(list); <span class="hljs-comment">// [Java, C++]</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="✅-4-总结"><a href="#✅-4-总结" class="headerlink" title="✅ 4. 总结"></a>✅ <strong>4. 总结</strong></h2><ul><li><strong>并发修改异常</strong>：当在遍历集合的过程中修改集合的结构时（如 <code>add()</code> 或 <code>remove()</code>），可能会抛出 <code>ConcurrentModificationException</code>。</li><li><strong>避免方式</strong>：<ul><li>使用 <code>Iterator</code> 的 <code>remove()</code> 方法来安全删除元素。</li><li>使用线程安全的集合类，如 <code>CopyOnWriteArrayList</code>，避免并发修改异常。</li><li>使用 <code>forEachRemaining()</code> 方法遍历 <code>Iterator</code> 时修改集合。</li></ul></li></ul><p>并发修改异常是一种常见的错误，正确的做法是通过提供合适的 API（如 <code>Iterator.remove()</code>）或者使用线程安全的集合类来避免它的发生。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Collection</title>
      <link href="/2025/03/31/javaBasics/3.1%20Collection/"/>
      <url>/2025/03/31/javaBasics/3.1%20Collection/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-Collection-常用功能详解"><a href="#Java-Collection-常用功能详解" class="headerlink" title="Java Collection 常用功能详解"></a><strong>Java Collection 常用功能详解</strong></h1><p>在 Java 中，<code>Collection</code> 接口是所有集合类的根接口，主要用于存储和操作一组对象。它的常用功能包括添加、删除、遍历、排序、筛选等操作。  </p><h2 id="✅-1-Collection-的核心方法"><a href="#✅-1-Collection-的核心方法" class="headerlink" title="✅ 1. Collection 的核心方法"></a>✅ <strong>1. Collection 的核心方法</strong></h2><p><code>Collection</code> 接口定义了一些通用方法，这些方法被 <code>List</code>、<code>Set</code> 等子接口继承。</p><table><thead><tr><th><strong>方法</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td><code>add(E e)</code></td><td>添加元素</td></tr><tr><td><code>addAll(Collection&lt;? extends E&gt; c)</code></td><td>添加另一个集合的所有元素</td></tr><tr><td><code>remove(Object o)</code></td><td>删除指定元素</td></tr><tr><td><code>removeAll(Collection&lt;?&gt; c)</code></td><td>删除另一个集合中的所有元素</td></tr><tr><td><code>clear()</code></td><td>清空集合</td></tr><tr><td><code>contains(Object o)</code></td><td>检查集合是否包含某个元素</td></tr><tr><td><code>containsAll(Collection&lt;?&gt; c)</code></td><td>检查集合是否包含另一个集合的所有元素</td></tr><tr><td><code>isEmpty()</code></td><td>判断集合是否为空</td></tr><tr><td><code>size()</code></td><td>返回集合中元素个数</td></tr><tr><td><code>toArray()</code></td><td>转换为数组</td></tr><tr><td><code>iterator()</code></td><td>获取迭代器用于遍历</td></tr></tbody></table><hr><h2 id="✅-2-Collection-的常用功能"><a href="#✅-2-Collection-的常用功能" class="headerlink" title="✅ 2. Collection 的常用功能"></a>✅ <strong>2. Collection 的常用功能</strong></h2><h3 id="2-1-添加元素"><a href="#2-1-添加元素" class="headerlink" title="2.1 添加元素"></a><strong>2.1 添加元素</strong></h3><p>可以使用 <code>add()</code> 方法向 <code>Collection</code> 添加元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Collection;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CollectionAddExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Collection&lt;String&gt; coll = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        coll.add(<span class="hljs-string">&quot;Java&quot;</span>);<br>        coll.add(<span class="hljs-string">&quot;Python&quot;</span>);<br>        coll.add(<span class="hljs-string">&quot;C++&quot;</span>);<br><br>        System.out.println(coll); <span class="hljs-comment">// [Java, Python, C++]</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="2-2-删除元素"><a href="#2-2-删除元素" class="headerlink" title="2.2 删除元素"></a><strong>2.2 删除元素</strong></h3><p>可以使用 <code>remove()</code> 删除指定元素，或者 <code>clear()</code> 清空所有元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Collection;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CollectionRemoveExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Collection&lt;String&gt; coll = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        coll.add(<span class="hljs-string">&quot;Java&quot;</span>);<br>        coll.add(<span class="hljs-string">&quot;Python&quot;</span>);<br>        coll.add(<span class="hljs-string">&quot;C++&quot;</span>);<br><br>        coll.remove(<span class="hljs-string">&quot;Python&quot;</span>); <span class="hljs-comment">// 删除 &quot;Python&quot;</span><br>        System.out.println(coll); <span class="hljs-comment">// [Java, C++]</span><br><br>        coll.clear(); <span class="hljs-comment">// 清空集合</span><br>        System.out.println(coll.isEmpty()); <span class="hljs-comment">// true</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="2-3-判断元素是否存在"><a href="#2-3-判断元素是否存在" class="headerlink" title="2.3 判断元素是否存在"></a><strong>2.3 判断元素是否存在</strong></h3><p>使用 <code>contains()</code> 判断集合中是否包含某个元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.HashSet;<br><span class="hljs-keyword">import</span> java.util.Set;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CollectionContainsExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Set&lt;Integer&gt; numbers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        numbers.add(<span class="hljs-number">10</span>);<br>        numbers.add(<span class="hljs-number">20</span>);<br>        numbers.add(<span class="hljs-number">30</span>);<br><br>        System.out.println(numbers.contains(<span class="hljs-number">20</span>)); <span class="hljs-comment">// true</span><br>        System.out.println(numbers.contains(<span class="hljs-number">40</span>)); <span class="hljs-comment">// false</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="2-4-遍历集合"><a href="#2-4-遍历集合" class="headerlink" title="2.4 遍历集合"></a><strong>2.4 遍历集合</strong></h3><p>遍历 <code>Collection</code> 常用 <strong>三种方式</strong>：</p><ol><li><strong><code>Iterator</code> 迭代器</strong></li><li><strong>增强 <code>for</code> 循环</strong></li><li><strong>Lambda 表达式</strong></li></ol><h4 id="方式-1：Iterator-迭代器"><a href="#方式-1：Iterator-迭代器" class="headerlink" title="方式 1：Iterator 迭代器"></a><strong>方式 1：<code>Iterator</code> 迭代器</strong></h4><p>Collection集合获取迭代器的方法</p><table><thead><tr><th align="center">方法名称</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">Iterator<E> iterator()</td><td align="center">返回集合中的迭代器对象，该迭代器对象默认指向当前集合的第一个元素</td></tr></tbody></table><p>Iterator迭代器中的常用方法</p><table><thead><tr><th align="center">方法名称</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">boolean hasNext()</td><td align="center">询问当前位置是否有元素存在，存在返回true，不存在返回false</td></tr><tr><td align="center">E next()</td><td align="center">获取当前位置的元素，并同时将迭代器对象指向下一个元素处</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Iterator;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CollectionIteratorExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        list.add(<span class="hljs-string">&quot;Java&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;Python&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;C++&quot;</span>);<br><br>        Iterator&lt;String&gt; iterator = list.iterator();<br>        <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;  <br>            System.out.println(iterator.next());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="方式-2：增强-for-循环"><a href="#方式-2：增强-for-循环" class="headerlink" title="方式 2：增强 for 循环"></a><strong>方式 2：增强 <code>for</code> 循环</strong></h4><p>增强for可以遍历集合或者数组</p><p>增强for遍历集合，本质就是迭代器遍历集合的简化写法</p><p>格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(元素的数据类型 变量名 : 数组或集合)&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CollectionForEachExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        list.add(<span class="hljs-string">&quot;Java&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;Python&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;C++&quot;</span>);<br><br>        <span class="hljs-keyword">for</span> (String lang : list) &#123;<br>            System.out.println(lang);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="方式-3：Lambda-表达式（Java-8）"><a href="#方式-3：Lambda-表达式（Java-8）" class="headerlink" title="方式 3：Lambda 表达式（Java 8）"></a><strong>方式 3：Lambda 表达式（Java 8）</strong></h4><table><thead><tr><th align="center">方法名称</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">default void forEach(Consumer&lt;? super T&gt; action)</td><td align="center">结合lambda遍历集合</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CollectionLambdaExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        list.add(<span class="hljs-string">&quot;Java&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;Python&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;C++&quot;</span>);<br><br>        list.forEach(System.out::println);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="2-5-集合转换为数组"><a href="#2-5-集合转换为数组" class="headerlink" title="2.5 集合转换为数组"></a><strong>2.5 集合转换为数组</strong></h3><p>使用 <code>toArray()</code> 方法将 <code>Collection</code> 转换为数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CollectionToArrayExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        list.add(<span class="hljs-string">&quot;Java&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;Python&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;C++&quot;</span>);<br><br>        String[] array = list.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">for</span> (String lang : array) &#123;<br>            System.out.println(lang);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="2-6-批量操作"><a href="#2-6-批量操作" class="headerlink" title="2.6 批量操作"></a><strong>2.6 批量操作</strong></h3><h4 id="合并集合"><a href="#合并集合" class="headerlink" title="合并集合"></a><strong>合并集合</strong></h4><p>使用 <code>addAll()</code> 方法将一个集合中的所有元素添加到另一个集合中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CollectionAddAllExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;String&gt; list1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        list1.add(<span class="hljs-string">&quot;Java&quot;</span>);<br>        list1.add(<span class="hljs-string">&quot;Python&quot;</span>);<br><br>        List&lt;String&gt; list2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        list2.add(<span class="hljs-string">&quot;C++&quot;</span>);<br>        list2.add(<span class="hljs-string">&quot;Go&quot;</span>);<br><br>        list1.addAll(list2);<br>        System.out.println(list1); <span class="hljs-comment">// [Java, Python, C++, Go]</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="求交集"><a href="#求交集" class="headerlink" title="求交集"></a><strong>求交集</strong></h4><p>使用 <code>retainAll()</code> 方法保留两个集合的<strong>交集</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.HashSet;<br><span class="hljs-keyword">import</span> java.util.Set;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CollectionRetainAllExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Set&lt;String&gt; set1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        set1.add(<span class="hljs-string">&quot;Java&quot;</span>);<br>        set1.add(<span class="hljs-string">&quot;Python&quot;</span>);<br>        set1.add(<span class="hljs-string">&quot;C++&quot;</span>);<br><br>        Set&lt;String&gt; set2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        set2.add(<span class="hljs-string">&quot;Python&quot;</span>);<br>        set2.add(<span class="hljs-string">&quot;C++&quot;</span>);<br>        set2.add(<span class="hljs-string">&quot;Go&quot;</span>);<br><br>        set1.retainAll(set2); <span class="hljs-comment">// 仅保留交集</span><br>        System.out.println(set1); <span class="hljs-comment">// [Python, C++]</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="求差集"><a href="#求差集" class="headerlink" title="求差集"></a><strong>求差集</strong></h4><p>使用 <code>removeAll()</code> 删除另一个集合中的元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.HashSet;<br><span class="hljs-keyword">import</span> java.util.Set;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CollectionRemoveAllExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Set&lt;String&gt; set1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        set1.add(<span class="hljs-string">&quot;Java&quot;</span>);<br>        set1.add(<span class="hljs-string">&quot;Python&quot;</span>);<br>        set1.add(<span class="hljs-string">&quot;C++&quot;</span>);<br><br>        Set&lt;String&gt; set2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        set2.add(<span class="hljs-string">&quot;Python&quot;</span>);<br>        set2.add(<span class="hljs-string">&quot;C++&quot;</span>);<br><br>        set1.removeAll(set2); <span class="hljs-comment">// 移除 set2 中的元素</span><br>        System.out.println(set1); <span class="hljs-comment">// [Java]</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="✅-总结"><a href="#✅-总结" class="headerlink" title="✅ 总结"></a>✅ <strong>总结</strong></h2><h3 id="1-常见方法"><a href="#1-常见方法" class="headerlink" title="1. 常见方法"></a><strong>1. 常见方法</strong></h3><ul><li><code>add()</code> &#x2F; <code>remove()</code> &#x2F; <code>clear()</code></li><li><code>contains()</code> &#x2F; <code>size()</code> &#x2F; <code>isEmpty()</code></li><li><code>toArray()</code> 转换为数组</li><li><code>addAll()</code> &#x2F; <code>removeAll()</code> &#x2F; <code>retainAll()</code>（批量操作）</li></ul><h3 id="2-遍历方式"><a href="#2-遍历方式" class="headerlink" title="2. 遍历方式"></a><strong>2. 遍历方式</strong></h3><ul><li>增强 <code>for</code> 循环</li><li><code>Iterator</code> 迭代器</li><li>Lambda 表达式（Java 8）</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LinkedList</title>
      <link href="/2025/03/28/javaBasics/2.6%20LinkList/"/>
      <url>/2025/03/28/javaBasics/2.6%20LinkList/</url>
      
        <content type="html"><![CDATA[<p>在 <strong>Java</strong> 中，<code>LinkedList</code> 是 <strong>java.util</strong> 包中的一个类，实现了 <strong>List</strong> 接口和 <strong>Deque</strong> 接口。它是基于<strong>双向链表</strong>的数据结构，适合频繁插入和删除数据的场景。  </p><hr><h2 id="✅-1-LinkedList-的特点"><a href="#✅-1-LinkedList-的特点" class="headerlink" title="✅ 1. LinkedList 的特点"></a>✅ <strong>1. LinkedList 的特点</strong></h2><ul><li><strong>链表结构</strong>：每个节点包含数据和指向前后节点的引用。  </li><li><strong>插入和删除效率高</strong>：在链表中增加或删除元素的时间复杂度为 <strong>O(1)</strong>。  </li><li><strong>访问效率低</strong>：由于不是基于数组的结构，查找元素的时间复杂度为 <strong>O(n)</strong>。  </li><li><strong>双向链表</strong>：支持从头到尾和从尾到头的遍历。</li></ul><hr><h2 id="✅-2-创建-LinkedList"><a href="#✅-2-创建-LinkedList" class="headerlink" title="✅ 2. 创建 LinkedList"></a>✅ <strong>2. 创建 LinkedList</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.LinkedList;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建一个存储字符串的 LinkedList</span><br>        LinkedList&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><br>        <span class="hljs-comment">// 添加元素</span><br>        list.add(<span class="hljs-string">&quot;苹果&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;香蕉&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;橘子&quot;</span>);<br><br>        System.out.println(<span class="hljs-string">&quot;初始链表: &quot;</span> + list);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="✅-3-常用方法"><a href="#✅-3-常用方法" class="headerlink" title="✅ 3. 常用方法"></a>✅ <strong>3. 常用方法</strong></h2><table><thead><tr><th><strong>方法</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><code>add(E e)</code></td><td>添加元素到链表尾部</td></tr><tr><td><code>addFirst(E e)</code></td><td>在链表头部添加元素</td></tr><tr><td><code>addLast(E e)</code></td><td>在链表尾部添加元素</td></tr><tr><td><code>remove()</code></td><td>删除并返回头部元素</td></tr><tr><td><code>removeFirst()</code></td><td>删除并返回头部元素</td></tr><tr><td><code>removeLast()</code></td><td>删除并返回尾部元素</td></tr><tr><td><code>get(int index)</code></td><td>获取指定位置的元素</td></tr><tr><td><code>getFirst()</code></td><td>获取头部元素</td></tr><tr><td><code>getLast()</code></td><td>获取尾部元素</td></tr><tr><td><code>size()</code></td><td>获取链表长度</td></tr><tr><td><code>isEmpty()</code></td><td>判断链表是否为空</td></tr><tr><td><code>contains(Object o)</code></td><td>判断链表是否包含某个元素</td></tr><tr><td><code>clear()</code></td><td>清空链表</td></tr></tbody></table><hr><h2 id="✅-4-示例：基本操作"><a href="#✅-4-示例：基本操作" class="headerlink" title="✅ 4. 示例：基本操作"></a>✅ <strong>4. 示例：基本操作</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.LinkedList;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        LinkedList&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><br>        <span class="hljs-comment">// 添加元素</span><br>        list.add(<span class="hljs-string">&quot;Java&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;Python&quot;</span>);<br>        list.addFirst(<span class="hljs-string">&quot;C++&quot;</span>);    <span class="hljs-comment">// 添加到头部</span><br>        list.addLast(<span class="hljs-string">&quot;JavaScript&quot;</span>); <span class="hljs-comment">// 添加到尾部</span><br><br>        System.out.println(<span class="hljs-string">&quot;链表内容: &quot;</span> + list);<br><br>        <span class="hljs-comment">// 获取元素</span><br>        System.out.println(<span class="hljs-string">&quot;第一个元素: &quot;</span> + list.getFirst());<br>        System.out.println(<span class="hljs-string">&quot;最后一个元素: &quot;</span> + list.getLast());<br>        System.out.println(<span class="hljs-string">&quot;索引1的元素: &quot;</span> + list.get(<span class="hljs-number">1</span>));<br><br>        <span class="hljs-comment">// 删除元素</span><br>        list.removeFirst();  <span class="hljs-comment">// 删除头部元素</span><br>        list.removeLast();   <span class="hljs-comment">// 删除尾部元素</span><br>        System.out.println(<span class="hljs-string">&quot;删除后的链表: &quot;</span> + list);<br><br>        <span class="hljs-comment">// 判断元素是否存在</span><br>        System.out.println(<span class="hljs-string">&quot;是否包含 Python: &quot;</span> + list.contains(<span class="hljs-string">&quot;Python&quot;</span>));<br><br>        <span class="hljs-comment">// 清空链表</span><br>        list.clear();<br>        System.out.println(<span class="hljs-string">&quot;清空后链表是否为空: &quot;</span> + list.isEmpty());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="✅-5-LinkedList-的遍历方式"><a href="#✅-5-LinkedList-的遍历方式" class="headerlink" title="✅ 5. LinkedList 的遍历方式"></a>✅ <strong>5. LinkedList 的遍历方式</strong></h2><h3 id="方式一：普通-for-循环"><a href="#方式一：普通-for-循环" class="headerlink" title="方式一：普通 for 循环"></a><strong>方式一：普通 for 循环</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; list.size(); i++) &#123;<br>    System.out.println(list.get(i));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="方式二：增强-for-循环"><a href="#方式二：增强-for-循环" class="headerlink" title="方式二：增强 for 循环"></a><strong>方式二：增强 for 循环</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (String s : list) &#123;<br>    System.out.println(s);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="方式三：使用-Iterator"><a href="#方式三：使用-Iterator" class="headerlink" title="方式三：使用 Iterator"></a><strong>方式三：使用 Iterator</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Iterator;<br><br>Iterator&lt;String&gt; iterator = list.iterator();<br><span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>    System.out.println(iterator.next());<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="方式四：使用-Lambda-表达式"><a href="#方式四：使用-Lambda-表达式" class="headerlink" title="方式四：使用 Lambda 表达式"></a><strong>方式四：使用 Lambda 表达式</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">list.forEach(s -&gt; System.out.println(s));<br></code></pre></td></tr></table></figure><hr><h2 id="✅-6-LinkedList-vs-ArrayList"><a href="#✅-6-LinkedList-vs-ArrayList" class="headerlink" title="✅ 6. LinkedList vs ArrayList"></a>✅ <strong>6. LinkedList vs ArrayList</strong></h2><table><thead><tr><th><strong>特性</strong></th><th><strong>LinkedList</strong></th><th><strong>ArrayList</strong></th></tr></thead><tbody><tr><td><strong>底层结构</strong></td><td>双向链表</td><td>动态数组</td></tr><tr><td><strong>插入和删除</strong></td><td>O(1)（在头部或尾部）</td><td>O(n)（中间位置需要移动元素）</td></tr><tr><td><strong>查找元素</strong></td><td>O(n)</td><td>O(1)</td></tr><tr><td><strong>内存占用</strong></td><td>较高（需要额外存储前后指针）</td><td>较低（只存储数据）</td></tr><tr><td><strong>适用场景</strong></td><td>频繁插入、删除数据</td><td>频繁随机访问数据</td></tr></tbody></table><ul><li>如果需要<strong>快速插入和删除</strong>，使用 <code>LinkedList</code>。  </li><li>如果需要<strong>频繁访问元素</strong>，使用 <code>ArrayList</code>。</li></ul><hr><h2 id="✅-总结"><a href="#✅-总结" class="headerlink" title="✅ 总结"></a>✅ <strong>总结</strong></h2><ul><li><code>LinkedList</code> 是基于<strong>双向链表</strong>实现的，插入和删除效率高。  </li><li>支持<strong>队列</strong>和<strong>栈</strong>操作，可以当作<strong>双端队列</strong>使用。  </li><li>不适合大量的随机访问，推荐在需要频繁增删的场景中使用。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用API </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ArrayList</title>
      <link href="/2025/03/28/javaBasics/2.5%20ArrayList/"/>
      <url>/2025/03/28/javaBasics/2.5%20ArrayList/</url>
      
        <content type="html"><![CDATA[<p>在 Java 中，<code>ArrayList</code> 是 <code>java.util</code> 包中的一个类，用于存储动态数组。它提供了比普通数组更灵活的功能，可以自动调整大小。  </p><hr><h2 id="✅1-创建-ArrayList"><a href="#✅1-创建-ArrayList" class="headerlink" title="✅1. 创建 ArrayList"></a><strong>✅1. 创建 ArrayList</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建一个存储字符串的 ArrayList</span><br>        ArrayList&lt;String&gt; list1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>        <span class="hljs-comment">// 使用 List 接口引用</span><br>        List&lt;Integer&gt; list2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong><code>ArrayList</code></strong> 是实现类，<strong><code>List</code></strong> 是接口。  </li><li><strong>泛型 <code>&lt;E&gt;</code></strong> 指定存储的数据类型。  </li><li>如果没有指定类型：<code>ArrayList list = new ArrayList();</code>（不推荐）</li></ul><hr><h2 id="✅2-常用方法"><a href="#✅2-常用方法" class="headerlink" title="✅2. 常用方法"></a><strong>✅2. 常用方法</strong></h2><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>add(E e)</code></td><td>添加元素</td></tr><tr><td><code>add(int index, E e)</code></td><td>在指定位置插入元素</td></tr><tr><td><code>remove(int index)</code></td><td>删除指定位置的元素</td></tr><tr><td><code>remove(Object o)</code></td><td>删除指定元素</td></tr><tr><td><code>get(int index)</code></td><td>获取指定位置的元素</td></tr><tr><td><code>set(int index, E e)</code></td><td>修改指定位置的元素</td></tr><tr><td><code>size()</code></td><td>获取元素数量</td></tr><tr><td><code>isEmpty()</code></td><td>判断是否为空</td></tr><tr><td><code>contains(Object o)</code></td><td>判断是否包含某个元素</td></tr><tr><td><code>clear()</code></td><td>清空所有元素</td></tr></tbody></table><hr><h2 id="✅3-示例：基本操作"><a href="#✅3-示例：基本操作" class="headerlink" title="✅3. 示例：基本操作"></a><strong>✅3. 示例：基本操作</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>        <span class="hljs-comment">// 添加元素</span><br>        list.add(<span class="hljs-string">&quot;苹果&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;香蕉&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;橘子&quot;</span>);<br><br>        System.out.println(<span class="hljs-string">&quot;初始列表: &quot;</span> + list);<br><br>        <span class="hljs-comment">// 在指定位置插入元素</span><br>        list.add(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;芒果&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;插入芒果后: &quot;</span> + list);<br><br>        <span class="hljs-comment">// 获取元素</span><br>        System.out.println(<span class="hljs-string">&quot;第二个元素: &quot;</span> + list.get(<span class="hljs-number">1</span>));<br><br>        <span class="hljs-comment">// 修改元素</span><br>        list.set(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;西瓜&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;修改后: &quot;</span> + list);<br><br>        <span class="hljs-comment">// 删除元素</span><br>        list.remove(<span class="hljs-string">&quot;香蕉&quot;</span>); <span class="hljs-comment">// 删除具体元素</span><br>        System.out.println(<span class="hljs-string">&quot;删除香蕉后: &quot;</span> + list);<br><br>        list.remove(<span class="hljs-number">1</span>); <span class="hljs-comment">// 删除索引位置的元素</span><br>        System.out.println(<span class="hljs-string">&quot;删除索引1后: &quot;</span> + list);<br><br>        <span class="hljs-comment">// 判断是否包含</span><br>        System.out.println(<span class="hljs-string">&quot;是否包含苹果: &quot;</span> + list.contains(<span class="hljs-string">&quot;苹果&quot;</span>));<br><br>        <span class="hljs-comment">// 清空列表</span><br>        list.clear();<br>        System.out.println(<span class="hljs-string">&quot;清空后: &quot;</span> + list.isEmpty());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="✅4-遍历-ArrayList"><a href="#✅4-遍历-ArrayList" class="headerlink" title="✅4. 遍历 ArrayList"></a><strong>✅4. 遍历 ArrayList</strong></h2><h3 id="方式一：for-each-循环"><a href="#方式一：for-each-循环" class="headerlink" title="方式一：for-each 循环"></a><strong>方式一：for-each 循环</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>list.add(<span class="hljs-string">&quot;Java&quot;</span>);<br>list.add(<span class="hljs-string">&quot;Python&quot;</span>);<br>list.add(<span class="hljs-string">&quot;C++&quot;</span>);<br><br><span class="hljs-keyword">for</span> (String lang : list) &#123;<br>    System.out.println(lang);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="方式二：普通-for-循环"><a href="#方式二：普通-for-循环" class="headerlink" title="方式二：普通 for 循环"></a><strong>方式二：普通 for 循环</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; list.size(); i++) &#123;<br>    System.out.println(list.get(i));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="方式三：使用-Lambda-表达式"><a href="#方式三：使用-Lambda-表达式" class="headerlink" title="方式三：使用 Lambda 表达式"></a><strong>方式三：使用 Lambda 表达式</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">list.forEach(lang -&gt; System.out.println(lang));<br></code></pre></td></tr></table></figure><hr><h2 id="✅5-ArrayList-与数组转换"><a href="#✅5-ArrayList-与数组转换" class="headerlink" title="✅5. ArrayList 与数组转换"></a><strong>✅5. ArrayList 与数组转换</strong></h2><h3 id="ArrayList-转-数组"><a href="#ArrayList-转-数组" class="headerlink" title="ArrayList 转 数组"></a><strong>ArrayList 转 数组</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">String[] array = list.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[<span class="hljs-number">0</span>]);<br><span class="hljs-keyword">for</span> (String s : array) &#123;<br>    System.out.println(s);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="数组-转-ArrayList"><a href="#数组-转-ArrayList" class="headerlink" title="数组 转 ArrayList"></a><strong>数组 转 ArrayList</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.List;<br><br>String[] array = &#123;<span class="hljs-string">&quot;Java&quot;</span>, <span class="hljs-string">&quot;Python&quot;</span>, <span class="hljs-string">&quot;C++&quot;</span>&#125;;<br>List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(Arrays.asList(array));<br>System.out.println(list);<br></code></pre></td></tr></table></figure><hr><h2 id="✅总结"><a href="#✅总结" class="headerlink" title="✅总结"></a><strong>✅总结</strong></h2><ul><li><strong><code>ArrayList</code></strong> 适合需要频繁读取数据的场景，增删元素时性能较低。  </li><li>如果需要频繁增删数据，可以考虑使用 <strong><code>LinkedList</code></strong>。  </li><li><code>ArrayList</code> 是<strong>线程不安全</strong>的，如果需要在多线程环境中使用，请考虑使用 <code>Collections.synchronizedList()</code> 或 <code>CopyOnWriteArrayList</code>。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用API </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>String</title>
      <link href="/2025/03/28/javaBasics/2.4%20String/"/>
      <url>/2025/03/28/javaBasics/2.4%20String/</url>
      
        <content type="html"><![CDATA[<p>在 Java 中，<code>String</code> 类是最常用的数据类型之一，它代表不可变的字符串。<code>String</code> 提供了丰富的 API，用于字符串操作，如查找、替换、截取、格式化等。  </p><hr><h2 id="✅-1-创建字符串"><a href="#✅-1-创建字符串" class="headerlink" title="✅ 1. 创建字符串"></a>✅ <strong>1. 创建字符串</strong></h2><p>Java 提供了多种方式来创建字符串：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello&quot;</span>;  <span class="hljs-comment">// 直接赋值（推荐）</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;Hello&quot;</span>);  <span class="hljs-comment">// 通过构造方法（不推荐）</span><br><span class="hljs-type">char</span>[] chars = &#123;<span class="hljs-string">&#x27;H&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>&#125;;<br><span class="hljs-type">String</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(chars);  <span class="hljs-comment">// 通过字符数组创建</span><br></code></pre></td></tr></table></figure><hr><h2 id="✅-2-字符串基本操作"><a href="#✅-2-字符串基本操作" class="headerlink" title="✅ 2. 字符串基本操作"></a>✅ <strong>2. 字符串基本操作</strong></h2><h3 id="（1）获取字符串长度"><a href="#（1）获取字符串长度" class="headerlink" title="（1）获取字符串长度"></a><strong>（1）获取字符串长度</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello, World!&quot;</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> str.length();<br>System.out.println(length); <span class="hljs-comment">// 13</span><br></code></pre></td></tr></table></figure><h3 id="（2）获取字符串中的某个字符"><a href="#（2）获取字符串中的某个字符" class="headerlink" title="（2）获取字符串中的某个字符"></a><strong>（2）获取字符串中的某个字符</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">char</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> str.charAt(<span class="hljs-number">0</span>);<br>System.out.println(ch); <span class="hljs-comment">// &#x27;H&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="（3）字符串拼接"><a href="#（3）字符串拼接" class="headerlink" title="（3）字符串拼接"></a><strong>（3）字符串拼接</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot; World&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> s1.concat(s2);<br>System.out.println(result); <span class="hljs-comment">// &quot;Hello World&quot;</span><br></code></pre></td></tr></table></figure><blockquote><p><strong>⚠ 注意</strong>：尽量使用 <code>StringBuilder</code> 进行拼接，<code>String</code> 的拼接会创建新的对象，效率较低。</p></blockquote><hr><h2 id="✅-3-查找与匹配"><a href="#✅-3-查找与匹配" class="headerlink" title="✅ 3. 查找与匹配"></a>✅ <strong>3. 查找与匹配</strong></h2><h3 id="（1）判断是否包含子字符串"><a href="#（1）判断是否包含子字符串" class="headerlink" title="（1）判断是否包含子字符串"></a><strong>（1）判断是否包含子字符串</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-variable">contains</span> <span class="hljs-operator">=</span> str.contains(<span class="hljs-string">&quot;World&quot;</span>);<br>System.out.println(contains); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h3 id="（2）判断是否以某个前缀或后缀开头"><a href="#（2）判断是否以某个前缀或后缀开头" class="headerlink" title="（2）判断是否以某个前缀或后缀开头"></a><strong>（2）判断是否以某个前缀或后缀开头</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(str.startsWith(<span class="hljs-string">&quot;Hello&quot;</span>)); <span class="hljs-comment">// true</span><br>System.out.println(str.endsWith(<span class="hljs-string">&quot;!&quot;</span>)); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h3 id="（3）获取子字符串的位置"><a href="#（3）获取子字符串的位置" class="headerlink" title="（3）获取子字符串的位置"></a><strong>（3）获取子字符串的位置</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> str.indexOf(<span class="hljs-string">&quot;World&quot;</span>); <span class="hljs-comment">// 7</span><br><span class="hljs-type">int</span> <span class="hljs-variable">lastIndex</span> <span class="hljs-operator">=</span> str.lastIndexOf(<span class="hljs-string">&quot;o&quot;</span>); <span class="hljs-comment">// 8</span><br></code></pre></td></tr></table></figure><hr><h2 id="✅-4-字符串截取"><a href="#✅-4-字符串截取" class="headerlink" title="✅ 4. 字符串截取"></a>✅ <strong>4. 字符串截取</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">sub</span> <span class="hljs-operator">=</span> str.substring(<span class="hljs-number">7</span>); <span class="hljs-comment">// 从索引 7 开始截取</span><br>System.out.println(sub); <span class="hljs-comment">// &quot;World!&quot;</span><br><br><span class="hljs-type">String</span> <span class="hljs-variable">sub2</span> <span class="hljs-operator">=</span> str.substring(<span class="hljs-number">7</span>, <span class="hljs-number">12</span>); <span class="hljs-comment">// 截取索引 [7, 12)</span><br>System.out.println(sub2); <span class="hljs-comment">// &quot;World&quot;</span><br></code></pre></td></tr></table></figure><hr><h2 id="✅-5-替换字符串"><a href="#✅-5-替换字符串" class="headerlink" title="✅ 5. 替换字符串"></a>✅ <strong>5. 替换字符串</strong></h2><h3 id="（1）替换单个字符"><a href="#（1）替换单个字符" class="headerlink" title="（1）替换单个字符"></a><strong>（1）替换单个字符</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">newStr</span> <span class="hljs-operator">=</span> str.replace(<span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>);<br>System.out.println(newStr); <span class="hljs-comment">// &quot;Hell0, W0rld!&quot;</span><br></code></pre></td></tr></table></figure><h3 id="（2）替换子字符串"><a href="#（2）替换子字符串" class="headerlink" title="（2）替换子字符串"></a><strong>（2）替换子字符串</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">newStr2</span> <span class="hljs-operator">=</span> str.replace(<span class="hljs-string">&quot;World&quot;</span>, <span class="hljs-string">&quot;Java&quot;</span>);<br>System.out.println(newStr2); <span class="hljs-comment">// &quot;Hello, Java!&quot;</span><br></code></pre></td></tr></table></figure><h3 id="（3）使用正则表达式替换"><a href="#（3）使用正则表达式替换" class="headerlink" title="（3）使用正则表达式替换"></a><strong>（3）使用正则表达式替换</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">replaced</span> <span class="hljs-operator">=</span> str.replaceAll(<span class="hljs-string">&quot;\\w+&quot;</span>, <span class="hljs-string">&quot;X&quot;</span>);<br>System.out.println(replaced); <span class="hljs-comment">// &quot;X, X!&quot;</span><br></code></pre></td></tr></table></figure><hr><h2 id="✅-6-分割字符串"><a href="#✅-6-分割字符串" class="headerlink" title="✅ 6. 分割字符串"></a>✅ <strong>6. 分割字符串</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;apple,banana,orange&quot;</span>;<br>String[] fruits = data.split(<span class="hljs-string">&quot;,&quot;</span>);<br><span class="hljs-keyword">for</span> (String fruit : fruits) &#123;<br>    System.out.println(fruit);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">apple<br>banana<br>orange<br></code></pre></td></tr></table></figure><hr><h2 id="✅-7-大小写转换"><a href="#✅-7-大小写转换" class="headerlink" title="✅ 7. 大小写转换"></a>✅ <strong>7. 大小写转换</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(str.toUpperCase()); <span class="hljs-comment">// &quot;HELLO, WORLD!&quot;</span><br>System.out.println(str.toLowerCase()); <span class="hljs-comment">// &quot;hello, world!&quot;</span><br></code></pre></td></tr></table></figure><hr><h2 id="✅-8-去除首尾空格"><a href="#✅-8-去除首尾空格" class="headerlink" title="✅ 8. 去除首尾空格"></a>✅ <strong>8. 去除首尾空格</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">spaced</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;   Hello World!   &quot;</span>;<br>System.out.println(spaced.trim()); <span class="hljs-comment">// &quot;Hello World!&quot;</span><br></code></pre></td></tr></table></figure><hr><h2 id="✅-9-字符串比较"><a href="#✅-9-字符串比较" class="headerlink" title="✅ 9. 字符串比较"></a>✅ <strong>9. 字符串比较</strong></h2><h3 id="（1）区分大小写"><a href="#（1）区分大小写" class="headerlink" title="（1）区分大小写"></a><strong>（1）区分大小写</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello&quot;</span>;<br>System.out.println(a.equals(b)); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><h3 id="（2）忽略大小写比较"><a href="#（2）忽略大小写比较" class="headerlink" title="（2）忽略大小写比较"></a><strong>（2）忽略大小写比较</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(a.equalsIgnoreCase(b)); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h3 id="（3）按字典顺序比较"><a href="#（3）按字典顺序比较" class="headerlink" title="（3）按字典顺序比较"></a><strong>（3）按字典顺序比较</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(<span class="hljs-string">&quot;abc&quot;</span>.compareTo(<span class="hljs-string">&quot;abd&quot;</span>)); <span class="hljs-comment">// -1</span><br>System.out.println(<span class="hljs-string">&quot;abc&quot;</span>.compareTo(<span class="hljs-string">&quot;abc&quot;</span>)); <span class="hljs-comment">// 0</span><br>System.out.println(<span class="hljs-string">&quot;abd&quot;</span>.compareTo(<span class="hljs-string">&quot;abc&quot;</span>)); <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><hr><h2 id="✅-10-格式化字符串"><a href="#✅-10-格式化字符串" class="headerlink" title="✅ 10. 格式化字符串"></a>✅ <strong>10. 格式化字符串</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">formatted</span> <span class="hljs-operator">=</span> String.format(<span class="hljs-string">&quot;My name is %s and I am %d years old.&quot;</span>, <span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">25</span>);<br>System.out.println(formatted); <br><span class="hljs-comment">// &quot;My name is Alice and I am 25 years old.&quot;</span><br></code></pre></td></tr></table></figure><hr><h2 id="✅-11-判断字符串是否为空"><a href="#✅-11-判断字符串是否为空" class="headerlink" title="✅ 11. 判断字符串是否为空"></a>✅ <strong>11. 判断字符串是否为空</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">emptyStr</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>System.out.println(emptyStr.isEmpty()); <span class="hljs-comment">// true</span><br>System.out.println(emptyStr.isBlank()); <span class="hljs-comment">// true（Java 11+）</span><br></code></pre></td></tr></table></figure><hr><h2 id="✅-12-使用-StringBuilder-进行高效拼接"><a href="#✅-12-使用-StringBuilder-进行高效拼接" class="headerlink" title="✅ 12. 使用 StringBuilder 进行高效拼接"></a>✅ <strong>12. 使用 <code>StringBuilder</code> 进行高效拼接</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>sb.append(<span class="hljs-string">&quot;Hello&quot;</span>).append(<span class="hljs-string">&quot; &quot;</span>).append(<span class="hljs-string">&quot;World!&quot;</span>);<br>System.out.println(sb.toString()); <span class="hljs-comment">// &quot;Hello World!&quot;</span><br></code></pre></td></tr></table></figure><hr><h2 id="✅-总结"><a href="#✅-总结" class="headerlink" title="✅ 总结"></a>✅ <strong>总结</strong></h2><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td><code>length()</code></td><td>获取字符串长度</td></tr><tr><td><code>charAt(index)</code></td><td>获取指定索引位置的字符</td></tr><tr><td><code>concat(str)</code></td><td>拼接字符串</td></tr><tr><td><code>contains(str)</code></td><td>判断是否包含子字符串</td></tr><tr><td><code>startsWith(str) / endsWith(str)</code></td><td>判断是否以某字符串开头&#x2F;结尾</td></tr><tr><td><code>indexOf(str) / lastIndexOf(str)</code></td><td>获取子字符串的索引位置</td></tr><tr><td><code>substring(start, end)</code></td><td>截取子字符串</td></tr><tr><td><code>replace(old, new)</code></td><td>替换字符串</td></tr><tr><td><code>replaceAll(regex, new)</code></td><td>使用正则表达式替换字符串</td></tr><tr><td><code>split(regex)</code></td><td>按照正则表达式分割字符串</td></tr><tr><td><code>toUpperCase() / toLowerCase()</code></td><td>转换大小写</td></tr><tr><td><code>trim()</code></td><td>去除首尾空格</td></tr><tr><td><code>equals(str) / equalsIgnoreCase(str)</code></td><td>字符串比较</td></tr><tr><td><code>compareTo(str)</code></td><td>按字典顺序比较</td></tr><tr><td><code>isEmpty() / isBlank()</code></td><td>判断字符串是否为空</td></tr><tr><td><code>String.format()</code></td><td>字符串格式化</td></tr><tr><td><code>StringBuilder</code></td><td>高效字符串拼接</td></tr></tbody></table><hr>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用API </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>方法引用</title>
      <link href="/2025/03/28/javaBasics/2.3%20%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8/"/>
      <url>/2025/03/28/javaBasics/2.3%20%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>在 <strong>Java</strong> 中，<strong>方法引用（Method Reference）</strong> 是 Java 8 引入的一种简洁的语法形式，用于通过方法的名字来引用方法。它是 <strong>Lambda 表达式</strong> 的一种简化写法，特别适用于需要传递方法作为参数的场景。</p><hr><h2 id="✅-方法引用的分类"><a href="#✅-方法引用的分类" class="headerlink" title="✅ 方法引用的分类"></a>✅ <strong>方法引用的分类</strong></h2><p>方法引用主要有以下四种形式：  </p><table><thead><tr><th><strong>类型</strong></th><th><strong>语法</strong></th><th><strong>示例</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>静态方法引用</td><td><code>ClassName::staticMethod</code></td><td><code>Math::abs</code></td><td>引用类中的静态方法</td></tr><tr><td>实例方法引用（特定对象）</td><td><code>instance::method</code></td><td><code>System.out::println</code></td><td>引用对象的实例方法</td></tr><tr><td>实例方法引用（任意对象）</td><td><code>ClassName::method</code></td><td><code>String::toUpperCase</code></td><td>引用某个类的任意对象的实例方法</td></tr><tr><td>构造器引用</td><td><code>ClassName::new</code></td><td><code>ArrayList::new</code></td><td>引用类的构造方法</td></tr></tbody></table><hr><h2 id="✅-1-静态方法引用"><a href="#✅-1-静态方法引用" class="headerlink" title="✅ 1. 静态方法引用"></a>✅ <strong>1. 静态方法引用</strong></h2><p>静态方法引用用于引用类的静态方法。  </p><h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a><strong>示例</strong>：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StaticMethodReferenceExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;Integer&gt; numbers = Arrays.asList(-<span class="hljs-number">3</span>, -<span class="hljs-number">2</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br>        <br>        <span class="hljs-comment">// 使用静态方法引用 Math::abs</span><br>        numbers.stream()<br>               .map(Math::abs)<br>               .forEach(System.out::println);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>解释</strong>：<code>Math::abs</code> 是静态方法引用，等价于 <code>x -&gt; Math.abs(x)</code>。</li></ul><hr><h2 id="✅-2-实例方法引用（特定对象）"><a href="#✅-2-实例方法引用（特定对象）" class="headerlink" title="✅ 2. 实例方法引用（特定对象）"></a>✅ <strong>2. 实例方法引用（特定对象）</strong></h2><p>实例方法引用用于引用特定对象的实例方法。  </p><h3 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a><strong>示例</strong>：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InstanceMethodReferenceExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;String&gt; names = Arrays.asList(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-string">&quot;Charlie&quot;</span>);<br>        <br>        <span class="hljs-comment">// 使用实例方法引用</span><br>        names.forEach(System.out::println);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>解释</strong>：<code>System.out::println</code> 是方法引用，等价于 <code>x -&gt; System.out.println(x)</code>。</li></ul><hr><h2 id="✅-3-实例方法引用（任意对象）"><a href="#✅-3-实例方法引用（任意对象）" class="headerlink" title="✅ 3. 实例方法引用（任意对象）"></a>✅ <strong>3. 实例方法引用（任意对象）</strong></h2><p>当实例方法的调用目标是流中的每一个对象时，可以使用类名加方法名的形式引用实例方法。  </p><h3 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a><strong>示例</strong>：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InstanceMethodReferenceExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;String&gt; words = Arrays.asList(<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-string">&quot;cherry&quot;</span>);<br>        <br>        <span class="hljs-comment">// 使用实例方法引用</span><br>        words.stream()<br>             .map(String::toUpperCase)<br>             .forEach(System.out::println);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>解释</strong>：<code>String::toUpperCase</code> 是方法引用，等价于 <code>s -&gt; s.toUpperCase()</code>。</li></ul><hr><h2 id="✅-4-构造器引用"><a href="#✅-4-构造器引用" class="headerlink" title="✅ 4. 构造器引用"></a>✅ <strong>4. 构造器引用</strong></h2><p>构造器引用用于创建对象。它通过 <code>ClassName::new</code> 的形式引用类的构造方法。  </p><h3 id="示例：-3"><a href="#示例：-3" class="headerlink" title="示例："></a><strong>示例</strong>：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.stream.Collectors;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConstructorReferenceExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;String&gt; names = List.of(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-string">&quot;Charlie&quot;</span>);<br>        <br>        <span class="hljs-comment">// 使用构造器引用</span><br>        List&lt;String&gt; nameList = names.stream()<br>                                      .collect(Collectors.toCollection(ArrayList::<span class="hljs-keyword">new</span>));<br><br>        System.out.println(nameList);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>解释</strong>：<code>ArrayList::new</code> 是构造器引用，等价于 <code>() -&gt; new ArrayList&lt;&gt;()</code>。</li></ul><hr><h2 id="✅-总结"><a href="#✅-总结" class="headerlink" title="✅ 总结"></a>✅ <strong>总结</strong></h2><table><thead><tr><th><strong>方法引用类型</strong></th><th><strong>语法形式</strong></th><th><strong>等价Lambda表达式</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td>静态方法引用</td><td><code>ClassName::staticMethod</code></td><td><code>(x) -&gt; ClassName.staticMethod(x)</code></td><td><code>Math::abs</code></td></tr><tr><td>实例方法引用（特定对象）</td><td><code>instance::method</code></td><td><code>(x) -&gt; instance.method(x)</code></td><td><code>System.out::println</code></td></tr><tr><td>实例方法引用（任意对象）</td><td><code>ClassName::method</code></td><td><code>(x) -&gt; x.method()</code></td><td><code>String::toUpperCase</code></td></tr><tr><td>构造器引用</td><td><code>ClassName::new</code></td><td><code>() -&gt; new ClassName()</code></td><td><code>ArrayList::new</code></td></tr></tbody></table><hr>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 函数式编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>lambda</title>
      <link href="/2025/03/28/javaBasics/2.2%20lambda/"/>
      <url>/2025/03/28/javaBasics/2.2%20lambda/</url>
      
        <content type="html"><![CDATA[<p>在 <strong>Java</strong> 中，<strong>Lambda表达式</strong> 是 Java 8 引入的一个特性，用于简化代码，特别是在需要使用 <strong>函数式接口</strong> 的场景。它提供了一种简洁的方式来表示匿名函数，使代码更简洁和可读。</p><hr><h2 id="✅1-Lambda-表达式的基本语法"><a href="#✅1-Lambda-表达式的基本语法" class="headerlink" title="✅1. Lambda 表达式的基本语法"></a><strong>✅1. Lambda 表达式的基本语法</strong></h2><p>Lambda 表达式的语法结构如下：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">(参数列表) -&gt; &#123; 方法体 &#125;<br></code></pre></td></tr></table></figure><ul><li><strong>参数列表</strong>：可以有 0 个或多个参数。  </li><li><strong>箭头操作符 <code>-&gt;</code></strong>：用于分隔参数和方法体。  </li><li><strong>方法体</strong>：包含具体的代码逻辑。</li></ul><h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a><strong>示例：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 无参数，直接执行</span><br><span class="hljs-type">Runnable</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> () -&gt; System.out.println(<span class="hljs-string">&quot;Hello, Lambda!&quot;</span>);<br>r.run();<br><br><span class="hljs-comment">// 有参数，有返回值</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Calculator</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>;<br>&#125;<br><br><span class="hljs-type">Calculator</span> <span class="hljs-variable">calc</span> <span class="hljs-operator">=</span> (a, b) -&gt; a + b;<br>System.out.println(<span class="hljs-string">&quot;结果: &quot;</span> + calc.add(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>));<br></code></pre></td></tr></table></figure><hr><h2 id="✅2-使用-Lambda-的条件"><a href="#✅2-使用-Lambda-的条件" class="headerlink" title="✅2. 使用 Lambda 的条件"></a><strong>✅2. 使用 Lambda 的条件</strong></h2><p>Lambda 表达式通常用于<strong>函数式接口</strong>。  </p><ul><li><strong>函数式接口</strong>：只包含一个抽象方法的接口，通常用 <code>@FunctionalInterface</code> 注解标识。  </li><li>Java 自带了很多函数式接口，例如 <code>Runnable</code>、<code>Comparator</code>、<code>Consumer</code> 等。</li></ul><h3 id="自定义函数式接口"><a href="#自定义函数式接口" class="headerlink" title="自定义函数式接口"></a><strong>自定义函数式接口</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Greeting</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHello</span><span class="hljs-params">(String name)</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Greeting</span> <span class="hljs-variable">greeting</span> <span class="hljs-operator">=</span> name -&gt; System.out.println(<span class="hljs-string">&quot;你好, &quot;</span> + name);<br>        greeting.sayHello(<span class="hljs-string">&quot;小明&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="✅3-常见-Lambda-用法"><a href="#✅3-常见-Lambda-用法" class="headerlink" title="✅3. 常见 Lambda 用法"></a><strong>✅3. 常见 Lambda 用法</strong></h2><h3 id="1-使用-Lambda-实现-Runnable"><a href="#1-使用-Lambda-实现-Runnable" class="headerlink" title="(1) 使用 Lambda 实现 Runnable"></a><strong>(1) 使用 Lambda 实现 Runnable</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; System.out.println(<span class="hljs-string">&quot;线程运行中&quot;</span>));<br>thread.start();<br></code></pre></td></tr></table></figure><h3 id="2-使用-Lambda-进行集合遍历"><a href="#2-使用-Lambda-进行集合遍历" class="headerlink" title="(2) 使用 Lambda 进行集合遍历"></a><strong>(2) 使用 Lambda 进行集合遍历</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        list.add(<span class="hljs-string">&quot;Java&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;Python&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;C++&quot;</span>);<br><br>        <span class="hljs-comment">// 使用 Lambda 表达式遍历</span><br>        list.forEach(item -&gt; System.out.println(item));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-使用-Lambda-进行排序"><a href="#3-使用-Lambda-进行排序" class="headerlink" title="(3) 使用 Lambda 进行排序"></a><strong>(3) 使用 Lambda 进行排序</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;String&gt; list = Arrays.asList(<span class="hljs-string">&quot;Banana&quot;</span>, <span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Orange&quot;</span>);<br><br>        <span class="hljs-comment">// 使用 Lambda 表达式排序</span><br>        Collections.sort(list, (a, b) -&gt; a.compareTo(b));<br>        System.out.println(list);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="✅4-使用方法引用"><a href="#✅4-使用方法引用" class="headerlink" title="✅4. 使用方法引用"></a><strong>✅4. 使用方法引用</strong></h2><p>当 Lambda 表达式仅调用一个现有方法时，可以使用方法引用进一步简化代码。<br><strong>语法：</strong> <code>类名::方法名</code> 或 <code>对象名::方法名</code></p><h3 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a><strong>示例：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = Arrays.asList(<span class="hljs-string">&quot;Banana&quot;</span>, <span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Orange&quot;</span>);<br><br><span class="hljs-comment">// 使用方法引用</span><br>list.forEach(System.out::println);<br></code></pre></td></tr></table></figure><p>等价于：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">list.forEach(item -&gt; System.out.println(item));<br></code></pre></td></tr></table></figure><hr><h2 id="✅5-总结"><a href="#✅5-总结" class="headerlink" title="✅5. 总结"></a><strong>✅5. 总结</strong></h2><ul><li><strong>Lambda 表达式</strong> 简化了匿名类的写法。  </li><li>只能用于<strong>函数式接口</strong>。  </li><li>使用 <code>-&gt;</code> 分隔参数和方法体。  </li><li>可以结合<strong>方法引用</strong>进一步简化代码。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 函数式编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>匿名内部类</title>
      <link href="/2025/03/28/javaBasics/2.1%20%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB/"/>
      <url>/2025/03/28/javaBasics/2.1%20%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<ul><li><p>在 <strong>Java</strong> 中，<strong>匿名内部类</strong> 是一种没有名字的类，通常用于简化代码。它用于实现接口或继承类的实例化，通常是在需要创建一次性对象的场景下使用。  </p><hr><h2 id="✅-1-什么是匿名内部类？"><a href="#✅-1-什么是匿名内部类？" class="headerlink" title="✅ 1. 什么是匿名内部类？"></a>✅ <strong>1. 什么是匿名内部类？</strong></h2><p><strong>匿名内部类</strong> 是在声明和实例化类的同时完成的，它没有类名。它可以：  </p><ul><li><strong>继承一个类</strong>  </li><li><strong>实现一个接口</strong></li></ul><p><strong>语法：</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> 父类或接口(参数) &#123;<br>    <span class="hljs-comment">// 重写方法或定义新方法</span><br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="✅-2-使用场景和示例"><a href="#✅-2-使用场景和示例" class="headerlink" title="✅ 2. 使用场景和示例"></a>✅ <strong>2. 使用场景和示例</strong></h2><h3 id="场景一：继承类的匿名内部类"><a href="#场景一：继承类的匿名内部类" class="headerlink" title="场景一：继承类的匿名内部类"></a><strong>场景一：继承类的匿名内部类</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">sound</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;动物发出声音&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建匿名内部类继承 Animal</span><br>        <span class="hljs-type">Animal</span> <span class="hljs-variable">cat</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Animal</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">void</span> <span class="hljs-title function_">sound</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;喵喵叫&quot;</span>);<br>            &#125;<br>        &#125;;<br><br>        cat.sound(); <span class="hljs-comment">// 输出：喵喵叫</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>解释：</strong>  </p><ul><li>使用 <code>new Animal()</code> 创建一个继承 <code>Animal</code> 的匿名类，并重写了 <code>sound()</code> 方法。  </li><li>这种写法适合需要临时重写父类方法的场景。</li></ul><hr><h3 id="场景二：实现接口的匿名内部类"><a href="#场景二：实现接口的匿名内部类" class="headerlink" title="场景二：实现接口的匿名内部类"></a><strong>场景二：实现接口的匿名内部类</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Greeting</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHello</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 使用匿名内部类实现接口</span><br>        <span class="hljs-type">Greeting</span> <span class="hljs-variable">greeting</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Greeting</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHello</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;你好，Java！&quot;</span>);<br>            &#125;<br>        &#125;;<br><br>        greeting.sayHello(); <span class="hljs-comment">// 输出：你好，Java！</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>解释：</strong>  </p><ul><li>匿名类实现了 <code>Greeting</code> 接口并重写了 <code>sayHello()</code> 方法。  </li><li>适合需要一次性实现接口的场景。</li></ul><hr><h3 id="场景三：结合线程的匿名内部类"><a href="#场景三：结合线程的匿名内部类" class="headerlink" title="场景三：结合线程的匿名内部类"></a><strong>场景三：结合线程的匿名内部类</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 使用匿名内部类创建线程</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;线程正在运行: &quot;</span> + Thread.currentThread().getName());<br>            &#125;<br>        &#125;);<br><br>        thread.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>解释：</strong>  </p><ul><li>匿名类实现了 <code>Runnable</code> 接口，并直接传递给 <code>Thread</code>。  </li><li>适合简单的多线程场景。</li></ul><hr><h3 id="场景四：使用-Lambda-替代匿名内部类"><a href="#场景四：使用-Lambda-替代匿名内部类" class="headerlink" title="场景四：使用 Lambda 替代匿名内部类"></a><strong>场景四：使用 Lambda 替代匿名内部类</strong></h3><p>对于只有一个抽象方法的接口（即<strong>函数式接口</strong>），Java 8 引入了 <strong>Lambda 表达式</strong>，可以更简洁地替代匿名内部类。  </p><p><strong>示例：使用 Lambda 替代匿名内部类</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Greeting</span> <span class="hljs-variable">greeting</span> <span class="hljs-operator">=</span> () -&gt; System.out.println(<span class="hljs-string">&quot;你好，Lambda！&quot;</span>);<br>greeting.sayHello();<br></code></pre></td></tr></table></figure><p><strong>解释：</strong>  </p><ul><li>Lambda 只能用于函数式接口。  </li><li>使用 <code>-&gt;</code> 符号简化代码。</li></ul><hr><h2 id="✅-3-匿名内部类的特点"><a href="#✅-3-匿名内部类的特点" class="headerlink" title="✅ 3. 匿名内部类的特点"></a>✅ <strong>3. 匿名内部类的特点</strong></h2><ul><li><strong>没有类名</strong>，只能通过父类或接口的引用进行操作。  </li><li><strong>一次性使用</strong>，通常用于简化代码。  </li><li><strong>可以直接重写方法</strong>，无需额外创建类文件。  </li><li><strong>不能有构造方法</strong>，但可以使用<strong>实例代码块</strong>进行初始化。</li></ul><p><strong>示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    Person(String name) &#123;<br>        System.out.println(<span class="hljs-string">&quot;Person 构造方法: &quot;</span> + name);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 使用实例代码块代替构造方法</span><br>        <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;张三&quot;</span>) &#123;<br>            &#123;<br>                System.out.println(<span class="hljs-string">&quot;匿名内部类中的初始化块&quot;</span>);<br>            &#125;<br>        &#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">Person 构造方法: 张三<br>匿名内部类中的初始化块<br></code></pre></td></tr></table></figure><hr><h2 id="✅-4-总结：什么时候使用匿名内部类？"><a href="#✅-4-总结：什么时候使用匿名内部类？" class="headerlink" title="✅ 4. 总结：什么时候使用匿名内部类？"></a>✅ <strong>4. 总结：什么时候使用匿名内部类？</strong></h2><ul><li><strong>临时性需求</strong>：只需要一次性实现接口或重写方法。  </li><li><strong>简化代码</strong>：不需要创建额外的类文件。  </li><li><strong>事件监听器</strong>：在 GUI 程序中广泛使用匿名内部类处理事件。  </li><li><strong>线程创建</strong>：快速实现 <code>Runnable</code>。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 函数式编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式</title>
      <link href="/2025/03/27/javaBasics/1.8%20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2025/03/27/javaBasics/1.8%20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>正则表达式（<strong>Regular Expression</strong>，简称 <strong>Regex</strong> 或 <strong>RegExp</strong>）是一种用于描述字符串模式的工具，广泛应用于字符串的匹配、搜索、替换和验证等操作。它通过特定的语法规则来匹配字符串中的特定模式。</p><p>在 <strong>Java</strong> 中，正则表达式是通过 <code>java.util.regex</code> 包中的 <strong><code>Pattern</code></strong> 和 <strong><code>Matcher</code></strong> 类来实现的。</p><hr><h2 id="✅-正则表达式的基本构成"><a href="#✅-正则表达式的基本构成" class="headerlink" title="✅ 正则表达式的基本构成"></a>✅ <strong>正则表达式的基本构成</strong></h2><h3 id="1-字符匹配"><a href="#1-字符匹配" class="headerlink" title="1. 字符匹配"></a><strong>1. 字符匹配</strong></h3><ul><li><strong><code>.</code></strong> : 匹配任意一个字符（除了换行符）</li><li><strong><code>\d</code></strong> : 匹配一个数字字符，等价于 <code>[0-9]</code></li><li><strong><code>\D</code></strong> : 匹配非数字字符，等价于 <code>[^0-9]</code></li><li><strong><code>\w</code></strong> : 匹配一个字母、数字或下划线字符，等价于 <code>[a-zA-Z0-9_]</code></li><li><strong><code>\W</code></strong> : 匹配非字母、数字或下划线字符，等价于 <code>[^a-zA-Z0-9_]</code></li><li><strong><code>\s</code></strong> : 匹配一个空白字符（如空格、制表符、换行符等）</li><li><strong><code>\S</code></strong> : 匹配一个非空白字符</li><li><strong><code>\b</code></strong> : 匹配单词边界</li><li><strong><code>\B</code></strong> : 匹配非单词边界</li></ul><h3 id="2-量词"><a href="#2-量词" class="headerlink" title="2. 量词"></a><strong>2. 量词</strong></h3><ul><li><strong><code>*</code></strong> : 匹配前面的字符零次或多次</li><li><strong><code>+</code></strong> : 匹配前面的字符一次或多次</li><li><strong><code>?</code></strong> : 匹配前面的字符零次或一次</li><li><strong><code>&#123;n&#125;</code></strong> : 匹配前面字符恰好 n 次</li><li><strong><code>&#123;n,&#125;</code></strong> : 匹配前面字符至少 n 次</li><li><strong><code>&#123;n,m&#125;</code></strong> : 匹配前面字符至少 n 次，至多 m 次</li></ul><h3 id="3-字符集与范围"><a href="#3-字符集与范围" class="headerlink" title="3. 字符集与范围"></a><strong>3. 字符集与范围</strong></h3><ul><li><strong><code>[abc]</code></strong> : 匹配字符 <code>a</code>、<code>b</code> 或 <code>c</code> 中的任意一个字符</li><li><strong><code>[^abc]</code></strong> : 匹配除 <code>a</code>、<code>b</code>、<code>c</code> 以外的任意字符</li><li><strong><code>[a-z]</code></strong> : 匹配小写字母中的任意一个字符</li><li><strong><code>[A-Z]</code></strong> : 匹配大写字母中的任意一个字符</li><li><strong><code>[0-9]</code></strong> : 匹配数字中的任意一个字符</li></ul><h3 id="4-分组与选择"><a href="#4-分组与选择" class="headerlink" title="4. 分组与选择"></a><strong>4. 分组与选择</strong></h3><ul><li><strong><code>()</code></strong> : 用于分组匹配</li><li><strong><code>|</code></strong> : 表示“或”操作，匹配左边或右边的表达式</li></ul><h3 id="5-其他特殊字符"><a href="#5-其他特殊字符" class="headerlink" title="5. 其他特殊字符"></a><strong>5. 其他特殊字符</strong></h3><ul><li><strong><code>\</code></strong> : 转义字符，用于转义特殊字符（如 <code>.</code>、<code>*</code>、<code>+</code> 等）</li><li><strong><code>^</code></strong> : 匹配输入的开始位置</li><li><strong><code>$</code></strong> : 匹配输入的结束位置</li></ul><hr><h2 id="✅-Java-中正则表达式的应用"><a href="#✅-Java-中正则表达式的应用" class="headerlink" title="✅ Java 中正则表达式的应用"></a>✅ <strong>Java 中正则表达式的应用</strong></h2><h3 id="1-使用-Pattern-类"><a href="#1-使用-Pattern-类" class="headerlink" title="1. 使用 Pattern 类"></a><strong>1. 使用 <code>Pattern</code> 类</strong></h3><p><code>Pattern</code> 类代表了一个正则表达式，并提供了许多方法来对字符串进行匹配操作。它是正则表达式操作的核心。</p><h3 id="2-使用-Matcher-类"><a href="#2-使用-Matcher-类" class="headerlink" title="2. 使用 Matcher 类"></a><strong>2. 使用 <code>Matcher</code> 类</strong></h3><p><code>Matcher</code> 类用于执行与正则表达式相关的匹配操作，如查找、替换、验证等。</p><h3 id="3-常用方法"><a href="#3-常用方法" class="headerlink" title="3. 常用方法"></a><strong>3. 常用方法</strong></h3><table><thead><tr><th><strong>方法</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><code>Pattern.compile(String regex)</code></td><td>编译一个正则表达式，返回一个 <code>Pattern</code> 对象</td></tr><tr><td><code>matcher.find()</code></td><td>查找匹配的字符串</td></tr><tr><td><code>matcher.group()</code></td><td>获取匹配的子字符串</td></tr><tr><td><code>matcher.matches()</code></td><td>检查整个字符串是否与正则表达式匹配</td></tr><tr><td><code>matcher.replaceAll(String replacement)</code></td><td>替换所有匹配的部分</td></tr></tbody></table><hr><h2 id="✅-示例：正则表达式的使用"><a href="#✅-示例：正则表达式的使用" class="headerlink" title="✅ 示例：正则表达式的使用"></a>✅ <strong>示例：正则表达式的使用</strong></h2><h3 id="1-判断字符串是否匹配正则表达式"><a href="#1-判断字符串是否匹配正则表达式" class="headerlink" title="1. 判断字符串是否匹配正则表达式"></a><strong>1. 判断字符串是否匹配正则表达式</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.regex.Pattern;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RegexExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">regex</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;^\\d&#123;3&#125;-\\d&#123;2&#125;-\\d&#123;4&#125;$&quot;</span>; <span class="hljs-comment">// 社会安全号码（SSN）格式</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">input</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;123-45-6789&quot;</span>;<br>        <br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">matches</span> <span class="hljs-operator">=</span> Pattern.matches(regex, input);<br>        System.out.println(<span class="hljs-string">&quot;匹配结果: &quot;</span> + matches);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>解释</strong>：这个正则表达式检查是否为一个有效的社会安全号码格式（例如：<code>123-45-6789</code>）。<code>^</code> 表示字符串开始，<code>\d&#123;3&#125;</code> 表示三位数字，<code>-</code> 匹配一个连字符，<code>\d&#123;2&#125;</code> 表示两位数字，最后的 <code>\d&#123;4&#125;</code> 表示四位数字，<code>$</code> 表示字符串结束。</li></ul><h3 id="2-使用-Pattern-和-Matcher-查找匹配内容"><a href="#2-使用-Pattern-和-Matcher-查找匹配内容" class="headerlink" title="2. 使用 Pattern 和 Matcher 查找匹配内容"></a><strong>2. 使用 <code>Pattern</code> 和 <code>Matcher</code> 查找匹配内容</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.regex.Matcher;<br><span class="hljs-keyword">import</span> java.util.regex.Pattern;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RegexExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">regex</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;\\b\\w+\\b&quot;</span>; <span class="hljs-comment">// 匹配单词</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">input</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello, how are you?&quot;</span>;<br><br>        <span class="hljs-type">Pattern</span> <span class="hljs-variable">pattern</span> <span class="hljs-operator">=</span> Pattern.compile(regex);<br>        <span class="hljs-type">Matcher</span> <span class="hljs-variable">matcher</span> <span class="hljs-operator">=</span> pattern.matcher(input);<br><br>        <span class="hljs-keyword">while</span> (matcher.find()) &#123;<br>            System.out.println(<span class="hljs-string">&quot;找到单词: &quot;</span> + matcher.group());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>解释</strong>：这个正则表达式匹配字符串中的每个单词（由字母、数字或下划线组成）。<code>\\b</code> 是单词边界，<code>\\w+</code> 匹配一个或多个字母、数字或下划线。</li></ul><h3 id="3-替换匹配的部分"><a href="#3-替换匹配的部分" class="headerlink" title="3. 替换匹配的部分"></a><strong>3. 替换匹配的部分</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.regex.Matcher;<br><span class="hljs-keyword">import</span> java.util.regex.Pattern;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RegexExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">regex</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;\\d+&quot;</span>;  <span class="hljs-comment">// 匹配数字</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">input</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;I have 2 apples and 10 oranges.&quot;</span>;<br><br>        <span class="hljs-type">Pattern</span> <span class="hljs-variable">pattern</span> <span class="hljs-operator">=</span> Pattern.compile(regex);<br>        <span class="hljs-type">Matcher</span> <span class="hljs-variable">matcher</span> <span class="hljs-operator">=</span> pattern.matcher(input);<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> matcher.replaceAll(<span class="hljs-string">&quot;many&quot;</span>);  <span class="hljs-comment">// 替换数字为 &quot;many&quot;</span><br>        System.out.println(<span class="hljs-string">&quot;替换后的字符串: &quot;</span> + result);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>解释</strong>：在这个示例中，正则表达式 <code>\\d+</code> 匹配字符串中的所有数字，并将其替换为 <code>&quot;many&quot;</code>。</li></ul><hr><h2 id="✅-总结"><a href="#✅-总结" class="headerlink" title="✅ 总结"></a>✅ <strong>总结</strong></h2><p>正则表达式是一个强大且灵活的工具，在处理字符串匹配、替换和验证时非常有用。Java 提供了 <code>Pattern</code> 和 <code>Matcher</code> 类来实现正则表达式的匹配操作。通过掌握常见的正则语法和 Java 中的操作方法，你可以更加高效地处理字符串相关的任务。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LocalDate</title>
      <link href="/2025/03/27/javaBasics/1.7%20LocalDate/"/>
      <url>/2025/03/27/javaBasics/1.7%20LocalDate/</url>
      
        <content type="html"><![CDATA[<p>在 Java 中，<code>LocalDate</code> 是 <code>java.time</code> 包中的一个类，表示<strong>不带时区的日期</strong>（年、月、日）。它是 Java 8 引入的 <code>java.time</code> API 的一部分，用于替代 <code>java.util.Date</code> 和 <code>java.util.Calendar</code>。  </p><hr><h2 id="✅1-创建-LocalDate"><a href="#✅1-创建-LocalDate" class="headerlink" title="✅1. 创建 LocalDate"></a><strong>✅1. 创建 LocalDate</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.time.LocalDate;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 获取当前日期</span><br>        <span class="hljs-type">LocalDate</span> <span class="hljs-variable">today</span> <span class="hljs-operator">=</span> LocalDate.now();<br>        System.out.println(<span class="hljs-string">&quot;今天的日期: &quot;</span> + today);<br><br>        <span class="hljs-comment">// 指定日期 (年, 月, 日)</span><br>        <span class="hljs-type">LocalDate</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> LocalDate.of(<span class="hljs-number">2025</span>, <span class="hljs-number">3</span>, <span class="hljs-number">28</span>);<br>        System.out.println(<span class="hljs-string">&quot;指定日期: &quot;</span> + date);<br><br>        <span class="hljs-comment">// 解析字符串</span><br>        <span class="hljs-type">LocalDate</span> <span class="hljs-variable">parsedDate</span> <span class="hljs-operator">=</span> LocalDate.parse(<span class="hljs-string">&quot;2025-03-28&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;解析的日期: &quot;</span> + parsedDate);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="✅2-获取日期信息"><a href="#✅2-获取日期信息" class="headerlink" title="✅2. 获取日期信息"></a><strong>✅2. 获取日期信息</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">LocalDate</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> LocalDate.of(<span class="hljs-number">2025</span>, <span class="hljs-number">3</span>, <span class="hljs-number">28</span>);<br>System.out.println(<span class="hljs-string">&quot;年份: &quot;</span> + date.getYear());<br>System.out.println(<span class="hljs-string">&quot;月份: &quot;</span> + date.getMonth());  <span class="hljs-comment">// MARCH</span><br>System.out.println(<span class="hljs-string">&quot;月份值: &quot;</span> + date.getMonthValue()); <span class="hljs-comment">// 3</span><br>System.out.println(<span class="hljs-string">&quot;日: &quot;</span> + date.getDayOfMonth());<br>System.out.println(<span class="hljs-string">&quot;星期: &quot;</span> + date.getDayOfWeek());  <span class="hljs-comment">// FRIDAY</span><br>System.out.println(<span class="hljs-string">&quot;是否闰年: &quot;</span> + date.isLeapYear());  <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><hr><h2 id="✅3-日期计算"><a href="#✅3-日期计算" class="headerlink" title="✅3. 日期计算"></a><strong>✅3. 日期计算</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">LocalDate</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> LocalDate.of(<span class="hljs-number">2025</span>, <span class="hljs-number">3</span>, <span class="hljs-number">28</span>);<br><br><span class="hljs-comment">// 加/减天数、月数、年数</span><br><span class="hljs-type">LocalDate</span> <span class="hljs-variable">plusDays</span> <span class="hljs-operator">=</span> date.plusDays(<span class="hljs-number">5</span>);<br><span class="hljs-type">LocalDate</span> <span class="hljs-variable">minusMonths</span> <span class="hljs-operator">=</span> date.minusMonths(<span class="hljs-number">2</span>);<br><br>System.out.println(<span class="hljs-string">&quot;加5天: &quot;</span> + plusDays);<br>System.out.println(<span class="hljs-string">&quot;减2个月: &quot;</span> + minusMonths);<br><br><span class="hljs-comment">// 计算两个日期之间的天数</span><br><span class="hljs-type">LocalDate</span> <span class="hljs-variable">anotherDate</span> <span class="hljs-operator">=</span> LocalDate.of(<span class="hljs-number">2025</span>, <span class="hljs-number">4</span>, <span class="hljs-number">10</span>);<br><span class="hljs-type">long</span> <span class="hljs-variable">daysBetween</span> <span class="hljs-operator">=</span> java.time.temporal.ChronoUnit.DAYS.between(date, anotherDate);<br>System.out.println(<span class="hljs-string">&quot;两日期相差天数: &quot;</span> + daysBetween);<br></code></pre></td></tr></table></figure><hr><h2 id="✅4-日期比较"><a href="#✅4-日期比较" class="headerlink" title="✅4. 日期比较"></a><strong>✅4. 日期比较</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">LocalDate</span> <span class="hljs-variable">date1</span> <span class="hljs-operator">=</span> LocalDate.of(<span class="hljs-number">2025</span>, <span class="hljs-number">3</span>, <span class="hljs-number">28</span>);<br><span class="hljs-type">LocalDate</span> <span class="hljs-variable">date2</span> <span class="hljs-operator">=</span> LocalDate.of(<span class="hljs-number">2025</span>, <span class="hljs-number">4</span>, <span class="hljs-number">10</span>);<br><br>System.out.println(date1.isBefore(date2)); <span class="hljs-comment">// true</span><br>System.out.println(date1.isAfter(date2));  <span class="hljs-comment">// false</span><br>System.out.println(date1.equals(date2));   <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><hr><h2 id="✅5-获取本月第一天和最后一天"><a href="#✅5-获取本月第一天和最后一天" class="headerlink" title="✅5. 获取本月第一天和最后一天"></a><strong>✅5. 获取本月第一天和最后一天</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">LocalDate</span> <span class="hljs-variable">today</span> <span class="hljs-operator">=</span> LocalDate.now();<br><span class="hljs-type">LocalDate</span> <span class="hljs-variable">firstDay</span> <span class="hljs-operator">=</span> today.withDayOfMonth(<span class="hljs-number">1</span>);<br><span class="hljs-type">LocalDate</span> <span class="hljs-variable">lastDay</span> <span class="hljs-operator">=</span> today.withDayOfMonth(today.lengthOfMonth());<br><br>System.out.println(<span class="hljs-string">&quot;本月第一天: &quot;</span> + firstDay);<br>System.out.println(<span class="hljs-string">&quot;本月最后一天: &quot;</span> + lastDay);<br></code></pre></td></tr></table></figure><hr><h3 id="✅总结"><a href="#✅总结" class="headerlink" title="✅总结"></a><strong>✅总结</strong></h3><ul><li><code>LocalDate</code> <strong>不包含时间</strong>，只表示日期（年月日）。</li><li><strong>不可变对象</strong>，所有修改都会返回一个新实例。</li><li>使用 <code>now()</code> 获取当前日期，<code>of()</code> 创建指定日期，<code>parse()</code> 解析字符串。</li><li>提供日期计算、比较等操作。</li></ul><p>如果你需要<strong>时间</strong>，可以使用 <code>LocalDateTime</code> 或 <code>ZonedDateTime</code>。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>泛型</title>
      <link href="/2025/03/27/javaBasics/1.6%20%E6%B3%9B%E5%9E%8B/"/>
      <url>/2025/03/27/javaBasics/1.6%20%E6%B3%9B%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>在 <strong>Java</strong> 中，<strong>泛型（Generics）</strong> 是一种提供<strong>类型安全</strong>和<strong>代码复用</strong>的机制。它允许你在类、接口和方法中定义类型参数，从而编写更加通用和灵活的代码。</p><hr><h2 id="✅-1-为什么需要泛型？"><a href="#✅-1-为什么需要泛型？" class="headerlink" title="✅ 1. 为什么需要泛型？"></a>✅ <strong>1. 为什么需要泛型？</strong></h2><p>在 Java 5 之前，集合类（如 <code>ArrayList</code>）只能存储 <code>Object</code> 类型，这导致了以下问题：  </p><ul><li><strong>类型不安全</strong>：需要强制类型转换，容易出现 <code>ClassCastException</code>。  </li><li><strong>代码不清晰</strong>：无法明确知道集合中存储的具体数据类型。</li></ul><p><strong>没有泛型的代码示例：</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ArrayList</span> <span class="hljs-variable">list</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>(); <span class="hljs-comment">// 使用Object存储</span><br>        list.add(<span class="hljs-string">&quot;Hello&quot;</span>);<br>        list.add(<span class="hljs-number">123</span>); <span class="hljs-comment">// 不同类型的数据</span><br><br>        <span class="hljs-comment">// 需要强制类型转换</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> (String) list.get(<span class="hljs-number">0</span>);<br>        System.out.println(str);<br><br>        <span class="hljs-comment">// 类型转换错误会抛出异常</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> (String) list.get(<span class="hljs-number">1</span>); <span class="hljs-comment">// ClassCastException</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>解决方法：使用泛型</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>list.add(<span class="hljs-string">&quot;Hello&quot;</span>);<br><span class="hljs-comment">// list.add(123); // 编译时报错，避免类型错误</span><br><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> list.get(<span class="hljs-number">0</span>); <span class="hljs-comment">// 不需要强制类型转换</span><br></code></pre></td></tr></table></figure><hr><h2 id="✅-2-泛型的基本语法"><a href="#✅-2-泛型的基本语法" class="headerlink" title="✅ 2. 泛型的基本语法"></a>✅ <strong>2. 泛型的基本语法</strong></h2><p><strong>定义泛型类</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Box</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">private</span> T content;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setContent</span><span class="hljs-params">(T content)</span> &#123;<br>        <span class="hljs-built_in">this</span>.content = content;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getContent</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> content;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Box&lt;String&gt; stringBox = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Box</span>&lt;&gt;();<br>        stringBox.setContent(<span class="hljs-string">&quot;泛型示例&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;内容: &quot;</span> + stringBox.getContent());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>解释：</strong>  </p><ul><li><code>&lt;T&gt;</code>：表示泛型类型，<code>T</code> 是一个占位符，可以用任意字母代替。  </li><li><code>Box&lt;String&gt;</code>：指定泛型类型为 <code>String</code>，确保类型安全。</li></ul><hr><h2 id="✅-3-泛型方法"><a href="#✅-3-泛型方法" class="headerlink" title="✅ 3. 泛型方法"></a>✅ <strong>3. 泛型方法</strong></h2><p>泛型不仅可以用于类，还可以用于方法。  </p><p><strong>泛型方法示例：</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br><br>    <span class="hljs-comment">// 定义一个泛型方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">printArray</span><span class="hljs-params">(T[] array)</span> &#123;<br>        <span class="hljs-keyword">for</span> (T element : array) &#123;<br>            System.out.print(element + <span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br>        System.out.println();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Integer[] intArray = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>        String[] strArray = &#123;<span class="hljs-string">&quot;Java&quot;</span>, <span class="hljs-string">&quot;Python&quot;</span>, <span class="hljs-string">&quot;C++&quot;</span>&#125;;<br><br>        printArray(intArray);<br>        printArray(strArray);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>解释：</strong>  </p><ul><li><code>&lt;T&gt;</code>：在方法返回类型之前声明。  </li><li><code>T[] array</code>：泛型数组参数。  </li><li>方法可以接受任意类型的数组。</li></ul><hr><h2 id="✅-4-泛型的类型边界"><a href="#✅-4-泛型的类型边界" class="headerlink" title="✅ 4. 泛型的类型边界"></a>✅ <strong>4. 泛型的类型边界</strong></h2><p>有时候我们需要对泛型的类型进行限制，Java 提供了两种方式：  </p><h3 id="1-上界通配符："><a href="#1-上界通配符：" class="headerlink" title="(1) 上界通配符： &lt;? extends T&gt;"></a><strong>(1) 上界通配符： <code>&lt;? extends T&gt;</code></strong></h3><ul><li>适用于读取数据。  </li><li>表示类型必须是 <code>T</code> 或 <code>T</code> 的子类。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printNumbers</span><span class="hljs-params">(List&lt;? extends Number&gt; list)</span> &#123;<br>        <span class="hljs-keyword">for</span> (Number num : list) &#123;<br>            System.out.println(num);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;Integer&gt; intList = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br>        List&lt;Double&gt; doubleList = Arrays.asList(<span class="hljs-number">1.1</span>, <span class="hljs-number">2.2</span>, <span class="hljs-number">3.3</span>);<br><br>        printNumbers(intList);<br>        printNumbers(doubleList);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-下界通配符："><a href="#2-下界通配符：" class="headerlink" title="(2) 下界通配符： &lt;? super T&gt;"></a><strong>(2) 下界通配符： <code>&lt;? super T&gt;</code></strong></h3><ul><li>适用于写入数据。  </li><li>表示类型必须是 <code>T</code> 或 <code>T</code> 的父类。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addNumbers</span><span class="hljs-params">(List&lt;? <span class="hljs-built_in">super</span> Integer&gt; list)</span> &#123;<br>        list.add(<span class="hljs-number">100</span>);<br>        list.add(<span class="hljs-number">200</span>);<br>        System.out.println(list);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;Number&gt; numberList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        addNumbers(numberList);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="✅-5-泛型中的通配符"><a href="#✅-5-泛型中的通配符" class="headerlink" title="✅ 5. 泛型中的通配符 &lt;?&gt;"></a>✅ <strong>5. 泛型中的通配符 <code>&lt;?&gt;</code></strong></h2><ul><li><code>&lt;?&gt;</code> 表示<strong>未知类型</strong>，称为<strong>通配符</strong>。  </li><li>常用于方法参数中，表示可以接受任何类型的集合。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printList</span><span class="hljs-params">(List&lt;?&gt; list)</span> &#123;<br>        <span class="hljs-keyword">for</span> (Object obj : list) &#123;<br>            System.out.println(obj);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;String&gt; strList = Arrays.asList(<span class="hljs-string">&quot;Java&quot;</span>, <span class="hljs-string">&quot;Python&quot;</span>);<br>        List&lt;Integer&gt; intList = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br><br>        printList(strList);<br>        printList(intList);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="✅-6-泛型的限制"><a href="#✅-6-泛型的限制" class="headerlink" title="✅ 6. 泛型的限制"></a>✅ <strong>6. 泛型的限制</strong></h2><ol><li><p><strong>基本数据类型不能作为泛型类型</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;<span class="hljs-type">int</span>&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(); <span class="hljs-comment">// 错误</span><br></code></pre></td></tr></table></figure><p><strong>解决方法：</strong> 使用包装类 <code>Integer</code> 替代 <code>int</code>：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br></code></pre></td></tr></table></figure></li><li><p><strong>不能创建泛型数组</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">T[] array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">T</span>[<span class="hljs-number">10</span>]; <span class="hljs-comment">// 错误</span><br></code></pre></td></tr></table></figure><p><strong>解决方法：</strong> 使用 <code>Object</code> 数组并强制转换：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>T[] array = (T[]) <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[<span class="hljs-number">10</span>];<br></code></pre></td></tr></table></figure></li></ol><hr><h2 id="✅-总结"><a href="#✅-总结" class="headerlink" title="✅ 总结"></a>✅ <strong>总结</strong></h2><ul><li><strong>泛型类</strong>：使用 <code>&lt;T&gt;</code> 声明通用类型，使类可以操作不同的数据类型。  </li><li><strong>泛型方法</strong>：在方法中使用 <code>&lt;T&gt;</code> 使其支持不同类型的参数。  </li><li><strong>通配符 <code>&lt;?&gt;</code></strong>：表示未知类型，用于通用代码。  </li><li><strong>上界 <code>&lt;? extends T&gt;</code></strong>：用于读取数据。  </li><li><strong>下界 <code>&lt;? super T&gt;</code></strong>：用于写入数据。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>异常</title>
      <link href="/2025/03/27/javaBasics/1.5%20%E5%BC%82%E5%B8%B8/"/>
      <url>/2025/03/27/javaBasics/1.5%20%E5%BC%82%E5%B8%B8/</url>
      
        <content type="html"><![CDATA[<p>在 <strong>Java</strong> 中，<strong>异常（Exception）</strong> 是指程序在运行过程中发生的错误或意外情况。异常机制提供了一种优雅的方式来处理这些错误，避免程序崩溃。</p><hr><h2 id="✅-1-异常的分类"><a href="#✅-1-异常的分类" class="headerlink" title="✅ 1. 异常的分类"></a>✅ <strong>1. 异常的分类</strong></h2><p>Java 中的异常分为两大类：  </p><h3 id="1-Checked-Exception（受检异常）"><a href="#1-Checked-Exception（受检异常）" class="headerlink" title="(1) Checked Exception（受检异常）"></a><strong>(1) Checked Exception（受检异常）</strong></h3><ul><li>编译期异常，必须处理，否则代码无法编译。  </li><li>例如：<code>IOException</code>、<code>SQLException</code>、<code>FileNotFoundException</code> 等。  </li><li>需要用 <code>try-catch</code> 或 <code>throws</code> 处理。</li></ul><h3 id="2-Unchecked-Exception（非受检异常）"><a href="#2-Unchecked-Exception（非受检异常）" class="headerlink" title="(2) Unchecked Exception（非受检异常）"></a><strong>(2) Unchecked Exception（非受检异常）</strong></h3><ul><li>运行时异常，在程序运行时抛出。  </li><li>例如：<code>NullPointerException</code>、<code>ArrayIndexOutOfBoundsException</code> 等。  </li><li>可以不强制处理，但建议通过代码逻辑避免。</li></ul><hr><h2 id="✅-2-异常的基本语法"><a href="#✅-2-异常的基本语法" class="headerlink" title="✅ 2. 异常的基本语法"></a>✅ <strong>2. 异常的基本语法</strong></h2><h3 id="1-使用-try-catch-处理异常"><a href="#1-使用-try-catch-处理异常" class="headerlink" title="(1) 使用 try-catch 处理异常"></a><strong>(1) 使用 try-catch 处理异常</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span> / <span class="hljs-number">0</span>; <span class="hljs-comment">// 会抛出异常</span><br>        &#125; <span class="hljs-keyword">catch</span> (ArithmeticException e) &#123;<br>            System.out.println(<span class="hljs-string">&quot;捕获异常: &quot;</span> + e.getMessage());<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;执行 finally 语句，无论是否异常都会执行&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>说明：</strong>  </p><ul><li><code>try</code>：放置可能发生异常的代码。  </li><li><code>catch</code>：捕获异常并处理。  </li><li><code>finally</code>：可选，通常用于释放资源。</li></ul><hr><h3 id="2-使用-throws-声明异常"><a href="#2-使用-throws-声明异常" class="headerlink" title="(2) 使用 throws 声明异常"></a><strong>(2) 使用 throws 声明异常</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.File;<br><span class="hljs-keyword">import</span> java.io.FileNotFoundException;<br><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">readFile</span><span class="hljs-params">(String filePath)</span> <span class="hljs-keyword">throws</span> FileNotFoundException &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(filePath));<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            readFile(<span class="hljs-string">&quot;test.txt&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (FileNotFoundException e) &#123;<br>            System.out.println(<span class="hljs-string">&quot;文件未找到: &quot;</span> + e.getMessage());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>说明：</strong>  </p><ul><li><code>throws</code> 用于声明可能抛出的异常。  </li><li>调用方法时，需要使用 <code>try-catch</code> 处理异常。</li></ul><hr><h2 id="✅-3-多异常捕获"><a href="#✅-3-多异常捕获" class="headerlink" title="✅ 3. 多异常捕获"></a>✅ <strong>3. 多异常捕获</strong></h2><p>当可能抛出多种异常时，可以使用多 <code>catch</code> 语句：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>            System.out.println(arr[<span class="hljs-number">5</span>]); <span class="hljs-comment">// 数组越界异常</span><br>        &#125; <span class="hljs-keyword">catch</span> (ArithmeticException e) &#123;<br>            System.out.println(<span class="hljs-string">&quot;算术异常: &quot;</span> + e.getMessage());<br>        &#125; <span class="hljs-keyword">catch</span> (ArrayIndexOutOfBoundsException e) &#123;<br>            System.out.println(<span class="hljs-string">&quot;数组越界异常: &quot;</span> + e.getMessage());<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            System.out.println(<span class="hljs-string">&quot;其他异常: &quot;</span> + e.getMessage());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>说明：</strong>  </p><ul><li>异常应从<strong>具体异常</strong>到<strong>父类异常</strong>依次捕获，避免父类异常拦截所有异常。  </li><li><code>Exception</code> 是所有异常的父类。</li></ul><hr><h2 id="✅-4-自定义异常"><a href="#✅-4-自定义异常" class="headerlink" title="✅ 4. 自定义异常"></a>✅ <strong>4. 自定义异常</strong></h2><p>你可以通过继承 <code>Exception</code> 或 <code>RuntimeException</code> 来创建自定义异常。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 自定义异常类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Exception</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CustomException</span><span class="hljs-params">(String message)</span> &#123;<br>        <span class="hljs-built_in">super</span>(message);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkNumber</span><span class="hljs-params">(<span class="hljs-type">int</span> number)</span> <span class="hljs-keyword">throws</span> CustomException &#123;<br>        <span class="hljs-keyword">if</span> (number &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CustomException</span>(<span class="hljs-string">&quot;数字不能为负数: &quot;</span> + number);<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;数字是: &quot;</span> + number);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            checkNumber(-<span class="hljs-number">5</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (CustomException e) &#123;<br>            System.out.println(<span class="hljs-string">&quot;捕获异常: &quot;</span> + e.getMessage());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>说明：</strong>  </p><ul><li>自定义异常通常用于业务逻辑层中进行异常处理。  </li><li>使用 <code>throw</code> 关键字主动抛出异常。</li></ul><hr><h2 id="✅-5-常见异常类型"><a href="#✅-5-常见异常类型" class="headerlink" title="✅ 5. 常见异常类型"></a>✅ <strong>5. 常见异常类型</strong></h2><table><thead><tr><th><strong>异常类型</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><code>NullPointerException</code></td><td>访问空对象的属性或方法</td></tr><tr><td><code>ArrayIndexOutOfBoundsException</code></td><td>数组索引越界</td></tr><tr><td><code>ArithmeticException</code></td><td>算术运算异常，如除以 0</td></tr><tr><td><code>NumberFormatException</code></td><td>字符串转数字失败</td></tr><tr><td><code>IOException</code></td><td>输入输出异常</td></tr><tr><td><code>FileNotFoundException</code></td><td>文件未找到异常</td></tr><tr><td><code>ClassNotFoundException</code></td><td>找不到指定的类</td></tr></tbody></table><hr><h2 id="✅-总结"><a href="#✅-总结" class="headerlink" title="✅ 总结"></a>✅ <strong>总结</strong></h2><ul><li>使用 <code>try-catch</code> 捕获异常，避免程序崩溃。  </li><li>使用 <code>finally</code> 释放资源。  </li><li>使用 <code>throws</code> 声明异常，让调用者处理。  </li><li>自定义异常可用于业务逻辑校验。  </li><li>合理处理异常，有助于提高程序的健壮性和可维护性。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>抽象类与接口</title>
      <link href="/2025/03/27/javaBasics/1.4%20%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3/"/>
      <url>/2025/03/27/javaBasics/1.4%20%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<ul><li><p>在面向对象编程（OOP）中，<strong>抽象类（Abstract Class）</strong> 和 <strong>接口（Interface）</strong> 是两种定义类的方式，它们都可以用于定义规范，但它们有一些重要的区别。</p><hr><h2 id="1-抽象类（Abstract-Class）"><a href="#1-抽象类（Abstract-Class）" class="headerlink" title="1. 抽象类（Abstract Class）"></a><strong>1. 抽象类（Abstract Class）</strong></h2><p><strong>定义</strong>：</p><ul><li>抽象类是不能被实例化的类，通常包含至少一个<strong>抽象方法</strong>（没有方法体的函数）。</li><li>主要用于提供基本实现，并允许子类继承。</li><li>既可以包含普通方法（有方法体），也可以包含抽象方法（只有方法声明，没有方法体）。</li></ul><p><strong>特点</strong>：</p><ol><li><strong>不能实例化</strong>，只能被继承。</li><li>可以包含<strong>普通方法</strong>和<strong>抽象方法</strong>。</li><li><strong>可以</strong>有成员变量（字段），可以定义构造函数。</li><li><strong>可以</strong>有访问修饰符（public、protected、private）。</li></ol><p><strong>示例（Java）：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">abstract class Animal &#123;<br>    String name;<br><br>    // 构造方法<br>    Animal(String name) &#123;<br>        this.name = name;<br>    &#125;<br><br>    // 具体方法<br>    void eat() &#123;<br>        System.out.println(name + &quot; is eating.&quot;);<br>    &#125;<br><br>    // 抽象方法（子类必须实现）<br>    abstract void makeSound();<br>&#125;<br><br>class Dog extends Animal &#123;<br>    Dog(String name) &#123;<br>        super(name);<br>    &#125;<br><br>    @Override<br>    void makeSound() &#123;<br>        System.out.println(&quot;Woof Woof!&quot;);<br>    &#125;<br>&#125;<br><br>public class Main &#123;<br>    public static void main(String[] args) &#123;<br>        Dog dog = new Dog(&quot;Buddy&quot;);<br>        dog.eat();      // 继承的普通方法<br>        dog.makeSound(); // 实现的抽象方法<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="2-接口（Interface）"><a href="#2-接口（Interface）" class="headerlink" title="2. 接口（Interface）"></a><strong>2. 接口（Interface）</strong></h2><p><strong>定义</strong>：</p><ul><li>接口是一个完全抽象的类，所有方法<strong>默认都是抽象的</strong>（Java 8 之后支持默认方法）。</li><li>主要用于定义行为规范，而<strong>不提供实现</strong>，由实现接口的类提供具体实现。</li></ul><p><strong>特点</strong>：</p><ol><li><strong>不能实例化</strong>，只能被类实现（<code>implements</code>）。</li><li><strong>所有方法默认是 <code>public abstract</code></strong>（即使不写 <code>public abstract</code> 关键字）。</li><li><strong>不能</strong>包含普通方法（Java 8 之后可以有默认方法 <code>default</code>）。</li><li><strong>不能</strong>有成员变量，但可以有 <code>public static final</code> 常量。</li><li><strong>一个类可以实现多个接口</strong>（支持多继承）。</li></ol><p><strong>示例（Java）：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">interface Animal &#123;<br>    // 默认是 public abstract<br>    void makeSound();<br>&#125;<br><br>// 接口实现<br>class Cat implements Animal &#123;<br>    @Override<br>    public void makeSound() &#123;<br>        System.out.println(&quot;Meow Meow!&quot;);<br>    &#125;<br>&#125;<br><br>public class Main &#123;<br>    public static void main(String[] args) &#123;<br>        Cat cat = new Cat();<br>        cat.makeSound();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="3-主要区别"><a href="#3-主要区别" class="headerlink" title="3. 主要区别"></a><strong>3. 主要区别</strong></h2><table><thead><tr><th><strong>对比项</strong></th><th><strong>抽象类</strong></th><th><strong>接口</strong></th></tr></thead><tbody><tr><td><strong>实例化</strong></td><td>不能被实例化</td><td>不能被实例化</td></tr><tr><td><strong>方法</strong></td><td>可以有普通方法和抽象方法</td><td>只能有抽象方法（Java 8+ 允许默认方法）</td></tr><tr><td><strong>成员变量</strong></td><td>可以有变量（实例变量、静态变量）</td><td>只能有 <code>public static final</code> 常量</td></tr><tr><td><strong>构造函数</strong></td><td>可以有构造函数</td><td>不能有构造函数</td></tr><tr><td><strong>继承关系</strong></td><td>只能单继承（<code>extends</code>）</td><td>可以多实现（<code>implements</code>）</td></tr><tr><td><strong>使用场景</strong></td><td>用于<strong>共享代码</strong>和定义行为</td><td>用于<strong>定义规范</strong>，让不同类实现相同行为</td></tr></tbody></table><hr><h2 id="4-什么时候用？"><a href="#4-什么时候用？" class="headerlink" title="4. 什么时候用？"></a><strong>4. 什么时候用？</strong></h2><p>✅ <strong>用抽象类</strong>：</p><ul><li>当多个类有<strong>共同的部分实现</strong>（代码复用），但仍然需要在子类中提供具体实现时。</li><li>当希望<strong>限制继承</strong>，只允许单一继承时。</li></ul><p>✅ <strong>用接口</strong>：</p><ul><li>当需要<strong>多个类具有相同行为</strong>，但它们本身可能没有共同的父类。</li><li>当需要<strong>多继承</strong>时（Java 不支持类的多继承，但支持接口的多实现）。</li><li>当需要定义一个<strong>严格的行为规范</strong>时。</li></ul><hr><h3 id="5-结合使用"><a href="#5-结合使用" class="headerlink" title="5. 结合使用"></a><strong>5. 结合使用</strong></h3><p>有时候，可以结合 <strong>抽象类</strong> 和 <strong>接口</strong>，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">interface Flyable &#123;<br>    void fly();<br>&#125;<br><br>abstract class Bird &#123;<br>    void eat() &#123;<br>        System.out.println(&quot;Bird is eating.&quot;);<br>    &#125;<br><br>    abstract void makeSound();<br>&#125;<br><br>// 继承抽象类 &amp; 实现接口<br>class Sparrow extends Bird implements Flyable &#123;<br>    @Override<br>    void makeSound() &#123;<br>        System.out.println(&quot;Chirp Chirp!&quot;);<br>    &#125;<br><br>    @Override<br>    public void fly() &#123;<br>        System.out.println(&quot;Sparrow is flying.&quot;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里 <code>Sparrow</code> 继承 <code>Bird</code>（因为所有鸟都可以吃东西），但也实现了 <code>Flyable</code> 接口，因为不是所有鸟都会飞（如企鹅）。</p><hr><h2 id="6-结论"><a href="#6-结论" class="headerlink" title="6. 结论"></a><strong>6. 结论</strong></h2><ul><li><strong>抽象类</strong> 适用于<strong>父类提供部分实现</strong>，子类扩展功能的情况。</li><li><strong>接口</strong> 适用于<strong>定义行为规范</strong>，让多个不相关的类实现相同方法的情况。</li><li><strong>接口比抽象类更灵活</strong>，因为它允许<strong>多实现</strong>。</li></ul><p>💡 <strong>记住</strong>：如果是**“是什么”<strong>（继承关系），用</strong>抽象类**；如果是**“能做什么”<strong>（行为规范），用</strong>接口**。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>枚举类</title>
      <link href="/2025/03/27/javaBasics/1.3%20%E6%9E%9A%E4%B8%BE%E7%B1%BB/"/>
      <url>/2025/03/27/javaBasics/1.3%20%E6%9E%9A%E4%B8%BE%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="枚举类（Enum）"><a href="#枚举类（Enum）" class="headerlink" title="枚举类（Enum）"></a><strong>枚举类（Enum）</strong></h2><h3 id="1-什么是枚举类？"><a href="#1-什么是枚举类？" class="headerlink" title="1. 什么是枚举类？"></a><strong>1. 什么是枚举类？</strong></h3><p>枚举（<code>enum</code>）是一种特殊的类，表示一组固定的常量。它在 Java、C++、Python 等编程语言中广泛应用，通常用于定义状态、类型、方向等不可变值。</p><hr><h3 id="2-Java-枚举的基本使用"><a href="#2-Java-枚举的基本使用" class="headerlink" title="2. Java 枚举的基本使用"></a><strong>2. Java 枚举的基本使用</strong></h3><p>Java 枚举使用 <code>enum</code> 关键字定义，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">public enum Color &#123;<br>    RED, GREEN, BLUE;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>特点</strong>：</p><ul><li><code>enum</code> 实际上是一个类，继承自 <code>java.lang.Enum</code>。</li><li>枚举的实例是<strong>固定的、有限的</strong>，不能通过 <code>new</code> 创建新实例。</li><li>每个枚举值本质上是 <code>Color</code> 类的一个静态实例。</li></ul><p><strong>使用示例</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">Color c = Color.RED;<br>System.out.println(c); // 输出：RED<br></code></pre></td></tr></table></figure><hr><h3 id="3-枚举类的常见用法"><a href="#3-枚举类的常见用法" class="headerlink" title="3. 枚举类的常见用法"></a><strong>3. 枚举类的常见用法</strong></h3><h4 id="（1）枚举类中定义属性和方法"><a href="#（1）枚举类中定义属性和方法" class="headerlink" title="（1）枚举类中定义属性和方法"></a><strong>（1）枚举类中定义属性和方法</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">public enum Status &#123;<br>    SUCCESS(200, &quot;OK&quot;),<br>    ERROR(500, &quot;Server Error&quot;),<br>    NOT_FOUND(404, &quot;Not Found&quot;);<br><br>    private final int code;<br>    private final String message;<br><br>    // 构造方法（必须是 private）<br>    private Status(int code, String message) &#123;<br>        this.code = code;<br>        this.message = message;<br>    &#125;<br><br>    public int getCode() &#123;<br>        return code;<br>    &#125;<br><br>    public String getMessage() &#123;<br>        return message;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>使用：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">System.out.println(Status.SUCCESS.getCode());    // 输出：200<br>System.out.println(Status.SUCCESS.getMessage()); // 输出：&quot;OK&quot;<br></code></pre></td></tr></table></figure><hr><h4 id="（2）枚举类中的抽象方法"><a href="#（2）枚举类中的抽象方法" class="headerlink" title="（2）枚举类中的抽象方法"></a><strong>（2）枚举类中的抽象方法</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">public enum Operation &#123;<br>    ADD &#123;<br>        @Override<br>        public int apply(int a, int b) &#123;<br>            return a + b;<br>        &#125;<br>    &#125;,<br>    SUBTRACT &#123;<br>        @Override<br>        public int apply(int a, int b) &#123;<br>            return a - b;<br>        &#125;<br>    &#125;;<br><br>    public abstract int apply(int a, int b);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>使用：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">int result = Operation.ADD.apply(5, 3); // 5 + 3 = 8<br>System.out.println(result);<br></code></pre></td></tr></table></figure><hr><h4 id="（3）遍历枚举值"><a href="#（3）遍历枚举值" class="headerlink" title="（3）遍历枚举值"></a><strong>（3）遍历枚举值</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">(Color c : Color.values()) &#123;<br>    System.out.println(c);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">RED<br>GREEN<br>BLUE<br></code></pre></td></tr></table></figure><hr><h4 id="（4）枚举类的-valueOf-方法"><a href="#（4）枚举类的-valueOf-方法" class="headerlink" title="（4）枚举类的 valueOf 方法"></a><strong>（4）枚举类的 <code>valueOf</code> 方法</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">Color c = Color.valueOf(&quot;RED&quot;);<br>System.out.println(c); // 输出：RED<br></code></pre></td></tr></table></figure><ul><li><code>valueOf(&quot;RED&quot;)</code> 必须匹配 <code>enum</code> 中的名称（区分大小写）。</li><li>如果传入 <code>&quot;red&quot;</code>，会抛出 <code>IllegalArgumentException</code>。</li></ul><hr><h3 id="4-枚举实现单例模式（推荐）"><a href="#4-枚举实现单例模式（推荐）" class="headerlink" title="4. 枚举实现单例模式（推荐）"></a><strong>4. 枚举实现单例模式（推荐）</strong></h3><p>枚举是实现单例模式的最佳方式，<strong>线程安全</strong>、<strong>防止反射破坏</strong>、<strong>防止序列化破坏</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">public enum Singleton &#123;<br>    INSTANCE;<br><br>    public void doSomething() &#123;<br>        System.out.println(&quot;Hello, Singleton!&quot;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>使用：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">Singleton.INSTANCE.doSomething();<br></code></pre></td></tr></table></figure><hr><h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a><strong>5. 总结</strong></h3><table><thead><tr><th>特性</th><th>描述</th></tr></thead><tbody><tr><td>继承</td><td><code>enum</code> 默认继承 <code>java.lang.Enum</code>，不能再继承其他类</td></tr><tr><td>线程安全</td><td><code>enum</code> 本质上是 <code>final</code>，且实例是静态的，天然线程安全</td></tr><tr><td>构造方法</td><td>必须是 <code>private</code>，外部不能 <code>new</code> 构造</td></tr><tr><td>反射安全</td><td>反射无法创建新的 <code>enum</code> 实例</td></tr><tr><td>序列化安全</td><td><code>enum</code> 反序列化时不会创建新对象，保证单例</td></tr></tbody></table><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a><strong>适用场景</strong></h3><ul><li><strong>定义常量集合</strong>（如 HTTP 状态码、星期、颜色等）</li><li><strong>替代 <code>switch-case</code> 语句中的字符串或整数</strong></li><li><strong>实现策略模式</strong></li><li><strong>单例模式（推荐使用）</strong></li></ul><p>枚举不仅仅是常量的集合，它可以包含方法、构造函数，甚至实现接口，使其更加强大和灵活。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单例类</title>
      <link href="/2025/03/27/javaBasics/1.2%20%E5%8D%95%E4%BE%8B%E7%B1%BB/"/>
      <url>/2025/03/27/javaBasics/1.2%20%E5%8D%95%E4%BE%8B%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="单例类（Singleton）"><a href="#单例类（Singleton）" class="headerlink" title="单例类（Singleton）"></a>单例类（Singleton）</h2><p>单例模式（Singleton Pattern）是一种常见的设计模式，确保一个类在系统中只有一个实例，并提供一个全局访问点。</p><h3 id="单例模式的特点"><a href="#单例模式的特点" class="headerlink" title="单例模式的特点"></a><strong>单例模式的特点</strong></h3><ol><li><strong>唯一性</strong>：整个系统中该类只有一个实例。</li><li><strong>全局访问</strong>：可以在整个程序中访问这个实例。</li><li><strong>延迟初始化（可选）</strong>：只有在真正需要时才创建实例，提高性能。</li></ol><hr><h2 id="单例模式的实现方式"><a href="#单例模式的实现方式" class="headerlink" title="单例模式的实现方式"></a><strong>单例模式的实现方式</strong></h2><h3 id="1-饿汉式（Eager-Singleton）"><a href="#1-饿汉式（Eager-Singleton）" class="headerlink" title="1. 饿汉式（Eager Singleton）"></a><strong>1. 饿汉式（Eager Singleton）</strong></h3><h4 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a><strong>实现方式</strong></h4><ul><li>直接在类加载时创建实例，线程安全。</li><li>缺点是可能会造成资源浪费（如果实例很早创建，但一直未被使用）。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">public class Singleton &#123;<br>    private static final Singleton INSTANCE = new Singleton(); // 直接创建实例<br><br>    private Singleton() &#123;&#125; // 私有构造方法，防止外部创建对象<br><br>    public static Singleton getInstance() &#123;<br>        return INSTANCE;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="2-懒汉式（Lazy-Singleton）"><a href="#2-懒汉式（Lazy-Singleton）" class="headerlink" title="2. 懒汉式（Lazy Singleton）"></a><strong>2. 懒汉式（Lazy Singleton）</strong></h3><h4 id="实现方式-1"><a href="#实现方式-1" class="headerlink" title="实现方式"></a><strong>实现方式</strong></h4><ul><li>只有在第一次调用 <code>getInstance()</code> 时才创建实例，避免资源浪费。</li><li>但<strong>非线程安全</strong>，多个线程可能同时创建多个实例。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">public class Singleton &#123;<br>    private static Singleton instance;<br><br>    private Singleton() &#123;&#125; // 私有构造方法<br><br>    public static Singleton getInstance() &#123;<br>        if (instance == null) &#123; // 只有在需要时才创建实例<br>            instance = new Singleton();<br>        &#125;<br>        return instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>问题</strong>：多线程环境下，可能出现多个实例。</p><hr><h3 id="3-线程安全的懒汉式"><a href="#3-线程安全的懒汉式" class="headerlink" title="3. 线程安全的懒汉式"></a><strong>3. 线程安全的懒汉式</strong></h3><p><strong>方式 1：使用 synchronized</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">public class Singleton &#123;<br>    private static Singleton instance;<br><br>    private Singleton() &#123;&#125;<br><br>    public static synchronized Singleton getInstance() &#123;<br>        if (instance == null) &#123;<br>            instance = new Singleton();<br>        &#125;<br>        return instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>缺点</strong>：<code>synchronized</code> 影响性能，每次访问都需要加锁。</p><hr><p><strong>方式 2：双重检查锁（Double-Check Locking）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">public class Singleton &#123;<br>    private static volatile Singleton instance;<br><br>    private Singleton() &#123;&#125;<br><br>    public static Singleton getInstance() &#123;<br>        if (instance == null) &#123; // 第一次检查<br>            synchronized (Singleton.class) &#123;<br>                if (instance == null) &#123; // 第二次检查<br>                    instance = new Singleton();<br>                &#125;<br>            &#125;<br>        &#125;<br>        return instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong><code>volatile</code> 关键字</strong>：防止指令重排，保证可见性。</li><li><strong>双重检查</strong>：避免不必要的加锁，提高性能。</li></ul><hr><h3 id="4-静态内部类（推荐方式）"><a href="#4-静态内部类（推荐方式）" class="headerlink" title="4. 静态内部类（推荐方式）"></a><strong>4. 静态内部类（推荐方式）</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">public class Singleton &#123;<br>    private Singleton() &#123;&#125;<br><br>    private static class SingletonHolder &#123;<br>        private static final Singleton INSTANCE = new Singleton();<br>    &#125;<br><br>    public static Singleton getInstance() &#123;<br>        return SingletonHolder.INSTANCE;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>优点</strong>：</p><ul><li>线程安全，利用类加载机制确保实例唯一。</li><li><strong>延迟加载</strong>（Lazy Loading），只有 <code>getInstance()</code> 被调用时，才创建实例。</li></ul><hr><h3 id="5-枚举实现单例（最佳方案）"><a href="#5-枚举实现单例（最佳方案）" class="headerlink" title="5. 枚举实现单例（最佳方案）"></a><strong>5. 枚举实现单例（最佳方案）</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">public enum Singleton &#123;<br>    INSTANCE;<br><br>    public void doSomething() &#123;<br>        System.out.println(&quot;Hello Singleton!&quot;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>优点</strong>：</p><ul><li><strong>线程安全</strong>，由 JVM 保证。</li><li><strong>防止反射攻击</strong>（私有构造方法仍可通过反射破坏单例，但枚举不会）。</li><li><strong>防止反序列化创建新实例</strong>。</li></ul><hr><h2 id="防止反射和序列化破坏单例"><a href="#防止反射和序列化破坏单例" class="headerlink" title="防止反射和序列化破坏单例"></a><strong>防止反射和序列化破坏单例</strong></h2><ol><li><p><strong>防止反射破坏单例</strong></p><ul><li>在构造方法中检测实例是否已存在：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">public class Singleton &#123;<br>    private static volatile Singleton instance;<br><br>    private Singleton() &#123;<br>        if (instance != null) &#123;<br>            throw new RuntimeException(&quot;禁止反射创建单例！&quot;);<br>        &#125;<br>    &#125;<br><br>    public static Singleton getInstance() &#123;<br>        if (instance == null) &#123;<br>            synchronized (Singleton.class) &#123;<br>                if (instance == null) &#123;<br>                    instance = new Singleton();<br>                &#125;<br>            &#125;<br>        &#125;<br>        return instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>防止序列化破坏单例</strong></p><ul><li>通过 <code>readResolve()</code> 方法确保反序列化返回同一个实例：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">private Object readResolve() &#123;<br>    return instance;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><table><thead><tr><th>方式</th><th>是否线程安全</th><th>是否延迟加载</th><th>是否推荐</th></tr></thead><tbody><tr><td>饿汉式</td><td>✅</td><td>❌</td><td>❌（可能浪费资源）</td></tr><tr><td>懒汉式</td><td>❌</td><td>✅</td><td>❌（非线程安全）</td></tr><tr><td>synchronized 懒汉式</td><td>✅</td><td>✅</td><td>❌（影响性能）</td></tr><tr><td>双重检查锁</td><td>✅</td><td>✅</td><td>✅</td></tr><tr><td>静态内部类</td><td>✅</td><td>✅</td><td>✅（推荐）</td></tr><tr><td>枚举</td><td>✅</td><td>✅</td><td>⭐（最佳方式）</td></tr></tbody></table><p><strong>最佳实践</strong>：优先使用 <strong>枚举</strong> 或 <strong>静态内部类</strong> 实现单例。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>final</title>
      <link href="/2025/03/27/javaBasics/1.1%20final/"/>
      <url>/2025/03/27/javaBasics/1.1%20final/</url>
      
        <content type="html"><![CDATA[<p><code>final</code> 关键字在 Java 中主要用于修饰<strong>变量、方法和类</strong>，用来表示<strong>不可更改</strong>的特性。具体用法如下：</p><hr><h2 id="1-修饰变量（常量）"><a href="#1-修饰变量（常量）" class="headerlink" title="1. 修饰变量（常量）"></a>1. 修饰变量（常量）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">final int MAX_VALUE = 100;<br>MAX_VALUE = 200; // ❌ 编译错误，不能修改 final 变量<br></code></pre></td></tr></table></figure><ul><li><strong>修饰基本数据类型</strong>：值不能被修改。</li><li><strong>修饰引用类型</strong>：引用地址不能修改，但对象的内容可以更改。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">final List&lt;String&gt; list = new ArrayList&lt;&gt;();<br>list.add(&quot;Hello&quot;);  // ✅ 可以修改内容<br>list = new ArrayList&lt;&gt;();  // ❌ 不能修改引用地址<br></code></pre></td></tr></table></figure><hr><h2 id="2-修饰方法（防止方法被重写）"><a href="#2-修饰方法（防止方法被重写）" class="headerlink" title="2. 修饰方法（防止方法被重写）"></a>2. 修饰方法（防止方法被重写）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class Parent &#123;<br>    final void show() &#123;<br>        System.out.println(&quot;Parent show&quot;);<br>    &#125;<br>&#125;<br><br>class Child extends Parent &#123;<br>    // ❌ 编译错误，不能重写 final 方法<br>    void show() &#123; <br>        System.out.println(&quot;Child show&quot;); <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="3-修饰类（防止类被继承）"><a href="#3-修饰类（防止类被继承）" class="headerlink" title="3. 修饰类（防止类被继承）"></a>3. 修饰类（防止类被继承）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">final class Animal &#123;<br>    void speak() &#123;<br>        System.out.println(&quot;Animal speaks&quot;);<br>    &#125;<br>&#125;<br><br>// ❌ 编译错误，不能继承 final 类<br>class Dog extends Animal &#123; <br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="4-final-关键字的特殊用法"><a href="#4-final-关键字的特殊用法" class="headerlink" title="4. final 关键字的特殊用法"></a>4. final 关键字的特殊用法</h2><h3 id="（1）修饰成员变量（必须初始化）"><a href="#（1）修饰成员变量（必须初始化）" class="headerlink" title="（1）修饰成员变量（必须初始化）"></a>（1）修饰成员变量（必须初始化）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class Test &#123;<br>    final int num; // 必须在构造器或代码块中初始化<br><br>    Test(int num) &#123;<br>        this.num = num;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="（2）修饰方法参数（参数值不能被修改）"><a href="#（2）修饰方法参数（参数值不能被修改）" class="headerlink" title="（2）修饰方法参数（参数值不能被修改）"></a>（2）修饰方法参数（参数值不能被修改）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">void print(final int x) &#123;<br>    x = 20; // ❌ 编译错误<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="（3）配合-static-final（常量）"><a href="#（3）配合-static-final（常量）" class="headerlink" title="（3）配合 static final（常量）"></a>（3）配合 <code>static final</code>（常量）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">static final double PI = 3.14159;<br></code></pre></td></tr></table></figure><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>修饰变量</strong>：变量值不可变（基本类型值不可变，引用类型地址不可变）。</li><li><strong>修饰方法</strong>：防止子类重写方法。</li><li><strong>修饰类</strong>：防止类被继承。</li></ul><p>这样使用 <code>final</code> 主要是为了<strong>保证安全性</strong>、<strong>提高程序的可读性</strong>，并且在某些情况下还能<strong>优化性能</strong>（JVM 可进行编译优化）。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown语法</title>
      <link href="/2025/03/25/javaBasics/Markdown%E8%AF%AD%E6%B3%95/"/>
      <url>/2025/03/25/javaBasics/Markdown%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="1-0标题"><a href="#1-0标题" class="headerlink" title="1.0标题"></a>1.0标题</h2><p>语法展示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plaintext"># 一级标题<br>## 二级标题<br>### 三级标题<br>#### 四级标题<br>##### 五级标题<br>###### 六级标题<br></code></pre></td></tr></table></figure><hr><h2 id="2-0字体"><a href="#2-0字体" class="headerlink" title="2.0字体"></a>2.0字体</h2><p>语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">*斜体文本*<br>**粗体文本**<br>***粗斜体文本***<br></code></pre></td></tr></table></figure><p><em>斜体</em></p><p><strong>粗体</strong></p><p><em><strong>粗斜体</strong></em></p><hr><h2 id="3-0分割线"><a href="#3-0分割线" class="headerlink" title="3.0分割线"></a>3.0分割线</h2><p>分割线可以让文章变得更加有层次感，语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">***<br>----------<br>_ _ _<br></code></pre></td></tr></table></figure><hr><h2 id="4-0删除线"><a href="#4-0删除线" class="headerlink" title="4.0删除线"></a>4.0删除线</h2><p>给文本加上删除线，在文本两端使用两个波浪线<code>~</code>，语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">~~文本~~<br></code></pre></td></tr></table></figure><p>例如：<del>文本</del></p><hr><h2 id="5-0列表"><a href="#5-0列表" class="headerlink" title="5.0列表"></a>5.0列表</h2><p>列表分为无序和有序</p><hr><h3 id="5-1无序列表"><a href="#5-1无序列表" class="headerlink" title="5.1无序列表"></a>5.1无序列表</h3><p>无序列表使用星号<code>*</code>、加号 <code>+</code>、减号 <code>-</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">* 第一项<br>* 第二项<br>* 第三项<br><br>+ 第一项<br>+ 第二项<br>+ 第三项<br><br><br>- 第一项<br>- 第二项<br>- 第三项<br></code></pre></td></tr></table></figure><p>例如：</p><ul><li>第一项</li><li>第二项</li><li>第三项</li></ul><hr><h3 id="5-2有序列表"><a href="#5-2有序列表" class="headerlink" title="5.2有序列表"></a>5.2有序列表</h3><p>有序列表很简单，就是数字加上<code>.</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">1. 第一项<br>2. 第二项<br>3. 第三项<br></code></pre></td></tr></table></figure><p>例如：</p><ol><li>第一项</li><li>第二项</li><li>第三项</li></ol><hr><h3 id="5-3列表嵌套"><a href="#5-3列表嵌套" class="headerlink" title="5.3列表嵌套"></a>5.3列表嵌套</h3><p>无序和有序可以一起使用，只需要在子列表的选项添加四个空格</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">1. 第一项：<br>    - 子列表1<br>    - 子列表2<br>2. 第二项：<br>    - 子列表1<br>    - 子列表2<br></code></pre></td></tr></table></figure><hr><h2 id="6-0区块"><a href="#6-0区块" class="headerlink" title="6.0区块"></a>6.0区块</h2><p>区块是用来引用的，比如链接或者一段文本</p><p>在段落的开头使用<code>&gt;</code>符号，使用空格，隔开文本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&gt; 引用的内容<br>&gt;<br>&gt; 第二段引用的内容<br></code></pre></td></tr></table></figure><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">https://source.fomal.cc/img/default_cover_1.webp<br></code></pre></td></tr></table></figure></blockquote><p>在引用里面也是分段落的，我们不是使用回车，而是使用<code>&gt;</code>成单个一行</p><hr><h3 id="6-1区块嵌套"><a href="#6-1区块嵌套" class="headerlink" title="6.1区块嵌套"></a>6.1区块嵌套</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&gt; 引用<br>&gt;&gt; 2<br>&gt;&gt;<br>&gt;&gt;&gt;3<br></code></pre></td></tr></table></figure><hr><h2 id="7-0代码块"><a href="#7-0代码块" class="headerlink" title="7.0代码块"></a>7.0代码块</h2><p>这是一个程序员专用的语法，代码块可以展示不同语言的代码，代码块语法如下:上下使用三个点进行包裹，最顶上的可以写上代码的类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">```javascript<br>$(document).ready(function () &#123;<br>    alert(&#x27;RUNOOB&#x27;);<br>&#125;);<br>```<br></code></pre></td></tr></table></figure><hr><h2 id="8-0链接"><a href="#8-0链接" class="headerlink" title="8.0链接"></a>8.0链接</h2><p>插入链接有两种方式：</p><ul><li>第一种：直接插入</li></ul><p><a href="https://selimn0802.github.io/">https://selimn0802.github.io/</a></p><p>这种方式适用于短的链接，但是过长的链接可能会看起来不得当</p><ul><li>第二种：使用markdown语法插入</li></ul><p>其实就是让一段文本，拥有跳转功能</p><p>语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">[链接名称](链接地址)<br><br>或者<br><br>&lt;链接地址&gt;<br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">[Firefly](https://selimn0802.github.io/)<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;https://selimn0802.github.io/&gt;<br></code></pre></td></tr></table></figure><p><a href="https://selimn0802.github.io/">Firefly</a></p><p><a href="https://selimn0802.github.io/">https://selimn0802.github.io/</a></p><hr><h2 id="9-0图片"><a href="#9-0图片" class="headerlink" title="9.0图片"></a>9.0图片</h2><p>语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">![图片描述](图片的链接)<br></code></pre></td></tr></table></figure><p><img src="https://source.fomal.cc/img/default_cover_1.webp" alt="原神"></p><hr><h2 id="10-0表格"><a href="#10-0表格" class="headerlink" title="10.0表格"></a>10.0表格</h2><p>在markdown里面是可以插入表格的，可以体现一些数据</p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">|  表头   | 表头  |<br>|  ----  | ----  |<br>| 单元格  | 单元格 |<br>| 单元格  | 单元格 |<br></code></pre></td></tr></table></figure><hr><h3 id="10-1表格对齐"><a href="#10-1表格对齐" class="headerlink" title="10.1表格对齐"></a>10.1表格对齐</h3><ul><li>居右<code>-:</code></li><li>居左<code>:-</code></li><li>居中<code>:-:</code></li></ul><p>语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">| 左对齐 | 右对齐 | 居中对齐 |<br>| :-----| ----: | :----: |<br>| 单元格 | 单元格 | 单元格 |<br>| 单元格 | 单元格 | 单元格 |<br></code></pre></td></tr></table></figure><hr><h2 id="11-0转义字符"><a href="#11-0转义字符" class="headerlink" title="11.0转义字符"></a>11.0转义字符</h2><p>因为在markdown的语法里面，用了一些特定的符号作为语法，如果我们想输出符号，而不是被识别成语法，就需要使转义字符，只需要使用反斜杠，然后加上下面的某个符号即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">\   反斜线<br>`   反引号<br>*   星号<br>_   下划线<br>&#123;&#125;  花括号<br>[]  方括号<br>()  小括号<br>#   井字号<br>+   加号<br>-   减号<br>.   英文句点<br>!   感叹号<br></code></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2025/03/23/javaBasics/hello-world/"/>
      <url>/2025/03/23/javaBasics/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>关于</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>标签</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>友链</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>音乐</title>
      <link href="/music/index.html"/>
      <url>/music/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>电影</title>
      <link href="/movies/index.html"/>
      <url>/movies/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
