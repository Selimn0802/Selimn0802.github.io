<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>线程池</title>
      <link href="/2025/03/29/09-05-%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
      <url>/2025/03/29/09-05-%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="✅-线程池概述"><a href="#✅-线程池概述" class="headerlink" title="✅ 线程池概述"></a>✅ <strong>线程池概述</strong></h2><p>在多线程编程中，创建和销毁线程是一项相对昂贵的操作。为了减少频繁创建和销毁线程带来的性能开销，<strong>线程池</strong>（Thread Pool）技术应运而生。线程池通过提前创建一定数量的线程来 <strong>复用线程</strong>，提高系统的 <strong>效率</strong> 和 <strong>性能</strong>。</p><p><strong>线程池的主要优势</strong>：</p><ol><li><strong>避免频繁创建和销毁线程的开销</strong>。</li><li><strong>可以控制线程的最大并发数</strong>，防止资源过度消耗。</li><li><strong>线程池可以更好地管理线程生命周期</strong>，避免线程泄漏。</li></ol><hr><h2 id="✅-Java-中的线程池"><a href="#✅-Java-中的线程池" class="headerlink" title="✅ Java 中的线程池"></a>✅ <strong>Java 中的线程池</strong></h2><p>在 <strong>Java</strong> 中，线程池的使用通过 <strong><code>java.util.concurrent</code></strong> 包中的 <strong><code>Executor</code></strong> 接口及其实现类来完成。</p><h3 id="1-线程池核心接口：Executor"><a href="#1-线程池核心接口：Executor" class="headerlink" title="1. 线程池核心接口：Executor"></a><strong>1. 线程池核心接口：<code>Executor</code></strong></h3><ul><li><strong><code>Executor</code></strong> 接口定义了执行异步任务的核心方法：<strong><code>execute(Runnable command)</code></strong>。</li><li><strong><code>ExecutorService</code></strong> 是 <strong><code>Executor</code></strong> 的子接口，提供了更多的线程池控制方法，如提交任务、关闭线程池等。</li></ul><h3 id="2-常见线程池实现："><a href="#2-常见线程池实现：" class="headerlink" title="2. 常见线程池实现："></a><strong>2. 常见线程池实现：</strong></h3><ol><li><strong><code>ThreadPoolExecutor</code></strong><ul><li>这是 <code>ExecutorService</code> 的最常用实现类，具有高度的自定义性。</li></ul></li><li><strong><code>Executors</code> 工厂类</strong><ul><li>提供了几种常用的线程池实现，如 <strong>固定大小线程池</strong>、<strong>单线程池</strong>、<strong>可缓存线程池</strong> 等。</li></ul></li></ol><hr><h2 id="✅-线程池的类型"><a href="#✅-线程池的类型" class="headerlink" title="✅ 线程池的类型"></a>✅ <strong>线程池的类型</strong></h2><h3 id="1-可缓存线程池（newCachedThreadPool-）"><a href="#1-可缓存线程池（newCachedThreadPool-）" class="headerlink" title="1. 可缓存线程池（newCachedThreadPool()）"></a><strong>1. 可缓存线程池（<code>newCachedThreadPool()</code>）</strong></h3><ul><li><strong>特点</strong>：线程池的大小会根据实际情况调整，如果线程池中没有空闲线程，就会创建新线程，空闲线程会在60秒后被回收。</li><li><strong>适用场景</strong>：适合执行大量短时间的小任务。</li></ul><h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a><strong>代码示例</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.ExecutorService;<br><span class="hljs-keyword">import</span> java.util.concurrent.Executors;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CachedThreadPoolExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> Executors.newCachedThreadPool();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            executor.submit(() -&gt; &#123;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 执行任务&quot;</span>);<br>            &#125;);<br>        &#125;<br><br>        executor.shutdown();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>解析</strong>：<code>newCachedThreadPool</code> 创建一个可缓存线程池，根据任务量自动调整线程池的大小。</li></ul><h3 id="2-固定大小线程池（newFixedThreadPool-）"><a href="#2-固定大小线程池（newFixedThreadPool-）" class="headerlink" title="2. 固定大小线程池（newFixedThreadPool()）"></a><strong>2. 固定大小线程池（<code>newFixedThreadPool()</code>）</strong></h3><ul><li><strong>特点</strong>：线程池中的线程数固定，如果所有线程都处于忙碌状态，新的任务会被放入队列等待。</li><li><strong>适用场景</strong>：适用于负载较重的任务，需要控制最大线程数的场景。</li></ul><h4 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a><strong>代码示例</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.ExecutorService;<br><span class="hljs-keyword">import</span> java.util.concurrent.Executors;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FixedThreadPoolExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">3</span>); <span class="hljs-comment">// 创建一个固定大小的线程池</span><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            executor.submit(() -&gt; &#123;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 执行任务&quot;</span>);<br>            &#125;);<br>        &#125;<br><br>        executor.shutdown();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>解析</strong>：<code>newFixedThreadPool(3)</code> 创建一个包含 3 个线程的线程池，超过 3 个任务会被放入队列中等待。</li></ul><h3 id="3-单线程池（newSingleThreadExecutor-）"><a href="#3-单线程池（newSingleThreadExecutor-）" class="headerlink" title="3. 单线程池（newSingleThreadExecutor()）"></a><strong>3. 单线程池（<code>newSingleThreadExecutor()</code>）</strong></h3><ul><li><strong>特点</strong>：线程池只会创建一个线程，所有任务都会在该线程中顺序执行，适用于任务需要串行执行的场景。</li><li><strong>适用场景</strong>：适用于需要确保任务顺序执行的场景。</li></ul><h4 id="代码示例-2"><a href="#代码示例-2" class="headerlink" title="代码示例"></a><strong>代码示例</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.ExecutorService;<br><span class="hljs-keyword">import</span> java.util.concurrent.Executors;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SingleThreadExecutorExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> Executors.newSingleThreadExecutor(); <span class="hljs-comment">// 创建一个单线程池</span><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            executor.submit(() -&gt; &#123;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 执行任务&quot;</span>);<br>            &#125;);<br>        &#125;<br><br>        executor.shutdown();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>解析</strong>：<code>newSingleThreadExecutor</code> 创建一个单线程池，所有任务会按顺序执行，不会并发。</li></ul><h3 id="4-定时线程池（newScheduledThreadPool-）"><a href="#4-定时线程池（newScheduledThreadPool-）" class="headerlink" title="4. 定时线程池（newScheduledThreadPool()）"></a><strong>4. 定时线程池（<code>newScheduledThreadPool()</code>）</strong></h3><ul><li><strong>特点</strong>：线程池支持定时任务执行，可以周期性地执行任务。</li><li><strong>适用场景</strong>：适合定时调度任务或周期性任务。</li></ul><h4 id="代码示例-3"><a href="#代码示例-3" class="headerlink" title="代码示例"></a><strong>代码示例</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.Executors;<br><span class="hljs-keyword">import</span> java.util.concurrent.ScheduledExecutorService;<br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ScheduledThreadPoolExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ScheduledExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> Executors.newScheduledThreadPool(<span class="hljs-number">1</span>);<br><br>        executor.scheduleAtFixedRate(() -&gt; &#123;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 执行定时任务&quot;</span>);<br>        &#125;, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, TimeUnit.SECONDS); <span class="hljs-comment">// 从 0 秒后每 2 秒执行一次</span><br><br>        <span class="hljs-comment">// 等待 10 秒后关闭线程池</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">10000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>        executor.shutdown();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>解析</strong>：<code>scheduleAtFixedRate</code> 用于按固定频率执行任务，适合定时调度任务。</li></ul><hr><h2 id="✅-ThreadPoolExecutor-自定义线程池"><a href="#✅-ThreadPoolExecutor-自定义线程池" class="headerlink" title="✅ ThreadPoolExecutor 自定义线程池"></a>✅ <strong><code>ThreadPoolExecutor</code> 自定义线程池</strong></h2><p><code>ThreadPoolExecutor</code> 是 Java 中最强大且可自定义的线程池实现类，允许你精细控制线程池的行为，如线程池的 <strong>核心线程数</strong>、<strong>最大线程数</strong>、<strong>线程空闲时间</strong> 等。</p><h3 id="构造函数："><a href="#构造函数：" class="headerlink" title="构造函数："></a><strong>构造函数：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize, </span><br><span class="hljs-params">                          <span class="hljs-type">int</span> maximumPoolSize,</span><br><span class="hljs-params">                          <span class="hljs-type">long</span> keepAliveTime,</span><br><span class="hljs-params">                          TimeUnit unit,</span><br><span class="hljs-params">                          BlockingQueue&lt;Runnable&gt; workQueue)</span><br></code></pre></td></tr></table></figure><ul><li><strong><code>corePoolSize</code></strong>：线程池的核心线程数。</li><li><strong><code>maximumPoolSize</code></strong>：线程池的最大线程数。</li><li><strong><code>keepAliveTime</code></strong>：当线程池中的线程超过核心线程数时，空闲线程的最大存活时间。</li><li><strong><code>unit</code></strong>：<code>keepAliveTime</code> 参数的时间单位。</li><li><strong><code>workQueue</code></strong>：用于保存等待执行任务的阻塞队列。</li></ul><h3 id="代码示例-4"><a href="#代码示例-4" class="headerlink" title="代码示例"></a><strong>代码示例</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomThreadPoolExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<br>            <span class="hljs-number">2</span>,  <span class="hljs-comment">// 核心线程数</span><br>            <span class="hljs-number">4</span>,  <span class="hljs-comment">// 最大线程数</span><br>            <span class="hljs-number">60</span>, <span class="hljs-comment">// 空闲线程存活时间</span><br>            TimeUnit.SECONDS,<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="hljs-number">2</span>) <span class="hljs-comment">// 阻塞队列，最多容纳 2 个任务</span><br>        );<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">6</span>; i++) &#123;<br>            executor.submit(() -&gt; &#123;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 执行任务&quot;</span>);<br>            &#125;);<br>        &#125;<br><br>        executor.shutdown();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>解析</strong>：这个线程池设置了 <strong>2 个核心线程</strong>，<strong>最多 4 个线程</strong>，并且 <strong>空闲线程会在 60 秒后被回收</strong>。队列最多能容纳 2 个任务，超过后任务会被拒绝。</li></ul><hr><h2 id="✅-总结"><a href="#✅-总结" class="headerlink" title="✅ 总结"></a>✅ <strong>总结</strong></h2><table><thead><tr><th><strong>线程池类型</strong></th><th><strong>特点</strong></th><th><strong>适用场景</strong></th></tr></thead><tbody><tr><td><strong>可缓存线程池</strong> (<code>newCachedThreadPool()</code>)</td><td>根据需求动态增加线程，空闲线程会被回收</td><td>适合大量短时间任务</td></tr><tr><td><strong>固定线程池</strong> (<code>newFixedThreadPool()</code>)</td><td>线程数固定，多余的任务会在队列中等待</td><td>适合负载较重，控制线程数的场景</td></tr><tr><td><strong>单线程池</strong> (<code>newSingleThreadExecutor()</code>)</td><td>只有一个线程，任务顺序执行</td><td>需要保证任务顺序执行的场景</td></tr><tr><td><strong>定时线程池</strong> (<code>newScheduledThreadPool()</code>)</td><td>支持定时任务执行</td><td>定时任务、周期性任务</td></tr><tr><td><strong>自定义线程池</strong> (<code>ThreadPoolExecutor</code>)</td><td>高度可定制，灵活配置核心线程数、最大线程数等</td><td>需要精细控制线程池行为的场景</td></tr></tbody></table><blockquote><p><strong>总结</strong>：选择线程池时，要根据任务的特性、负载要求和并发需求，来决定使用哪种类型的线程池。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程同步</title>
      <link href="/2025/03/29/09-04-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/"/>
      <url>/2025/03/29/09-04-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="✅-1-线程同步概述"><a href="#✅-1-线程同步概述" class="headerlink" title="✅ 1. 线程同步概述"></a>✅ <strong>1. 线程同步概述</strong></h2><p>在 <strong>多线程环境</strong> 下，如果多个线程同时访问 <strong>共享资源</strong>，可能会导致 <strong>数据不一致</strong> 或 <strong>线程安全问题</strong>。为了避免这种情况，我们需要 <strong>线程同步机制</strong> 来 <strong>控制多个线程对共享资源的访问</strong>。</p><p><strong>常见的线程同步方式</strong>：</p><ol><li><strong>同步代码块（synchronized 代码块）</strong></li><li><strong>同步方法（synchronized 方法）</strong></li><li><strong>显示锁（Lock 机制，如 ReentrantLock）</strong></li></ol><hr><h2 id="✅-2-同步代码块（synchronized-代码块）"><a href="#✅-2-同步代码块（synchronized-代码块）" class="headerlink" title="✅ 2. 同步代码块（synchronized 代码块）"></a>✅ <strong>2. 同步代码块（synchronized 代码块）</strong></h2><h3 id="🔹-概念"><a href="#🔹-概念" class="headerlink" title="🔹 概念"></a><strong>🔹 概念</strong></h3><ul><li><strong>通过 <code>synchronized</code> 关键字</strong> <strong>锁定某个对象</strong>，保证 <strong>同一时刻只有一个线程</strong> 执行同步代码块。</li><li><strong>适用于部分代码需要同步</strong> 的情况，提高性能。</li></ul><h3 id="🔹-代码示例"><a href="#🔹-代码示例" class="headerlink" title="🔹 代码示例"></a><strong>🔹 代码示例</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SharedResource</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">increment</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123; <span class="hljs-comment">// 只锁定 this（当前实例）</span><br>            count++;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; -&gt; &quot;</span> + count);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SynchronizedBlockExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">SharedResource</span> <span class="hljs-variable">resource</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SharedResource</span>();<br><br>        <span class="hljs-type">Runnable</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> () -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>                resource.increment();<br>            &#125;<br>        &#125;;<br><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(task, <span class="hljs-string">&quot;线程1&quot;</span>);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(task, <span class="hljs-string">&quot;线程2&quot;</span>);<br><br>        t1.start();<br>        t2.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="🔹-解析"><a href="#🔹-解析" class="headerlink" title="🔹 解析"></a><strong>🔹 解析</strong></h3><ul><li><code>synchronized (this)</code> <strong>锁定当前实例</strong>，多个线程访问 <code>increment()</code> 方法时 <strong>会串行执行</strong>，避免竞态条件。</li><li><strong>适用于部分代码需要同步</strong> 的场景，而不是锁住整个方法，能提高程序 <strong>并发性能</strong>。</li></ul><hr><h2 id="✅-3-同步方法（synchronized-方法）"><a href="#✅-3-同步方法（synchronized-方法）" class="headerlink" title="✅ 3. 同步方法（synchronized 方法）"></a>✅ <strong>3. 同步方法（synchronized 方法）</strong></h2><h3 id="🔹-概念-1"><a href="#🔹-概念-1" class="headerlink" title="🔹 概念"></a><strong>🔹 概念</strong></h3><ul><li><strong>在方法前加 <code>synchronized</code></strong>，使得 <strong>整个方法</strong> 在同一时刻只能被 <strong>一个线程访问</strong>。</li><li>适用于 <strong>整个方法都需要同步</strong> 的场景，但可能会 <strong>影响并发性能</strong>。</li></ul><h3 id="🔹-代码示例-1"><a href="#🔹-代码示例-1" class="headerlink" title="🔹 代码示例"></a><strong>🔹 代码示例</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SharedResource</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">increment</span><span class="hljs-params">()</span> &#123; <span class="hljs-comment">// 方法同步</span><br>        count++;<br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; -&gt; &quot;</span> + count);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SynchronizedMethodExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">SharedResource</span> <span class="hljs-variable">resource</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SharedResource</span>();<br><br>        <span class="hljs-type">Runnable</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> () -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>                resource.increment();<br>            &#125;<br>        &#125;;<br><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(task, <span class="hljs-string">&quot;线程1&quot;</span>);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(task, <span class="hljs-string">&quot;线程2&quot;</span>);<br><br>        t1.start();<br>        t2.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="🔹-解析-1"><a href="#🔹-解析-1" class="headerlink" title="🔹 解析"></a><strong>🔹 解析</strong></h3><ul><li><code>synchronized</code> 修饰方法，相当于 <strong><code>synchronized (this) &#123;&#125;</code></strong>。</li><li><strong>适用于整个方法都需要同步</strong> 的情况，但会影响 <strong>程序并发性能</strong>。</li></ul><h3 id="⚠️-静态方法同步"><a href="#⚠️-静态方法同步" class="headerlink" title="⚠️ 静态方法同步"></a><strong>⚠️ 静态方法同步</strong></h3><ul><li><strong><code>synchronized static</code></strong> 方法锁定的是 <strong>类对象（Class 对象）</strong>，而不是实例：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SharedResource</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">increment</span><span class="hljs-params">()</span> &#123; <span class="hljs-comment">// 锁定类对象</span><br>        count++;<br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; -&gt; &quot;</span> + count);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>等价于：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">increment</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">synchronized</span> (SharedResource.class) &#123; <br>        count++;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>适用于</strong> 需要对 <strong>类级别共享资源</strong> 进行同步的场景。</p></blockquote><hr><h2 id="✅-4-Lock（显式锁机制）"><a href="#✅-4-Lock（显式锁机制）" class="headerlink" title="✅ 4. Lock（显式锁机制）"></a>✅ <strong>4. Lock（显式锁机制）</strong></h2><h3 id="🔹-概念-2"><a href="#🔹-概念-2" class="headerlink" title="🔹 概念"></a><strong>🔹 概念</strong></h3><ul><li><code>Lock</code>（如 <code>ReentrantLock</code>）提供 <strong>更灵活的同步控制</strong>，相比 <code>synchronized</code> 具有以下优势：<ul><li><strong>支持公平锁和非公平锁</strong>（<code>synchronized</code> 只能是非公平锁）</li><li><strong>可以尝试获取锁</strong>（避免死锁）</li><li><strong>可以中断</strong>（线程可被打断）</li></ul></li></ul><h3 id="🔹-代码示例-2"><a href="#🔹-代码示例-2" class="headerlink" title="🔹 代码示例"></a><strong>🔹 代码示例</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.locks.Lock;<br><span class="hljs-keyword">import</span> java.util.concurrent.locks.ReentrantLock;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SharedResource</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Lock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>(); <span class="hljs-comment">// 创建锁对象</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">increment</span><span class="hljs-params">()</span> &#123;<br>        lock.lock(); <span class="hljs-comment">// 获取锁</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            count++;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; -&gt; &quot;</span> + count);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock(); <span class="hljs-comment">// 确保释放锁</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LockExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">SharedResource</span> <span class="hljs-variable">resource</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SharedResource</span>();<br><br>        <span class="hljs-type">Runnable</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> () -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>                resource.increment();<br>            &#125;<br>        &#125;;<br><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(task, <span class="hljs-string">&quot;线程1&quot;</span>);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(task, <span class="hljs-string">&quot;线程2&quot;</span>);<br><br>        t1.start();<br>        t2.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="🔹-解析-2"><a href="#🔹-解析-2" class="headerlink" title="🔹 解析"></a><strong>🔹 解析</strong></h3><ul><li><code>lock.lock()</code> 获取锁，<code>lock.unlock()</code> 释放锁，确保 <code>finally</code> 代码块中释放锁，防止 <strong>死锁</strong>。</li><li><code>ReentrantLock</code> 是 <strong>可重入锁</strong>，同一线程可多次获取锁。</li></ul><hr><h2 id="✅-5-synchronized-vs-Lock-对比"><a href="#✅-5-synchronized-vs-Lock-对比" class="headerlink" title="✅ 5. synchronized vs Lock 对比"></a>✅ <strong>5. <code>synchronized</code> vs <code>Lock</code> 对比</strong></h2><table><thead><tr><th><strong>对比项</strong></th><th><strong>synchronized</strong></th><th><strong>Lock（ReentrantLock）</strong></th></tr></thead><tbody><tr><td><strong>锁的类型</strong></td><td><strong>隐式锁</strong>（JVM 负责加锁解锁）</td><td><strong>显式锁</strong>（手动加锁解锁）</td></tr><tr><td><strong>公平锁</strong></td><td>不支持</td><td>支持 <strong>公平锁&#x2F;非公平锁</strong></td></tr><tr><td><strong>可中断性</strong></td><td><strong>不可中断</strong>，必须执行完</td><td><strong>可中断</strong>（<code>lockInterruptibly()</code>）</td></tr><tr><td><strong>尝试获取锁</strong></td><td>不支持</td><td><strong>支持 <code>tryLock()</code></strong>（避免死锁）</td></tr><tr><td><strong>性能</strong></td><td><strong>JVM 优化，性能较高</strong></td><td><strong>稍低，但更灵活</strong></td></tr></tbody></table><h3 id="✅-使用建议"><a href="#✅-使用建议" class="headerlink" title="✅ 使用建议"></a><strong>✅ 使用建议</strong></h3><ul><li><strong>简单的同步</strong>（如线程安全的计数器）：✅ <code>synchronized</code></li><li><strong>需要公平锁、可中断锁</strong> 或 <strong>避免死锁</strong>：✅ <code>ReentrantLock</code></li><li><strong>涉及多个共享资源</strong>（如数据库事务、读写锁）：✅ <code>ReentrantLock</code></li></ul><hr><h2 id="✅-6-总结"><a href="#✅-6-总结" class="headerlink" title="✅ 6. 总结"></a>✅ <strong>6. 总结</strong></h2><table><thead><tr><th><strong>同步方式</strong></th><th><strong>特点</strong></th></tr></thead><tbody><tr><td><strong>同步代码块</strong> (<code>synchronized (this) &#123;&#125;</code>)</td><td>适用于 <strong>部分代码</strong> 需要同步，提高性能</td></tr><tr><td><strong>同步方法</strong> (<code>synchronized 方法名() &#123;&#125;</code>)</td><td>适用于 <strong>整个方法</strong> 需要同步，简单但影响并发</td></tr><tr><td><strong>Lock（ReentrantLock）</strong></td><td><strong>显式锁</strong>，支持 <strong>公平锁、可中断、尝试获取锁</strong>，适用于 <strong>高级同步</strong></td></tr></tbody></table><blockquote><p><strong>推荐方式</strong>：</p><ul><li><strong>首选 <code>synchronized</code>（简单、高效）</strong></li><li><strong>如果需要复杂控制（如公平锁、可中断）</strong>，使用 <code>Lock</code></li></ul></blockquote><hr>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式</title>
      <link href="/2025/03/29/13-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2025/03/29/13-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>正则表达式（<strong>Regular Expression</strong>，简称 <strong>Regex</strong> 或 <strong>RegExp</strong>）是一种用于描述字符串模式的工具，广泛应用于字符串的匹配、搜索、替换和验证等操作。它通过特定的语法规则来匹配字符串中的特定模式。</p><p>在 <strong>Java</strong> 中，正则表达式是通过 <code>java.util.regex</code> 包中的 <strong><code>Pattern</code></strong> 和 <strong><code>Matcher</code></strong> 类来实现的。</p><hr><h2 id="✅-正则表达式的基本构成"><a href="#✅-正则表达式的基本构成" class="headerlink" title="✅ 正则表达式的基本构成"></a>✅ <strong>正则表达式的基本构成</strong></h2><h3 id="1-字符匹配"><a href="#1-字符匹配" class="headerlink" title="1. 字符匹配"></a><strong>1. 字符匹配</strong></h3><ul><li><strong><code>.</code></strong> : 匹配任意一个字符（除了换行符）</li><li><strong><code>\d</code></strong> : 匹配一个数字字符，等价于 <code>[0-9]</code></li><li><strong><code>\D</code></strong> : 匹配非数字字符，等价于 <code>[^0-9]</code></li><li><strong><code>\w</code></strong> : 匹配一个字母、数字或下划线字符，等价于 <code>[a-zA-Z0-9_]</code></li><li><strong><code>\W</code></strong> : 匹配非字母、数字或下划线字符，等价于 <code>[^a-zA-Z0-9_]</code></li><li><strong><code>\s</code></strong> : 匹配一个空白字符（如空格、制表符、换行符等）</li><li><strong><code>\S</code></strong> : 匹配一个非空白字符</li><li><strong><code>\b</code></strong> : 匹配单词边界</li><li><strong><code>\B</code></strong> : 匹配非单词边界</li></ul><h3 id="2-量词"><a href="#2-量词" class="headerlink" title="2. 量词"></a><strong>2. 量词</strong></h3><ul><li><strong><code>*</code></strong> : 匹配前面的字符零次或多次</li><li><strong><code>+</code></strong> : 匹配前面的字符一次或多次</li><li><strong><code>?</code></strong> : 匹配前面的字符零次或一次</li><li><strong><code>&#123;n&#125;</code></strong> : 匹配前面字符恰好 n 次</li><li><strong><code>&#123;n,&#125;</code></strong> : 匹配前面字符至少 n 次</li><li><strong><code>&#123;n,m&#125;</code></strong> : 匹配前面字符至少 n 次，至多 m 次</li></ul><h3 id="3-字符集与范围"><a href="#3-字符集与范围" class="headerlink" title="3. 字符集与范围"></a><strong>3. 字符集与范围</strong></h3><ul><li><strong><code>[abc]</code></strong> : 匹配字符 <code>a</code>、<code>b</code> 或 <code>c</code> 中的任意一个字符</li><li><strong><code>[^abc]</code></strong> : 匹配除 <code>a</code>、<code>b</code>、<code>c</code> 以外的任意字符</li><li><strong><code>[a-z]</code></strong> : 匹配小写字母中的任意一个字符</li><li><strong><code>[A-Z]</code></strong> : 匹配大写字母中的任意一个字符</li><li><strong><code>[0-9]</code></strong> : 匹配数字中的任意一个字符</li></ul><h3 id="4-分组与选择"><a href="#4-分组与选择" class="headerlink" title="4. 分组与选择"></a><strong>4. 分组与选择</strong></h3><ul><li><strong><code>()</code></strong> : 用于分组匹配</li><li><strong><code>|</code></strong> : 表示“或”操作，匹配左边或右边的表达式</li></ul><h3 id="5-其他特殊字符"><a href="#5-其他特殊字符" class="headerlink" title="5. 其他特殊字符"></a><strong>5. 其他特殊字符</strong></h3><ul><li><strong><code>\</code></strong> : 转义字符，用于转义特殊字符（如 <code>.</code>、<code>*</code>、<code>+</code> 等）</li><li><strong><code>^</code></strong> : 匹配输入的开始位置</li><li><strong><code>$</code></strong> : 匹配输入的结束位置</li></ul><hr><h2 id="✅-Java-中正则表达式的应用"><a href="#✅-Java-中正则表达式的应用" class="headerlink" title="✅ Java 中正则表达式的应用"></a>✅ <strong>Java 中正则表达式的应用</strong></h2><h3 id="1-使用-Pattern-类"><a href="#1-使用-Pattern-类" class="headerlink" title="1. 使用 Pattern 类"></a><strong>1. 使用 <code>Pattern</code> 类</strong></h3><p><code>Pattern</code> 类代表了一个正则表达式，并提供了许多方法来对字符串进行匹配操作。它是正则表达式操作的核心。</p><h3 id="2-使用-Matcher-类"><a href="#2-使用-Matcher-类" class="headerlink" title="2. 使用 Matcher 类"></a><strong>2. 使用 <code>Matcher</code> 类</strong></h3><p><code>Matcher</code> 类用于执行与正则表达式相关的匹配操作，如查找、替换、验证等。</p><h3 id="3-常用方法"><a href="#3-常用方法" class="headerlink" title="3. 常用方法"></a><strong>3. 常用方法</strong></h3><table><thead><tr><th><strong>方法</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><code>Pattern.compile(String regex)</code></td><td>编译一个正则表达式，返回一个 <code>Pattern</code> 对象</td></tr><tr><td><code>matcher.find()</code></td><td>查找匹配的字符串</td></tr><tr><td><code>matcher.group()</code></td><td>获取匹配的子字符串</td></tr><tr><td><code>matcher.matches()</code></td><td>检查整个字符串是否与正则表达式匹配</td></tr><tr><td><code>matcher.replaceAll(String replacement)</code></td><td>替换所有匹配的部分</td></tr></tbody></table><hr><h2 id="✅-示例：正则表达式的使用"><a href="#✅-示例：正则表达式的使用" class="headerlink" title="✅ 示例：正则表达式的使用"></a>✅ <strong>示例：正则表达式的使用</strong></h2><h3 id="1-判断字符串是否匹配正则表达式"><a href="#1-判断字符串是否匹配正则表达式" class="headerlink" title="1. 判断字符串是否匹配正则表达式"></a><strong>1. 判断字符串是否匹配正则表达式</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.regex.Pattern;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RegexExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">regex</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;^\\d&#123;3&#125;-\\d&#123;2&#125;-\\d&#123;4&#125;$&quot;</span>; <span class="hljs-comment">// 社会安全号码（SSN）格式</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">input</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;123-45-6789&quot;</span>;<br>        <br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">matches</span> <span class="hljs-operator">=</span> Pattern.matches(regex, input);<br>        System.out.println(<span class="hljs-string">&quot;匹配结果: &quot;</span> + matches);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>解释</strong>：这个正则表达式检查是否为一个有效的社会安全号码格式（例如：<code>123-45-6789</code>）。<code>^</code> 表示字符串开始，<code>\d&#123;3&#125;</code> 表示三位数字，<code>-</code> 匹配一个连字符，<code>\d&#123;2&#125;</code> 表示两位数字，最后的 <code>\d&#123;4&#125;</code> 表示四位数字，<code>$</code> 表示字符串结束。</li></ul><h3 id="2-使用-Pattern-和-Matcher-查找匹配内容"><a href="#2-使用-Pattern-和-Matcher-查找匹配内容" class="headerlink" title="2. 使用 Pattern 和 Matcher 查找匹配内容"></a><strong>2. 使用 <code>Pattern</code> 和 <code>Matcher</code> 查找匹配内容</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.regex.Matcher;<br><span class="hljs-keyword">import</span> java.util.regex.Pattern;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RegexExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">regex</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;\\b\\w+\\b&quot;</span>; <span class="hljs-comment">// 匹配单词</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">input</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello, how are you?&quot;</span>;<br><br>        <span class="hljs-type">Pattern</span> <span class="hljs-variable">pattern</span> <span class="hljs-operator">=</span> Pattern.compile(regex);<br>        <span class="hljs-type">Matcher</span> <span class="hljs-variable">matcher</span> <span class="hljs-operator">=</span> pattern.matcher(input);<br><br>        <span class="hljs-keyword">while</span> (matcher.find()) &#123;<br>            System.out.println(<span class="hljs-string">&quot;找到单词: &quot;</span> + matcher.group());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>解释</strong>：这个正则表达式匹配字符串中的每个单词（由字母、数字或下划线组成）。<code>\\b</code> 是单词边界，<code>\\w+</code> 匹配一个或多个字母、数字或下划线。</li></ul><h3 id="3-替换匹配的部分"><a href="#3-替换匹配的部分" class="headerlink" title="3. 替换匹配的部分"></a><strong>3. 替换匹配的部分</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.regex.Matcher;<br><span class="hljs-keyword">import</span> java.util.regex.Pattern;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RegexExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">regex</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;\\d+&quot;</span>;  <span class="hljs-comment">// 匹配数字</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">input</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;I have 2 apples and 10 oranges.&quot;</span>;<br><br>        <span class="hljs-type">Pattern</span> <span class="hljs-variable">pattern</span> <span class="hljs-operator">=</span> Pattern.compile(regex);<br>        <span class="hljs-type">Matcher</span> <span class="hljs-variable">matcher</span> <span class="hljs-operator">=</span> pattern.matcher(input);<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> matcher.replaceAll(<span class="hljs-string">&quot;many&quot;</span>);  <span class="hljs-comment">// 替换数字为 &quot;many&quot;</span><br>        System.out.println(<span class="hljs-string">&quot;替换后的字符串: &quot;</span> + result);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>解释</strong>：在这个示例中，正则表达式 <code>\\d+</code> 匹配字符串中的所有数字，并将其替换为 <code>&quot;many&quot;</code>。</li></ul><hr><h2 id="✅-总结"><a href="#✅-总结" class="headerlink" title="✅ 总结"></a>✅ <strong>总结</strong></h2><p>正则表达式是一个强大且灵活的工具，在处理字符串匹配、替换和验证时非常有用。Java 提供了 <code>Pattern</code> 和 <code>Matcher</code> 类来实现正则表达式的匹配操作。通过掌握常见的正则语法和 Java 中的操作方法，你可以更加高效地处理字符串相关的任务。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>thread提供的常用构造器</title>
      <link href="/2025/03/29/09-03-thread%E6%8F%90%E4%BE%9B%E7%9A%84%E5%B8%B8%E7%94%A8%E6%9E%84%E9%80%A0%E5%99%A8/"/>
      <url>/2025/03/29/09-03-thread%E6%8F%90%E4%BE%9B%E7%9A%84%E5%B8%B8%E7%94%A8%E6%9E%84%E9%80%A0%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p><code>Thread</code> 类提供了几个常见的构造方法，用于创建和初始化线程。下面是 <code>Thread</code> 类的常见构造器及其说明：</p><hr><h2 id="✅-1-Thread"><a href="#✅-1-Thread" class="headerlink" title="✅ 1. Thread()"></a>✅ <strong>1. <code>Thread()</code></strong></h2><ul><li><strong>作用</strong>：创建一个新的线程，默认没有指定任务，也没有指定线程名称。</li><li><strong>使用场景</strong>：当你想要自定义线程的任务时，通常通过继承 <code>Thread</code> 类并重写 <code>run()</code> 方法。</li></ul><h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a><strong>示例</strong>：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>();<br>thread.start();<br></code></pre></td></tr></table></figure><hr><h2 id="✅-2-Thread-Runnable-target"><a href="#✅-2-Thread-Runnable-target" class="headerlink" title="✅ 2. Thread(Runnable target)"></a>✅ <strong>2. <code>Thread(Runnable target)</code></strong></h2><ul><li><strong>作用</strong>：创建一个新的线程并将指定的 <code>Runnable</code> 目标传递给线程。该线程会执行 <code>Runnable</code> 的 <code>run()</code> 方法中的任务。</li><li><strong>使用场景</strong>：当线程的任务已经被实现为 <code>Runnable</code> 接口时，可以直接传递给 <code>Thread</code> 构造方法。</li></ul><h3 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a><strong>示例</strong>：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Runnable</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> () -&gt; System.out.println(<span class="hljs-string">&quot;线程执行&quot;</span>);<br><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(task);<br>thread.start();<br></code></pre></td></tr></table></figure><hr><h2 id="✅-3-Thread-String-name"><a href="#✅-3-Thread-String-name" class="headerlink" title="✅ 3. Thread(String name)"></a>✅ <strong>3. <code>Thread(String name)</code></strong></h2><ul><li><strong>作用</strong>：创建一个新的线程并指定线程名称。该线程将执行 <code>run()</code> 方法，线程名称默认为 <code>Thread-0</code>、<code>Thread-1</code> 等。</li><li><strong>使用场景</strong>：当你想为线程指定名称时，可以使用该构造方法。</li></ul><h3 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a><strong>示例</strong>：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-string">&quot;自定义线程名称&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;线程名称: &quot;</span> + thread.getName());<br>thread.start();<br></code></pre></td></tr></table></figure><hr><h2 id="✅-4-Thread-Runnable-target-String-name"><a href="#✅-4-Thread-Runnable-target-String-name" class="headerlink" title="✅ 4. Thread(Runnable target, String name)"></a>✅ <strong>4. <code>Thread(Runnable target, String name)</code></strong></h2><ul><li><strong>作用</strong>：创建一个新的线程并将指定的 <code>Runnable</code> 目标传递给线程，同时为线程指定一个名称。该线程将执行 <code>Runnable</code> 的 <code>run()</code> 方法中的任务。</li><li><strong>使用场景</strong>：当你想为线程指定任务并为其命名时，可以使用该构造方法。</li></ul><h3 id="示例：-3"><a href="#示例：-3" class="headerlink" title="示例："></a><strong>示例</strong>：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Runnable</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> () -&gt; System.out.println(<span class="hljs-string">&quot;线程执行&quot;</span>);<br><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(task, <span class="hljs-string">&quot;自定义线程名称&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;线程名称: &quot;</span> + thread.getName());<br>thread.start();<br></code></pre></td></tr></table></figure><hr><h2 id="✅-5-Thread-ThreadGroup-group-Runnable-target"><a href="#✅-5-Thread-ThreadGroup-group-Runnable-target" class="headerlink" title="✅ 5. Thread(ThreadGroup group, Runnable target)"></a>✅ <strong>5. <code>Thread(ThreadGroup group, Runnable target)</code></strong></h2><ul><li><strong>作用</strong>：创建一个新的线程并指定线程组 <code>group</code> 和执行的任务 <code>Runnable target</code>。  </li><li><strong>使用场景</strong>：当需要将线程加入特定的线程组时，可以使用该构造方法。</li></ul><h3 id="示例：-4"><a href="#示例：-4" class="headerlink" title="示例："></a><strong>示例</strong>：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ThreadGroup</span> <span class="hljs-variable">group</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadGroup</span>(<span class="hljs-string">&quot;线程组&quot;</span>);<br><span class="hljs-type">Runnable</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> () -&gt; System.out.println(<span class="hljs-string">&quot;线程执行&quot;</span>);<br><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(group, task);<br>thread.start();<br></code></pre></td></tr></table></figure><hr><h2 id="✅-6-Thread-ThreadGroup-group-Runnable-target-String-name"><a href="#✅-6-Thread-ThreadGroup-group-Runnable-target-String-name" class="headerlink" title="✅ 6. Thread(ThreadGroup group, Runnable target, String name)"></a>✅ <strong>6. <code>Thread(ThreadGroup group, Runnable target, String name)</code></strong></h2><ul><li><strong>作用</strong>：创建一个新的线程并指定线程组、执行的任务和线程名称。</li><li><strong>使用场景</strong>：当你需要将线程加入特定的线程组、指定任务并命名线程时，可以使用该构造方法。</li></ul><h3 id="示例：-5"><a href="#示例：-5" class="headerlink" title="示例："></a><strong>示例</strong>：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ThreadGroup</span> <span class="hljs-variable">group</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadGroup</span>(<span class="hljs-string">&quot;线程组&quot;</span>);<br><span class="hljs-type">Runnable</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> () -&gt; System.out.println(<span class="hljs-string">&quot;线程执行&quot;</span>);<br><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(group, task, <span class="hljs-string">&quot;自定义线程名称&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;线程名称: &quot;</span> + thread.getName());<br>thread.start();<br></code></pre></td></tr></table></figure><hr><h2 id="✅-总结"><a href="#✅-总结" class="headerlink" title="✅ 总结"></a>✅ <strong>总结</strong></h2><table><thead><tr><th><strong>构造方法</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><code>Thread()</code></td><td>创建一个没有任务和名称的线程</td></tr><tr><td><code>Thread(Runnable target)</code></td><td>创建一个带有 <code>Runnable</code> 任务的线程</td></tr><tr><td><code>Thread(String name)</code></td><td>创建一个没有任务但指定名称的线程</td></tr><tr><td><code>Thread(Runnable target, String name)</code></td><td>创建一个带有 <code>Runnable</code> 任务并指定名称的线程</td></tr><tr><td><code>Thread(ThreadGroup group, Runnable target)</code></td><td>创建一个带有 <code>Runnable</code> 任务并指定线程组的线程</td></tr><tr><td><code>Thread(ThreadGroup group, Runnable target, String name)</code></td><td>创建一个带有 <code>Runnable</code> 任务、指定线程组和名称的线程</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>thread提供的常用方法</title>
      <link href="/2025/03/29/09-02-thread%E6%8F%90%E4%BE%9B%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/"/>
      <url>/2025/03/29/09-02-thread%E6%8F%90%E4%BE%9B%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p><code>Thread</code> 类提供了多种常用方法，用于创建和管理线程。下面是一些常用的 <code>Thread</code> 方法及其说明：</p><hr><h2 id="✅-1-创建和启动线程的方法"><a href="#✅-1-创建和启动线程的方法" class="headerlink" title="✅ 1. 创建和启动线程的方法"></a>✅ <strong>1. 创建和启动线程的方法</strong></h2><h3 id="1-start"><a href="#1-start" class="headerlink" title="(1) start()"></a><strong>(1) <code>start()</code></strong></h3><ul><li><strong>作用</strong>：启动线程。调用 <code>start()</code> 方法后，线程将进入“可运行”状态，并开始执行 <code>run()</code> 方法。</li><li><strong>注意</strong>：只能调用一次，调用多次会抛出 <code>IllegalThreadStateException</code> 异常。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; System.out.println(<span class="hljs-string">&quot;线程正在执行&quot;</span>));<br>thread.start();<br></code></pre></td></tr></table></figure><h3 id="2-run"><a href="#2-run" class="headerlink" title="(2) run()"></a><strong>(2) <code>run()</code></strong></h3><ul><li><strong>作用</strong>：线程执行的代码逻辑。<code>run()</code> 方法是线程的入口，线程在启动时会执行 <code>run()</code> 方法中的代码。  </li><li><strong>注意</strong>：通常不直接调用 <code>run()</code> 方法，而是调用 <code>start()</code> 来启动线程。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;线程执行&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">MyThread</span> <span class="hljs-variable">myThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>();<br>        myThread.start(); <span class="hljs-comment">// 调用 start() 执行 run()</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="✅-2-线程的生命周期方法"><a href="#✅-2-线程的生命周期方法" class="headerlink" title="✅ 2. 线程的生命周期方法"></a>✅ <strong>2. 线程的生命周期方法</strong></h2><h3 id="1-sleep-long-millis"><a href="#1-sleep-long-millis" class="headerlink" title="(1) sleep(long millis)"></a><strong>(1) <code>sleep(long millis)</code></strong></h3><ul><li><strong>作用</strong>：使当前线程暂停（休眠）指定时间（毫秒）。休眠期间线程不占用 CPU 资源。</li><li><strong>注意</strong>：<code>sleep()</code> 方法是静态的，调用后，当前线程进入“休眠”状态。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        System.out.println(<span class="hljs-string">&quot;线程开始&quot;</span>);<br>        Thread.sleep(<span class="hljs-number">2000</span>); <span class="hljs-comment">// 当前线程休眠 2 秒</span><br>        System.out.println(<span class="hljs-string">&quot;线程结束&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-interrupt"><a href="#2-interrupt" class="headerlink" title="(2) interrupt()"></a><strong>(2) <code>interrupt()</code></strong></h3><ul><li><strong>作用</strong>：中断当前线程，设置线程的中断标志为 <code>true</code>。  </li><li><strong>注意</strong>：如果线程在 <code>sleep()</code>、<code>wait()</code> 或 <code>join()</code> 等方法上被阻塞，调用 <code>interrupt()</code> 会抛出 <code>InterruptedException</code>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        Thread.sleep(<span class="hljs-number">5000</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        System.out.println(<span class="hljs-string">&quot;线程被中断&quot;</span>);<br>    &#125;<br>&#125;);<br>thread.start();<br><br><span class="hljs-comment">// 中断线程</span><br>thread.interrupt();<br></code></pre></td></tr></table></figure><hr><h2 id="✅-3-获取线程状态和信息的方法"><a href="#✅-3-获取线程状态和信息的方法" class="headerlink" title="✅ 3. 获取线程状态和信息的方法"></a>✅ <strong>3. 获取线程状态和信息的方法</strong></h2><h3 id="1-getId"><a href="#1-getId" class="headerlink" title="(1) getId()"></a><strong>(1) <code>getId()</code></strong></h3><ul><li><strong>作用</strong>：返回当前线程的唯一标识符（ID）。  </li><li><strong>返回类型</strong>：<code>long</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>();<br>System.out.println(<span class="hljs-string">&quot;线程ID: &quot;</span> + thread.getId());<br></code></pre></td></tr></table></figure><h3 id="2-getName"><a href="#2-getName" class="headerlink" title="(2) getName()"></a><strong>(2) <code>getName()</code></strong></h3><ul><li><strong>作用</strong>：返回当前线程的名称。默认名称是 <code>Thread-0</code>、<code>Thread-1</code> 等，可以通过构造方法修改。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>();<br>System.out.println(<span class="hljs-string">&quot;线程名称: &quot;</span> + thread.getName());<br></code></pre></td></tr></table></figure><h3 id="3-getState"><a href="#3-getState" class="headerlink" title="(3) getState()"></a><strong>(3) <code>getState()</code></strong></h3><ul><li><strong>作用</strong>：获取当前线程的状态。返回值是 <code>Thread.State</code> 枚举类型，可能的状态有：  <ul><li><code>NEW</code>：线程已创建，但未启动。  </li><li><code>RUNNABLE</code>：线程可以执行（即使线程正在等待 CPU 时间片）。  </li><li><code>BLOCKED</code>：线程在等待锁。  </li><li><code>WAITING</code>：线程正在等待其他线程的通知。  </li><li><code>TIMED_WAITING</code>：线程在等待指定时间后继续执行。  </li><li><code>TERMINATED</code>：线程已完成执行。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>();<br>System.out.println(<span class="hljs-string">&quot;线程状态: &quot;</span> + thread.getState());<br></code></pre></td></tr></table></figure><h3 id="4-isAlive"><a href="#4-isAlive" class="headerlink" title="(4) isAlive()"></a><strong>(4) <code>isAlive()</code></strong></h3><ul><li><strong>作用</strong>：判断线程是否仍在运行。返回 <code>true</code> 如果线程已启动并且尚未终止。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>();<br>thread.start();<br>System.out.println(<span class="hljs-string">&quot;线程是否活着: &quot;</span> + thread.isAlive());<br></code></pre></td></tr></table></figure><h3 id="5-setName-String-name"><a href="#5-setName-String-name" class="headerlink" title="(5) setName(String name)"></a><strong>(5) <code>setName(String name)</code></strong></h3><ul><li><strong>作用</strong>：设置当前线程的名称。  </li><li><strong>说明</strong>：默认线程名称是 <code>Thread-0</code>、<code>Thread-1</code> 等，可以通过 <code>setName()</code> 方法修改线程名称，便于识别和调试。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>();<br>thread.setName(<span class="hljs-string">&quot;自定义线程名称&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;当前线程名称: &quot;</span> + thread.getName());<br></code></pre></td></tr></table></figure><hr><h2 id="✅-4-线程的控制方法"><a href="#✅-4-线程的控制方法" class="headerlink" title="✅ 4. 线程的控制方法"></a>✅ <strong>4. 线程的控制方法</strong></h2><h3 id="1-join"><a href="#1-join" class="headerlink" title="(1) join()"></a><strong>(1) <code>join()</code></strong></h3><ul><li><strong>作用</strong>：使当前线程等待目标线程完成（终止），即当前线程会阻塞直到目标线程终止为止。</li><li><strong>注意</strong>：<code>join()</code> 可以带上等待时间，表示等待目标线程最多执行指定的时间。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">thread1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    System.out.println(<span class="hljs-string">&quot;线程1执行&quot;</span>);<br>&#125;);<br><span class="hljs-type">Thread</span> <span class="hljs-variable">thread2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    System.out.println(<span class="hljs-string">&quot;线程2执行&quot;</span>);<br>&#125;);<br><br>thread1.start();<br>thread2.start();<br><br><span class="hljs-keyword">try</span> &#123;<br>    thread1.join(); <span class="hljs-comment">// 等待线程1结束</span><br>    thread2.join(); <span class="hljs-comment">// 等待线程2结束</span><br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="✅-5-线程的优先级方法"><a href="#✅-5-线程的优先级方法" class="headerlink" title="✅ 5. 线程的优先级方法"></a>✅ <strong>5. 线程的优先级方法</strong></h2><h3 id="1-setPriority-int-newPriority"><a href="#1-setPriority-int-newPriority" class="headerlink" title="(1) setPriority(int newPriority)"></a><strong>(1) <code>setPriority(int newPriority)</code></strong></h3><ul><li><strong>作用</strong>：设置线程的优先级。线程优先级是一个整数，范围从 <code>Thread.MIN_PRIORITY</code>（1）到 <code>Thread.MAX_PRIORITY</code>（10），默认优先级是 <code>Thread.NORM_PRIORITY</code>（5）。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>();<br>thread.setPriority(Thread.MAX_PRIORITY); <span class="hljs-comment">// 设置为最大优先级</span><br></code></pre></td></tr></table></figure><h3 id="2-getPriority"><a href="#2-getPriority" class="headerlink" title="(2) getPriority()"></a><strong>(2) <code>getPriority()</code></strong></h3><ul><li><strong>作用</strong>：获取当前线程的优先级。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>();<br>System.out.println(<span class="hljs-string">&quot;线程优先级: &quot;</span> + thread.getPriority());<br></code></pre></td></tr></table></figure><hr><h2 id="✅-6-其他常用线程方法"><a href="#✅-6-其他常用线程方法" class="headerlink" title="✅ 6. 其他常用线程方法"></a>✅ <strong>6. 其他常用线程方法</strong></h2><h3 id="1-yield"><a href="#1-yield" class="headerlink" title="(1) yield()"></a><strong>(1) <code>yield()</code></strong></h3><ul><li><strong>作用</strong>：使当前线程主动让出 CPU 时间片，允许其他线程有机会执行。它并不会挂起线程，只是让当前线程回到可运行状态，其他线程可能获得执行机会。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Thread.<span class="hljs-keyword">yield</span>(); <span class="hljs-comment">// 当前线程让步</span><br></code></pre></td></tr></table></figure><h3 id="2-currentThread"><a href="#2-currentThread" class="headerlink" title="(2) currentThread()"></a><strong>(2) <code>currentThread()</code></strong></h3><ul><li><strong>作用</strong>：返回当前正在执行的线程对象。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">currentThread</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>System.out.println(<span class="hljs-string">&quot;当前线程名称: &quot;</span> + currentThread.getName());<br></code></pre></td></tr></table></figure><hr><h2 id="✅-7-Thread-常用方法总结"><a href="#✅-7-Thread-常用方法总结" class="headerlink" title="✅ 7.Thread 常用方法总结"></a>✅ <strong>7.<code>Thread</code> 常用方法总结</strong></h2><table><thead><tr><th><strong>方法</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td><code>start()</code></td><td>启动线程并执行 <code>run()</code> 方法</td></tr><tr><td><code>run()</code></td><td>线程的执行逻辑</td></tr><tr><td><code>sleep(long millis)</code></td><td>使线程休眠指定时间</td></tr><tr><td><code>interrupt()</code></td><td>中断线程</td></tr><tr><td><code>getId()</code></td><td>获取线程的唯一标识符</td></tr><tr><td><code>getName()</code></td><td>获取线程的名称</td></tr><tr><td><code>setName(String name)</code></td><td>设置线程的名称</td></tr><tr><td><code>getState()</code></td><td>获取线程的当前状态</td></tr><tr><td><code>isAlive()</code></td><td>判断线程是否仍在运行</td></tr><tr><td><code>join()</code></td><td>当前线程等待目标线程完成</td></tr><tr><td><code>setPriority(int)</code></td><td>设置线程的优先级</td></tr><tr><td><code>getPriority()</code></td><td>获取线程的优先级</td></tr><tr><td><code>yield()</code></td><td>当前线程让出 CPU 时间片</td></tr><tr><td><code>currentThread()</code></td><td>获取当前正在执行的线程对象</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>String</title>
      <link href="/2025/03/28/14-String/"/>
      <url>/2025/03/28/14-String/</url>
      
        <content type="html"><![CDATA[<p>在 Java 中，<code>String</code> 类是最常用的数据类型之一，它代表不可变的字符串。<code>String</code> 提供了丰富的 API，用于字符串操作，如查找、替换、截取、格式化等。  </p><hr><h2 id="✅-1-创建字符串"><a href="#✅-1-创建字符串" class="headerlink" title="✅ 1. 创建字符串"></a>✅ <strong>1. 创建字符串</strong></h2><p>Java 提供了多种方式来创建字符串：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello&quot;</span>;  <span class="hljs-comment">// 直接赋值（推荐）</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;Hello&quot;</span>);  <span class="hljs-comment">// 通过构造方法（不推荐）</span><br><span class="hljs-type">char</span>[] chars = &#123;<span class="hljs-string">&#x27;H&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>&#125;;<br><span class="hljs-type">String</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(chars);  <span class="hljs-comment">// 通过字符数组创建</span><br></code></pre></td></tr></table></figure><hr><h2 id="✅-2-字符串基本操作"><a href="#✅-2-字符串基本操作" class="headerlink" title="✅ 2. 字符串基本操作"></a>✅ <strong>2. 字符串基本操作</strong></h2><h3 id="（1）获取字符串长度"><a href="#（1）获取字符串长度" class="headerlink" title="（1）获取字符串长度"></a><strong>（1）获取字符串长度</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello, World!&quot;</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> str.length();<br>System.out.println(length); <span class="hljs-comment">// 13</span><br></code></pre></td></tr></table></figure><h3 id="（2）获取字符串中的某个字符"><a href="#（2）获取字符串中的某个字符" class="headerlink" title="（2）获取字符串中的某个字符"></a><strong>（2）获取字符串中的某个字符</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">char</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> str.charAt(<span class="hljs-number">0</span>);<br>System.out.println(ch); <span class="hljs-comment">// &#x27;H&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="（3）字符串拼接"><a href="#（3）字符串拼接" class="headerlink" title="（3）字符串拼接"></a><strong>（3）字符串拼接</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot; World&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> s1.concat(s2);<br>System.out.println(result); <span class="hljs-comment">// &quot;Hello World&quot;</span><br></code></pre></td></tr></table></figure><blockquote><p><strong>⚠ 注意</strong>：尽量使用 <code>StringBuilder</code> 进行拼接，<code>String</code> 的拼接会创建新的对象，效率较低。</p></blockquote><hr><h2 id="✅-3-查找与匹配"><a href="#✅-3-查找与匹配" class="headerlink" title="✅ 3. 查找与匹配"></a>✅ <strong>3. 查找与匹配</strong></h2><h3 id="（1）判断是否包含子字符串"><a href="#（1）判断是否包含子字符串" class="headerlink" title="（1）判断是否包含子字符串"></a><strong>（1）判断是否包含子字符串</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-variable">contains</span> <span class="hljs-operator">=</span> str.contains(<span class="hljs-string">&quot;World&quot;</span>);<br>System.out.println(contains); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h3 id="（2）判断是否以某个前缀或后缀开头"><a href="#（2）判断是否以某个前缀或后缀开头" class="headerlink" title="（2）判断是否以某个前缀或后缀开头"></a><strong>（2）判断是否以某个前缀或后缀开头</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(str.startsWith(<span class="hljs-string">&quot;Hello&quot;</span>)); <span class="hljs-comment">// true</span><br>System.out.println(str.endsWith(<span class="hljs-string">&quot;!&quot;</span>)); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h3 id="（3）获取子字符串的位置"><a href="#（3）获取子字符串的位置" class="headerlink" title="（3）获取子字符串的位置"></a><strong>（3）获取子字符串的位置</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> str.indexOf(<span class="hljs-string">&quot;World&quot;</span>); <span class="hljs-comment">// 7</span><br><span class="hljs-type">int</span> <span class="hljs-variable">lastIndex</span> <span class="hljs-operator">=</span> str.lastIndexOf(<span class="hljs-string">&quot;o&quot;</span>); <span class="hljs-comment">// 8</span><br></code></pre></td></tr></table></figure><hr><h2 id="✅-4-字符串截取"><a href="#✅-4-字符串截取" class="headerlink" title="✅ 4. 字符串截取"></a>✅ <strong>4. 字符串截取</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">sub</span> <span class="hljs-operator">=</span> str.substring(<span class="hljs-number">7</span>); <span class="hljs-comment">// 从索引 7 开始截取</span><br>System.out.println(sub); <span class="hljs-comment">// &quot;World!&quot;</span><br><br><span class="hljs-type">String</span> <span class="hljs-variable">sub2</span> <span class="hljs-operator">=</span> str.substring(<span class="hljs-number">7</span>, <span class="hljs-number">12</span>); <span class="hljs-comment">// 截取索引 [7, 12)</span><br>System.out.println(sub2); <span class="hljs-comment">// &quot;World&quot;</span><br></code></pre></td></tr></table></figure><hr><h2 id="✅-5-替换字符串"><a href="#✅-5-替换字符串" class="headerlink" title="✅ 5. 替换字符串"></a>✅ <strong>5. 替换字符串</strong></h2><h3 id="（1）替换单个字符"><a href="#（1）替换单个字符" class="headerlink" title="（1）替换单个字符"></a><strong>（1）替换单个字符</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">newStr</span> <span class="hljs-operator">=</span> str.replace(<span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>);<br>System.out.println(newStr); <span class="hljs-comment">// &quot;Hell0, W0rld!&quot;</span><br></code></pre></td></tr></table></figure><h3 id="（2）替换子字符串"><a href="#（2）替换子字符串" class="headerlink" title="（2）替换子字符串"></a><strong>（2）替换子字符串</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">newStr2</span> <span class="hljs-operator">=</span> str.replace(<span class="hljs-string">&quot;World&quot;</span>, <span class="hljs-string">&quot;Java&quot;</span>);<br>System.out.println(newStr2); <span class="hljs-comment">// &quot;Hello, Java!&quot;</span><br></code></pre></td></tr></table></figure><h3 id="（3）使用正则表达式替换"><a href="#（3）使用正则表达式替换" class="headerlink" title="（3）使用正则表达式替换"></a><strong>（3）使用正则表达式替换</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">replaced</span> <span class="hljs-operator">=</span> str.replaceAll(<span class="hljs-string">&quot;\\w+&quot;</span>, <span class="hljs-string">&quot;X&quot;</span>);<br>System.out.println(replaced); <span class="hljs-comment">// &quot;X, X!&quot;</span><br></code></pre></td></tr></table></figure><hr><h2 id="✅-6-分割字符串"><a href="#✅-6-分割字符串" class="headerlink" title="✅ 6. 分割字符串"></a>✅ <strong>6. 分割字符串</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;apple,banana,orange&quot;</span>;<br>String[] fruits = data.split(<span class="hljs-string">&quot;,&quot;</span>);<br><span class="hljs-keyword">for</span> (String fruit : fruits) &#123;<br>    System.out.println(fruit);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">apple<br>banana<br>orange<br></code></pre></td></tr></table></figure><hr><h2 id="✅-7-大小写转换"><a href="#✅-7-大小写转换" class="headerlink" title="✅ 7. 大小写转换"></a>✅ <strong>7. 大小写转换</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(str.toUpperCase()); <span class="hljs-comment">// &quot;HELLO, WORLD!&quot;</span><br>System.out.println(str.toLowerCase()); <span class="hljs-comment">// &quot;hello, world!&quot;</span><br></code></pre></td></tr></table></figure><hr><h2 id="✅-8-去除首尾空格"><a href="#✅-8-去除首尾空格" class="headerlink" title="✅ 8. 去除首尾空格"></a>✅ <strong>8. 去除首尾空格</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">spaced</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;   Hello World!   &quot;</span>;<br>System.out.println(spaced.trim()); <span class="hljs-comment">// &quot;Hello World!&quot;</span><br></code></pre></td></tr></table></figure><hr><h2 id="✅-9-字符串比较"><a href="#✅-9-字符串比较" class="headerlink" title="✅ 9. 字符串比较"></a>✅ <strong>9. 字符串比较</strong></h2><h3 id="（1）区分大小写"><a href="#（1）区分大小写" class="headerlink" title="（1）区分大小写"></a><strong>（1）区分大小写</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello&quot;</span>;<br>System.out.println(a.equals(b)); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><h3 id="（2）忽略大小写比较"><a href="#（2）忽略大小写比较" class="headerlink" title="（2）忽略大小写比较"></a><strong>（2）忽略大小写比较</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(a.equalsIgnoreCase(b)); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h3 id="（3）按字典顺序比较"><a href="#（3）按字典顺序比较" class="headerlink" title="（3）按字典顺序比较"></a><strong>（3）按字典顺序比较</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(<span class="hljs-string">&quot;abc&quot;</span>.compareTo(<span class="hljs-string">&quot;abd&quot;</span>)); <span class="hljs-comment">// -1</span><br>System.out.println(<span class="hljs-string">&quot;abc&quot;</span>.compareTo(<span class="hljs-string">&quot;abc&quot;</span>)); <span class="hljs-comment">// 0</span><br>System.out.println(<span class="hljs-string">&quot;abd&quot;</span>.compareTo(<span class="hljs-string">&quot;abc&quot;</span>)); <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><hr><h2 id="✅-10-格式化字符串"><a href="#✅-10-格式化字符串" class="headerlink" title="✅ 10. 格式化字符串"></a>✅ <strong>10. 格式化字符串</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">formatted</span> <span class="hljs-operator">=</span> String.format(<span class="hljs-string">&quot;My name is %s and I am %d years old.&quot;</span>, <span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">25</span>);<br>System.out.println(formatted); <br><span class="hljs-comment">// &quot;My name is Alice and I am 25 years old.&quot;</span><br></code></pre></td></tr></table></figure><hr><h2 id="✅-11-判断字符串是否为空"><a href="#✅-11-判断字符串是否为空" class="headerlink" title="✅ 11. 判断字符串是否为空"></a>✅ <strong>11. 判断字符串是否为空</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">emptyStr</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>System.out.println(emptyStr.isEmpty()); <span class="hljs-comment">// true</span><br>System.out.println(emptyStr.isBlank()); <span class="hljs-comment">// true（Java 11+）</span><br></code></pre></td></tr></table></figure><hr><h2 id="✅-12-使用-StringBuilder-进行高效拼接"><a href="#✅-12-使用-StringBuilder-进行高效拼接" class="headerlink" title="✅ 12. 使用 StringBuilder 进行高效拼接"></a>✅ <strong>12. 使用 <code>StringBuilder</code> 进行高效拼接</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>sb.append(<span class="hljs-string">&quot;Hello&quot;</span>).append(<span class="hljs-string">&quot; &quot;</span>).append(<span class="hljs-string">&quot;World!&quot;</span>);<br>System.out.println(sb.toString()); <span class="hljs-comment">// &quot;Hello World!&quot;</span><br></code></pre></td></tr></table></figure><hr><h2 id="✅-总结"><a href="#✅-总结" class="headerlink" title="✅ 总结"></a>✅ <strong>总结</strong></h2><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td><code>length()</code></td><td>获取字符串长度</td></tr><tr><td><code>charAt(index)</code></td><td>获取指定索引位置的字符</td></tr><tr><td><code>concat(str)</code></td><td>拼接字符串</td></tr><tr><td><code>contains(str)</code></td><td>判断是否包含子字符串</td></tr><tr><td><code>startsWith(str) / endsWith(str)</code></td><td>判断是否以某字符串开头&#x2F;结尾</td></tr><tr><td><code>indexOf(str) / lastIndexOf(str)</code></td><td>获取子字符串的索引位置</td></tr><tr><td><code>substring(start, end)</code></td><td>截取子字符串</td></tr><tr><td><code>replace(old, new)</code></td><td>替换字符串</td></tr><tr><td><code>replaceAll(regex, new)</code></td><td>使用正则表达式替换字符串</td></tr><tr><td><code>split(regex)</code></td><td>按照正则表达式分割字符串</td></tr><tr><td><code>toUpperCase() / toLowerCase()</code></td><td>转换大小写</td></tr><tr><td><code>trim()</code></td><td>去除首尾空格</td></tr><tr><td><code>equals(str) / equalsIgnoreCase(str)</code></td><td>字符串比较</td></tr><tr><td><code>compareTo(str)</code></td><td>按字典顺序比较</td></tr><tr><td><code>isEmpty() / isBlank()</code></td><td>判断字符串是否为空</td></tr><tr><td><code>String.format()</code></td><td>字符串格式化</td></tr><tr><td><code>StringBuilder</code></td><td>高效字符串拼接</td></tr></tbody></table><hr>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 常用API </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用API </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>方法引用</title>
      <link href="/2025/03/28/06-02-%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8/"/>
      <url>/2025/03/28/06-02-%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>在 <strong>Java</strong> 中，<strong>方法引用（Method Reference）</strong> 是 Java 8 引入的一种简洁的语法形式，用于通过方法的名字来引用方法。它是 <strong>Lambda 表达式</strong> 的一种简化写法，特别适用于需要传递方法作为参数的场景。</p><hr><h2 id="✅-方法引用的分类"><a href="#✅-方法引用的分类" class="headerlink" title="✅ 方法引用的分类"></a>✅ <strong>方法引用的分类</strong></h2><p>方法引用主要有以下四种形式：  </p><table><thead><tr><th><strong>类型</strong></th><th><strong>语法</strong></th><th><strong>示例</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>静态方法引用</td><td><code>ClassName::staticMethod</code></td><td><code>Math::abs</code></td><td>引用类中的静态方法</td></tr><tr><td>实例方法引用（特定对象）</td><td><code>instance::method</code></td><td><code>System.out::println</code></td><td>引用对象的实例方法</td></tr><tr><td>实例方法引用（任意对象）</td><td><code>ClassName::method</code></td><td><code>String::toUpperCase</code></td><td>引用某个类的任意对象的实例方法</td></tr><tr><td>构造器引用</td><td><code>ClassName::new</code></td><td><code>ArrayList::new</code></td><td>引用类的构造方法</td></tr></tbody></table><hr><h2 id="✅-1-静态方法引用"><a href="#✅-1-静态方法引用" class="headerlink" title="✅ 1. 静态方法引用"></a>✅ <strong>1. 静态方法引用</strong></h2><p>静态方法引用用于引用类的静态方法。  </p><h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a><strong>示例</strong>：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StaticMethodReferenceExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;Integer&gt; numbers = Arrays.asList(-<span class="hljs-number">3</span>, -<span class="hljs-number">2</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br>        <br>        <span class="hljs-comment">// 使用静态方法引用 Math::abs</span><br>        numbers.stream()<br>               .map(Math::abs)<br>               .forEach(System.out::println);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>解释</strong>：<code>Math::abs</code> 是静态方法引用，等价于 <code>x -&gt; Math.abs(x)</code>。</li></ul><hr><h2 id="✅-2-实例方法引用（特定对象）"><a href="#✅-2-实例方法引用（特定对象）" class="headerlink" title="✅ 2. 实例方法引用（特定对象）"></a>✅ <strong>2. 实例方法引用（特定对象）</strong></h2><p>实例方法引用用于引用特定对象的实例方法。  </p><h3 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a><strong>示例</strong>：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InstanceMethodReferenceExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;String&gt; names = Arrays.asList(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-string">&quot;Charlie&quot;</span>);<br>        <br>        <span class="hljs-comment">// 使用实例方法引用</span><br>        names.forEach(System.out::println);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>解释</strong>：<code>System.out::println</code> 是方法引用，等价于 <code>x -&gt; System.out.println(x)</code>。</li></ul><hr><h2 id="✅-3-实例方法引用（任意对象）"><a href="#✅-3-实例方法引用（任意对象）" class="headerlink" title="✅ 3. 实例方法引用（任意对象）"></a>✅ <strong>3. 实例方法引用（任意对象）</strong></h2><p>当实例方法的调用目标是流中的每一个对象时，可以使用类名加方法名的形式引用实例方法。  </p><h3 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a><strong>示例</strong>：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InstanceMethodReferenceExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;String&gt; words = Arrays.asList(<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-string">&quot;cherry&quot;</span>);<br>        <br>        <span class="hljs-comment">// 使用实例方法引用</span><br>        words.stream()<br>             .map(String::toUpperCase)<br>             .forEach(System.out::println);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>解释</strong>：<code>String::toUpperCase</code> 是方法引用，等价于 <code>s -&gt; s.toUpperCase()</code>。</li></ul><hr><h2 id="✅-4-构造器引用"><a href="#✅-4-构造器引用" class="headerlink" title="✅ 4. 构造器引用"></a>✅ <strong>4. 构造器引用</strong></h2><p>构造器引用用于创建对象。它通过 <code>ClassName::new</code> 的形式引用类的构造方法。  </p><h3 id="示例：-3"><a href="#示例：-3" class="headerlink" title="示例："></a><strong>示例</strong>：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.stream.Collectors;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConstructorReferenceExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;String&gt; names = List.of(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-string">&quot;Charlie&quot;</span>);<br>        <br>        <span class="hljs-comment">// 使用构造器引用</span><br>        List&lt;String&gt; nameList = names.stream()<br>                                      .collect(Collectors.toCollection(ArrayList::<span class="hljs-keyword">new</span>));<br><br>        System.out.println(nameList);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>解释</strong>：<code>ArrayList::new</code> 是构造器引用，等价于 <code>() -&gt; new ArrayList&lt;&gt;()</code>。</li></ul><hr><h2 id="✅-总结"><a href="#✅-总结" class="headerlink" title="✅ 总结"></a>✅ <strong>总结</strong></h2><table><thead><tr><th><strong>方法引用类型</strong></th><th><strong>语法形式</strong></th><th><strong>等价Lambda表达式</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td>静态方法引用</td><td><code>ClassName::staticMethod</code></td><td><code>(x) -&gt; ClassName.staticMethod(x)</code></td><td><code>Math::abs</code></td></tr><tr><td>实例方法引用（特定对象）</td><td><code>instance::method</code></td><td><code>(x) -&gt; instance.method(x)</code></td><td><code>System.out::println</code></td></tr><tr><td>实例方法引用（任意对象）</td><td><code>ClassName::method</code></td><td><code>(x) -&gt; x.method()</code></td><td><code>String::toUpperCase</code></td></tr><tr><td>构造器引用</td><td><code>ClassName::new</code></td><td><code>() -&gt; new ClassName()</code></td><td><code>ArrayList::new</code></td></tr></tbody></table><hr>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 函数式编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 函数式编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>匿名内部类</title>
      <link href="/2025/03/28/06-01-%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB/"/>
      <url>/2025/03/28/06-01-%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<ul><li><p>在 <strong>Java</strong> 中，<strong>匿名内部类</strong> 是一种没有名字的类，通常用于简化代码。它用于实现接口或继承类的实例化，通常是在需要创建一次性对象的场景下使用。  </p><hr><h2 id="✅-1-什么是匿名内部类？"><a href="#✅-1-什么是匿名内部类？" class="headerlink" title="✅ 1. 什么是匿名内部类？"></a>✅ <strong>1. 什么是匿名内部类？</strong></h2><p><strong>匿名内部类</strong> 是在声明和实例化类的同时完成的，它没有类名。它可以：  </p><ul><li><strong>继承一个类</strong>  </li><li><strong>实现一个接口</strong></li></ul><p><strong>语法：</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> 父类或接口(参数) &#123;<br>    <span class="hljs-comment">// 重写方法或定义新方法</span><br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="✅-2-使用场景和示例"><a href="#✅-2-使用场景和示例" class="headerlink" title="✅ 2. 使用场景和示例"></a>✅ <strong>2. 使用场景和示例</strong></h2><h3 id="场景一：继承类的匿名内部类"><a href="#场景一：继承类的匿名内部类" class="headerlink" title="场景一：继承类的匿名内部类"></a><strong>场景一：继承类的匿名内部类</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">sound</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;动物发出声音&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建匿名内部类继承 Animal</span><br>        <span class="hljs-type">Animal</span> <span class="hljs-variable">cat</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Animal</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">void</span> <span class="hljs-title function_">sound</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;喵喵叫&quot;</span>);<br>            &#125;<br>        &#125;;<br><br>        cat.sound(); <span class="hljs-comment">// 输出：喵喵叫</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>解释：</strong>  </p><ul><li>使用 <code>new Animal()</code> 创建一个继承 <code>Animal</code> 的匿名类，并重写了 <code>sound()</code> 方法。  </li><li>这种写法适合需要临时重写父类方法的场景。</li></ul><hr><h3 id="场景二：实现接口的匿名内部类"><a href="#场景二：实现接口的匿名内部类" class="headerlink" title="场景二：实现接口的匿名内部类"></a><strong>场景二：实现接口的匿名内部类</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Greeting</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHello</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 使用匿名内部类实现接口</span><br>        <span class="hljs-type">Greeting</span> <span class="hljs-variable">greeting</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Greeting</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHello</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;你好，Java！&quot;</span>);<br>            &#125;<br>        &#125;;<br><br>        greeting.sayHello(); <span class="hljs-comment">// 输出：你好，Java！</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>解释：</strong>  </p><ul><li>匿名类实现了 <code>Greeting</code> 接口并重写了 <code>sayHello()</code> 方法。  </li><li>适合需要一次性实现接口的场景。</li></ul><hr><h3 id="场景三：结合线程的匿名内部类"><a href="#场景三：结合线程的匿名内部类" class="headerlink" title="场景三：结合线程的匿名内部类"></a><strong>场景三：结合线程的匿名内部类</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 使用匿名内部类创建线程</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;线程正在运行: &quot;</span> + Thread.currentThread().getName());<br>            &#125;<br>        &#125;);<br><br>        thread.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>解释：</strong>  </p><ul><li>匿名类实现了 <code>Runnable</code> 接口，并直接传递给 <code>Thread</code>。  </li><li>适合简单的多线程场景。</li></ul><hr><h3 id="场景四：使用-Lambda-替代匿名内部类"><a href="#场景四：使用-Lambda-替代匿名内部类" class="headerlink" title="场景四：使用 Lambda 替代匿名内部类"></a><strong>场景四：使用 Lambda 替代匿名内部类</strong></h3><p>对于只有一个抽象方法的接口（即<strong>函数式接口</strong>），Java 8 引入了 <strong>Lambda 表达式</strong>，可以更简洁地替代匿名内部类。  </p><p><strong>示例：使用 Lambda 替代匿名内部类</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Greeting</span> <span class="hljs-variable">greeting</span> <span class="hljs-operator">=</span> () -&gt; System.out.println(<span class="hljs-string">&quot;你好，Lambda！&quot;</span>);<br>greeting.sayHello();<br></code></pre></td></tr></table></figure><p><strong>解释：</strong>  </p><ul><li>Lambda 只能用于函数式接口。  </li><li>使用 <code>-&gt;</code> 符号简化代码。</li></ul><hr><h2 id="✅-3-匿名内部类的特点"><a href="#✅-3-匿名内部类的特点" class="headerlink" title="✅ 3. 匿名内部类的特点"></a>✅ <strong>3. 匿名内部类的特点</strong></h2><ul><li><strong>没有类名</strong>，只能通过父类或接口的引用进行操作。  </li><li><strong>一次性使用</strong>，通常用于简化代码。  </li><li><strong>可以直接重写方法</strong>，无需额外创建类文件。  </li><li><strong>不能有构造方法</strong>，但可以使用<strong>实例代码块</strong>进行初始化。</li></ul><p><strong>示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    Person(String name) &#123;<br>        System.out.println(<span class="hljs-string">&quot;Person 构造方法: &quot;</span> + name);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 使用实例代码块代替构造方法</span><br>        <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;张三&quot;</span>) &#123;<br>            &#123;<br>                System.out.println(<span class="hljs-string">&quot;匿名内部类中的初始化块&quot;</span>);<br>            &#125;<br>        &#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">Person 构造方法: 张三<br>匿名内部类中的初始化块<br></code></pre></td></tr></table></figure><hr><h2 id="✅-4-总结：什么时候使用匿名内部类？"><a href="#✅-4-总结：什么时候使用匿名内部类？" class="headerlink" title="✅ 4. 总结：什么时候使用匿名内部类？"></a>✅ <strong>4. 总结：什么时候使用匿名内部类？</strong></h2><ul><li><strong>临时性需求</strong>：只需要一次性实现接口或重写方法。  </li><li><strong>简化代码</strong>：不需要创建额外的类文件。  </li><li><strong>事件监听器</strong>：在 GUI 程序中广泛使用匿名内部类处理事件。  </li><li><strong>线程创建</strong>：快速实现 <code>Runnable</code>。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 函数式编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 函数式编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>lambda</title>
      <link href="/2025/03/28/05-lambda/"/>
      <url>/2025/03/28/05-lambda/</url>
      
        <content type="html"><![CDATA[<p>在 <strong>Java</strong> 中，<strong>Lambda表达式</strong> 是 Java 8 引入的一个特性，用于简化代码，特别是在需要使用 <strong>函数式接口</strong> 的场景。它提供了一种简洁的方式来表示匿名函数，使代码更简洁和可读。</p><hr><h2 id="✅1-Lambda-表达式的基本语法"><a href="#✅1-Lambda-表达式的基本语法" class="headerlink" title="✅1. Lambda 表达式的基本语法"></a><strong>✅1. Lambda 表达式的基本语法</strong></h2><p>Lambda 表达式的语法结构如下：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">(参数列表) -&gt; &#123; 方法体 &#125;<br></code></pre></td></tr></table></figure><ul><li><strong>参数列表</strong>：可以有 0 个或多个参数。  </li><li><strong>箭头操作符 <code>-&gt;</code></strong>：用于分隔参数和方法体。  </li><li><strong>方法体</strong>：包含具体的代码逻辑。</li></ul><h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a><strong>示例：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 无参数，直接执行</span><br><span class="hljs-type">Runnable</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> () -&gt; System.out.println(<span class="hljs-string">&quot;Hello, Lambda!&quot;</span>);<br>r.run();<br><br><span class="hljs-comment">// 有参数，有返回值</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Calculator</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>;<br>&#125;<br><br><span class="hljs-type">Calculator</span> <span class="hljs-variable">calc</span> <span class="hljs-operator">=</span> (a, b) -&gt; a + b;<br>System.out.println(<span class="hljs-string">&quot;结果: &quot;</span> + calc.add(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>));<br></code></pre></td></tr></table></figure><hr><h2 id="✅2-使用-Lambda-的条件"><a href="#✅2-使用-Lambda-的条件" class="headerlink" title="✅2. 使用 Lambda 的条件"></a><strong>✅2. 使用 Lambda 的条件</strong></h2><p>Lambda 表达式通常用于<strong>函数式接口</strong>。  </p><ul><li><strong>函数式接口</strong>：只包含一个抽象方法的接口，通常用 <code>@FunctionalInterface</code> 注解标识。  </li><li>Java 自带了很多函数式接口，例如 <code>Runnable</code>、<code>Comparator</code>、<code>Consumer</code> 等。</li></ul><h3 id="自定义函数式接口"><a href="#自定义函数式接口" class="headerlink" title="自定义函数式接口"></a><strong>自定义函数式接口</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Greeting</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHello</span><span class="hljs-params">(String name)</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Greeting</span> <span class="hljs-variable">greeting</span> <span class="hljs-operator">=</span> name -&gt; System.out.println(<span class="hljs-string">&quot;你好, &quot;</span> + name);<br>        greeting.sayHello(<span class="hljs-string">&quot;小明&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="✅3-常见-Lambda-用法"><a href="#✅3-常见-Lambda-用法" class="headerlink" title="✅3. 常见 Lambda 用法"></a><strong>✅3. 常见 Lambda 用法</strong></h2><h3 id="1-使用-Lambda-实现-Runnable"><a href="#1-使用-Lambda-实现-Runnable" class="headerlink" title="(1) 使用 Lambda 实现 Runnable"></a><strong>(1) 使用 Lambda 实现 Runnable</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; System.out.println(<span class="hljs-string">&quot;线程运行中&quot;</span>));<br>thread.start();<br></code></pre></td></tr></table></figure><h3 id="2-使用-Lambda-进行集合遍历"><a href="#2-使用-Lambda-进行集合遍历" class="headerlink" title="(2) 使用 Lambda 进行集合遍历"></a><strong>(2) 使用 Lambda 进行集合遍历</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        list.add(<span class="hljs-string">&quot;Java&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;Python&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;C++&quot;</span>);<br><br>        <span class="hljs-comment">// 使用 Lambda 表达式遍历</span><br>        list.forEach(item -&gt; System.out.println(item));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-使用-Lambda-进行排序"><a href="#3-使用-Lambda-进行排序" class="headerlink" title="(3) 使用 Lambda 进行排序"></a><strong>(3) 使用 Lambda 进行排序</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;String&gt; list = Arrays.asList(<span class="hljs-string">&quot;Banana&quot;</span>, <span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Orange&quot;</span>);<br><br>        <span class="hljs-comment">// 使用 Lambda 表达式排序</span><br>        Collections.sort(list, (a, b) -&gt; a.compareTo(b));<br>        System.out.println(list);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="✅4-使用方法引用"><a href="#✅4-使用方法引用" class="headerlink" title="✅4. 使用方法引用"></a><strong>✅4. 使用方法引用</strong></h2><p>当 Lambda 表达式仅调用一个现有方法时，可以使用方法引用进一步简化代码。<br><strong>语法：</strong> <code>类名::方法名</code> 或 <code>对象名::方法名</code></p><h3 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a><strong>示例：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = Arrays.asList(<span class="hljs-string">&quot;Banana&quot;</span>, <span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Orange&quot;</span>);<br><br><span class="hljs-comment">// 使用方法引用</span><br>list.forEach(System.out::println);<br></code></pre></td></tr></table></figure><p>等价于：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">list.forEach(item -&gt; System.out.println(item));<br></code></pre></td></tr></table></figure><hr><h2 id="✅5-总结"><a href="#✅5-总结" class="headerlink" title="✅5. 总结"></a><strong>✅5. 总结</strong></h2><ul><li><strong>Lambda 表达式</strong> 简化了匿名类的写法。  </li><li>只能用于<strong>函数式接口</strong>。  </li><li>使用 <code>-&gt;</code> 分隔参数和方法体。  </li><li>可以结合<strong>方法引用</strong>进一步简化代码。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 函数式编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 函数式编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ArrayList</title>
      <link href="/2025/03/28/07-ArrayList/"/>
      <url>/2025/03/28/07-ArrayList/</url>
      
        <content type="html"><![CDATA[<p>在 Java 中，<code>ArrayList</code> 是 <code>java.util</code> 包中的一个类，用于存储动态数组。它提供了比普通数组更灵活的功能，可以自动调整大小。  </p><hr><h2 id="✅1-创建-ArrayList"><a href="#✅1-创建-ArrayList" class="headerlink" title="✅1. 创建 ArrayList"></a><strong>✅1. 创建 ArrayList</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建一个存储字符串的 ArrayList</span><br>        ArrayList&lt;String&gt; list1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>        <span class="hljs-comment">// 使用 List 接口引用</span><br>        List&lt;Integer&gt; list2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong><code>ArrayList</code></strong> 是实现类，<strong><code>List</code></strong> 是接口。  </li><li><strong>泛型 <code>&lt;E&gt;</code></strong> 指定存储的数据类型。  </li><li>如果没有指定类型：<code>ArrayList list = new ArrayList();</code>（不推荐）</li></ul><hr><h2 id="✅2-常用方法"><a href="#✅2-常用方法" class="headerlink" title="✅2. 常用方法"></a><strong>✅2. 常用方法</strong></h2><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>add(E e)</code></td><td>添加元素</td></tr><tr><td><code>add(int index, E e)</code></td><td>在指定位置插入元素</td></tr><tr><td><code>remove(int index)</code></td><td>删除指定位置的元素</td></tr><tr><td><code>remove(Object o)</code></td><td>删除指定元素</td></tr><tr><td><code>get(int index)</code></td><td>获取指定位置的元素</td></tr><tr><td><code>set(int index, E e)</code></td><td>修改指定位置的元素</td></tr><tr><td><code>size()</code></td><td>获取元素数量</td></tr><tr><td><code>isEmpty()</code></td><td>判断是否为空</td></tr><tr><td><code>contains(Object o)</code></td><td>判断是否包含某个元素</td></tr><tr><td><code>clear()</code></td><td>清空所有元素</td></tr></tbody></table><hr><h2 id="✅3-示例：基本操作"><a href="#✅3-示例：基本操作" class="headerlink" title="✅3. 示例：基本操作"></a><strong>✅3. 示例：基本操作</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>        <span class="hljs-comment">// 添加元素</span><br>        list.add(<span class="hljs-string">&quot;苹果&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;香蕉&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;橘子&quot;</span>);<br><br>        System.out.println(<span class="hljs-string">&quot;初始列表: &quot;</span> + list);<br><br>        <span class="hljs-comment">// 在指定位置插入元素</span><br>        list.add(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;芒果&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;插入芒果后: &quot;</span> + list);<br><br>        <span class="hljs-comment">// 获取元素</span><br>        System.out.println(<span class="hljs-string">&quot;第二个元素: &quot;</span> + list.get(<span class="hljs-number">1</span>));<br><br>        <span class="hljs-comment">// 修改元素</span><br>        list.set(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;西瓜&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;修改后: &quot;</span> + list);<br><br>        <span class="hljs-comment">// 删除元素</span><br>        list.remove(<span class="hljs-string">&quot;香蕉&quot;</span>); <span class="hljs-comment">// 删除具体元素</span><br>        System.out.println(<span class="hljs-string">&quot;删除香蕉后: &quot;</span> + list);<br><br>        list.remove(<span class="hljs-number">1</span>); <span class="hljs-comment">// 删除索引位置的元素</span><br>        System.out.println(<span class="hljs-string">&quot;删除索引1后: &quot;</span> + list);<br><br>        <span class="hljs-comment">// 判断是否包含</span><br>        System.out.println(<span class="hljs-string">&quot;是否包含苹果: &quot;</span> + list.contains(<span class="hljs-string">&quot;苹果&quot;</span>));<br><br>        <span class="hljs-comment">// 清空列表</span><br>        list.clear();<br>        System.out.println(<span class="hljs-string">&quot;清空后: &quot;</span> + list.isEmpty());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="✅4-遍历-ArrayList"><a href="#✅4-遍历-ArrayList" class="headerlink" title="✅4. 遍历 ArrayList"></a><strong>✅4. 遍历 ArrayList</strong></h2><h3 id="方式一：for-each-循环"><a href="#方式一：for-each-循环" class="headerlink" title="方式一：for-each 循环"></a><strong>方式一：for-each 循环</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>list.add(<span class="hljs-string">&quot;Java&quot;</span>);<br>list.add(<span class="hljs-string">&quot;Python&quot;</span>);<br>list.add(<span class="hljs-string">&quot;C++&quot;</span>);<br><br><span class="hljs-keyword">for</span> (String lang : list) &#123;<br>    System.out.println(lang);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="方式二：普通-for-循环"><a href="#方式二：普通-for-循环" class="headerlink" title="方式二：普通 for 循环"></a><strong>方式二：普通 for 循环</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; list.size(); i++) &#123;<br>    System.out.println(list.get(i));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="方式三：使用-Lambda-表达式"><a href="#方式三：使用-Lambda-表达式" class="headerlink" title="方式三：使用 Lambda 表达式"></a><strong>方式三：使用 Lambda 表达式</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">list.forEach(lang -&gt; System.out.println(lang));<br></code></pre></td></tr></table></figure><hr><h2 id="✅5-ArrayList-与数组转换"><a href="#✅5-ArrayList-与数组转换" class="headerlink" title="✅5. ArrayList 与数组转换"></a><strong>✅5. ArrayList 与数组转换</strong></h2><h3 id="ArrayList-转-数组"><a href="#ArrayList-转-数组" class="headerlink" title="ArrayList 转 数组"></a><strong>ArrayList 转 数组</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">String[] array = list.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[<span class="hljs-number">0</span>]);<br><span class="hljs-keyword">for</span> (String s : array) &#123;<br>    System.out.println(s);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="数组-转-ArrayList"><a href="#数组-转-ArrayList" class="headerlink" title="数组 转 ArrayList"></a><strong>数组 转 ArrayList</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.List;<br><br>String[] array = &#123;<span class="hljs-string">&quot;Java&quot;</span>, <span class="hljs-string">&quot;Python&quot;</span>, <span class="hljs-string">&quot;C++&quot;</span>&#125;;<br>List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(Arrays.asList(array));<br>System.out.println(list);<br></code></pre></td></tr></table></figure><hr><h2 id="✅总结"><a href="#✅总结" class="headerlink" title="✅总结"></a><strong>✅总结</strong></h2><ul><li><strong><code>ArrayList</code></strong> 适合需要频繁读取数据的场景，增删元素时性能较低。  </li><li>如果需要频繁增删数据，可以考虑使用 <strong><code>LinkedList</code></strong>。  </li><li><code>ArrayList</code> 是<strong>线程不安全</strong>的，如果需要在多线程环境中使用，请考虑使用 <code>Collections.synchronizedList()</code> 或 <code>CopyOnWriteArrayList</code>。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 常用API </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用API </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LinkedList</title>
      <link href="/2025/03/28/08-LinkList/"/>
      <url>/2025/03/28/08-LinkList/</url>
      
        <content type="html"><![CDATA[<p>在 <strong>Java</strong> 中，<code>LinkedList</code> 是 <strong>java.util</strong> 包中的一个类，实现了 <strong>List</strong> 接口和 <strong>Deque</strong> 接口。它是基于<strong>双向链表</strong>的数据结构，适合频繁插入和删除数据的场景。  </p><hr><h2 id="✅-1-LinkedList-的特点"><a href="#✅-1-LinkedList-的特点" class="headerlink" title="✅ 1. LinkedList 的特点"></a>✅ <strong>1. LinkedList 的特点</strong></h2><ul><li><strong>链表结构</strong>：每个节点包含数据和指向前后节点的引用。  </li><li><strong>插入和删除效率高</strong>：在链表中增加或删除元素的时间复杂度为 <strong>O(1)</strong>。  </li><li><strong>访问效率低</strong>：由于不是基于数组的结构，查找元素的时间复杂度为 <strong>O(n)</strong>。  </li><li><strong>双向链表</strong>：支持从头到尾和从尾到头的遍历。</li></ul><hr><h2 id="✅-2-创建-LinkedList"><a href="#✅-2-创建-LinkedList" class="headerlink" title="✅ 2. 创建 LinkedList"></a>✅ <strong>2. 创建 LinkedList</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.LinkedList;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建一个存储字符串的 LinkedList</span><br>        LinkedList&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><br>        <span class="hljs-comment">// 添加元素</span><br>        list.add(<span class="hljs-string">&quot;苹果&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;香蕉&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;橘子&quot;</span>);<br><br>        System.out.println(<span class="hljs-string">&quot;初始链表: &quot;</span> + list);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="✅-3-常用方法"><a href="#✅-3-常用方法" class="headerlink" title="✅ 3. 常用方法"></a>✅ <strong>3. 常用方法</strong></h2><table><thead><tr><th><strong>方法</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><code>add(E e)</code></td><td>添加元素到链表尾部</td></tr><tr><td><code>addFirst(E e)</code></td><td>在链表头部添加元素</td></tr><tr><td><code>addLast(E e)</code></td><td>在链表尾部添加元素</td></tr><tr><td><code>remove()</code></td><td>删除并返回头部元素</td></tr><tr><td><code>removeFirst()</code></td><td>删除并返回头部元素</td></tr><tr><td><code>removeLast()</code></td><td>删除并返回尾部元素</td></tr><tr><td><code>get(int index)</code></td><td>获取指定位置的元素</td></tr><tr><td><code>getFirst()</code></td><td>获取头部元素</td></tr><tr><td><code>getLast()</code></td><td>获取尾部元素</td></tr><tr><td><code>size()</code></td><td>获取链表长度</td></tr><tr><td><code>isEmpty()</code></td><td>判断链表是否为空</td></tr><tr><td><code>contains(Object o)</code></td><td>判断链表是否包含某个元素</td></tr><tr><td><code>clear()</code></td><td>清空链表</td></tr></tbody></table><hr><h2 id="✅-4-示例：基本操作"><a href="#✅-4-示例：基本操作" class="headerlink" title="✅ 4. 示例：基本操作"></a>✅ <strong>4. 示例：基本操作</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.LinkedList;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        LinkedList&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><br>        <span class="hljs-comment">// 添加元素</span><br>        list.add(<span class="hljs-string">&quot;Java&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;Python&quot;</span>);<br>        list.addFirst(<span class="hljs-string">&quot;C++&quot;</span>);    <span class="hljs-comment">// 添加到头部</span><br>        list.addLast(<span class="hljs-string">&quot;JavaScript&quot;</span>); <span class="hljs-comment">// 添加到尾部</span><br><br>        System.out.println(<span class="hljs-string">&quot;链表内容: &quot;</span> + list);<br><br>        <span class="hljs-comment">// 获取元素</span><br>        System.out.println(<span class="hljs-string">&quot;第一个元素: &quot;</span> + list.getFirst());<br>        System.out.println(<span class="hljs-string">&quot;最后一个元素: &quot;</span> + list.getLast());<br>        System.out.println(<span class="hljs-string">&quot;索引1的元素: &quot;</span> + list.get(<span class="hljs-number">1</span>));<br><br>        <span class="hljs-comment">// 删除元素</span><br>        list.removeFirst();  <span class="hljs-comment">// 删除头部元素</span><br>        list.removeLast();   <span class="hljs-comment">// 删除尾部元素</span><br>        System.out.println(<span class="hljs-string">&quot;删除后的链表: &quot;</span> + list);<br><br>        <span class="hljs-comment">// 判断元素是否存在</span><br>        System.out.println(<span class="hljs-string">&quot;是否包含 Python: &quot;</span> + list.contains(<span class="hljs-string">&quot;Python&quot;</span>));<br><br>        <span class="hljs-comment">// 清空链表</span><br>        list.clear();<br>        System.out.println(<span class="hljs-string">&quot;清空后链表是否为空: &quot;</span> + list.isEmpty());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="✅-5-LinkedList-的遍历方式"><a href="#✅-5-LinkedList-的遍历方式" class="headerlink" title="✅ 5. LinkedList 的遍历方式"></a>✅ <strong>5. LinkedList 的遍历方式</strong></h2><h3 id="方式一：普通-for-循环"><a href="#方式一：普通-for-循环" class="headerlink" title="方式一：普通 for 循环"></a><strong>方式一：普通 for 循环</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; list.size(); i++) &#123;<br>    System.out.println(list.get(i));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="方式二：增强-for-循环"><a href="#方式二：增强-for-循环" class="headerlink" title="方式二：增强 for 循环"></a><strong>方式二：增强 for 循环</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (String s : list) &#123;<br>    System.out.println(s);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="方式三：使用-Iterator"><a href="#方式三：使用-Iterator" class="headerlink" title="方式三：使用 Iterator"></a><strong>方式三：使用 Iterator</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Iterator;<br><br>Iterator&lt;String&gt; iterator = list.iterator();<br><span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>    System.out.println(iterator.next());<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="方式四：使用-Lambda-表达式"><a href="#方式四：使用-Lambda-表达式" class="headerlink" title="方式四：使用 Lambda 表达式"></a><strong>方式四：使用 Lambda 表达式</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">list.forEach(s -&gt; System.out.println(s));<br></code></pre></td></tr></table></figure><hr><h2 id="✅-6-LinkedList-vs-ArrayList"><a href="#✅-6-LinkedList-vs-ArrayList" class="headerlink" title="✅ 6. LinkedList vs ArrayList"></a>✅ <strong>6. LinkedList vs ArrayList</strong></h2><table><thead><tr><th><strong>特性</strong></th><th><strong>LinkedList</strong></th><th><strong>ArrayList</strong></th></tr></thead><tbody><tr><td><strong>底层结构</strong></td><td>双向链表</td><td>动态数组</td></tr><tr><td><strong>插入和删除</strong></td><td>O(1)（在头部或尾部）</td><td>O(n)（中间位置需要移动元素）</td></tr><tr><td><strong>查找元素</strong></td><td>O(n)</td><td>O(1)</td></tr><tr><td><strong>内存占用</strong></td><td>较高（需要额外存储前后指针）</td><td>较低（只存储数据）</td></tr><tr><td><strong>适用场景</strong></td><td>频繁插入、删除数据</td><td>频繁随机访问数据</td></tr></tbody></table><ul><li>如果需要<strong>快速插入和删除</strong>，使用 <code>LinkedList</code>。  </li><li>如果需要<strong>频繁访问元素</strong>，使用 <code>ArrayList</code>。</li></ul><hr><h2 id="✅-总结"><a href="#✅-总结" class="headerlink" title="✅ 总结"></a>✅ <strong>总结</strong></h2><ul><li><code>LinkedList</code> 是基于<strong>双向链表</strong>实现的，插入和删除效率高。  </li><li>支持<strong>队列</strong>和<strong>栈</strong>操作，可以当作<strong>双端队列</strong>使用。  </li><li>不适合大量的随机访问，推荐在需要频繁增删的场景中使用。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 常用API </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用API </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程的创建方法</title>
      <link href="/2025/03/28/09-01-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E6%96%B9%E6%B3%95/"/>
      <url>/2025/03/28/09-01-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<ul><li><p>在 <strong>Java</strong> 中，有三种常用的方法来创建线程：  </p><ol><li><strong>继承 <code>Thread</code> 类</strong>  </li><li><strong>实现 <code>Runnable</code> 接口</strong>  </li><li><strong>使用 <code>Callable</code> 和 <code>Future</code></strong></li></ol><hr><h2 id="✅-方法一：继承-Thread-类"><a href="#✅-方法一：继承-Thread-类" class="headerlink" title="✅ 方法一：继承 Thread 类"></a>✅ <strong>方法一：继承 <code>Thread</code> 类</strong></h2><p><strong>特点：</strong>  </p><ul><li>直接继承 <code>Thread</code> 类并重写 <code>run()</code> 方法。  </li><li>使用 <code>start()</code> 方法启动线程。</li></ul><p><strong>示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;线程 &quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot; 正在运行&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">MyThread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>();<br>        <span class="hljs-type">MyThread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>();<br>        t1.start();<br>        t2.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>优点：</strong> 简单直观，直接创建线程对象。<br><strong>缺点：</strong> Java 不支持多继承，继承 <code>Thread</code> 后不能继承其他类。  </p><hr><h2 id="✅-方法二：实现-Runnable-接口"><a href="#✅-方法二：实现-Runnable-接口" class="headerlink" title="✅ 方法二：实现 Runnable 接口"></a>✅ <strong>方法二：实现 <code>Runnable</code> 接口</strong></h2><p><strong>特点：</strong>  </p><ul><li>实现 <code>Runnable</code> 接口，并重写 <code>run()</code> 方法。  </li><li>使用 <code>Thread</code> 类包装 <code>Runnable</code> 对象。</li></ul><p><strong>示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;线程 &quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot; 正在运行&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRunnable</span>());<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRunnable</span>());<br>        t1.start();<br>        t2.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>优点：</strong>  </p><ul><li>更灵活，适合需要共享资源的场景。  </li><li>可以通过实现接口避免 Java 的单继承限制。</li></ul><p><strong>缺点：</strong> 代码稍微复杂一点，需要通过 <code>Thread</code> 对象启动。  </p><hr><h2 id="✅-方法三：使用-Callable-和-Future"><a href="#✅-方法三：使用-Callable-和-Future" class="headerlink" title="✅ 方法三：使用 Callable 和 Future"></a>✅ <strong>方法三：使用 <code>Callable</code> 和 <code>Future</code></strong></h2><p><strong>特点：</strong>  </p><ul><li>使用 <code>Callable</code> 接口，可以有返回值，并抛出异常。  </li><li>使用 <code>FutureTask</code> 获取线程的执行结果。</li></ul><p><strong>示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.*;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCallable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span>&lt;String&gt; &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;线程 &quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot; 执行完成&quot;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">MyCallable</span> <span class="hljs-variable">callable</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCallable</span>();<br>        FutureTask&lt;String&gt; futureTask = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;&gt;(callable);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(futureTask);<br>        thread.start();<br><br>        <span class="hljs-comment">// 获取线程执行结果</span><br>        System.out.println(<span class="hljs-string">&quot;结果: &quot;</span> + futureTask.get());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>优点：</strong>  </p><ul><li>有返回值，可以获取任务执行结果。  </li><li>可以捕获异常，进行更好的异常处理。</li></ul><p><strong>缺点：</strong> 代码较复杂，需要额外处理 <code>FutureTask</code>。  </p><hr><h2 id="✅-总结：选择哪种方式？"><a href="#✅-总结：选择哪种方式？" class="headerlink" title="✅ 总结：选择哪种方式？"></a>✅ <strong>总结：选择哪种方式？</strong></h2><table><thead><tr><th><strong>场景</strong></th><th><strong>推荐方法</strong></th><th><strong>原因</strong></th></tr></thead><tbody><tr><td>简单任务，无需返回结果</td><td><code>Thread</code> 类</td><td>代码简单，适合一次性任务</td></tr><tr><td>需要共享资源或避免继承限制</td><td><code>Runnable</code> 接口</td><td>更加灵活，推荐优先使用</td></tr><tr><td>需要获取线程执行结果，或可能抛异常</td><td><code>Callable + Future</code></td><td>支持返回值和异常处理</td></tr></tbody></table></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LocalDate</title>
      <link href="/2025/03/28/10-LocalDate/"/>
      <url>/2025/03/28/10-LocalDate/</url>
      
        <content type="html"><![CDATA[<p>在 Java 中，<code>LocalDate</code> 是 <code>java.time</code> 包中的一个类，表示<strong>不带时区的日期</strong>（年、月、日）。它是 Java 8 引入的 <code>java.time</code> API 的一部分，用于替代 <code>java.util.Date</code> 和 <code>java.util.Calendar</code>。  </p><hr><h2 id="✅1-创建-LocalDate"><a href="#✅1-创建-LocalDate" class="headerlink" title="✅1. 创建 LocalDate"></a><strong>✅1. 创建 LocalDate</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.time.LocalDate;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 获取当前日期</span><br>        <span class="hljs-type">LocalDate</span> <span class="hljs-variable">today</span> <span class="hljs-operator">=</span> LocalDate.now();<br>        System.out.println(<span class="hljs-string">&quot;今天的日期: &quot;</span> + today);<br><br>        <span class="hljs-comment">// 指定日期 (年, 月, 日)</span><br>        <span class="hljs-type">LocalDate</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> LocalDate.of(<span class="hljs-number">2025</span>, <span class="hljs-number">3</span>, <span class="hljs-number">28</span>);<br>        System.out.println(<span class="hljs-string">&quot;指定日期: &quot;</span> + date);<br><br>        <span class="hljs-comment">// 解析字符串</span><br>        <span class="hljs-type">LocalDate</span> <span class="hljs-variable">parsedDate</span> <span class="hljs-operator">=</span> LocalDate.parse(<span class="hljs-string">&quot;2025-03-28&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;解析的日期: &quot;</span> + parsedDate);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="✅2-获取日期信息"><a href="#✅2-获取日期信息" class="headerlink" title="✅2. 获取日期信息"></a><strong>✅2. 获取日期信息</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">LocalDate</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> LocalDate.of(<span class="hljs-number">2025</span>, <span class="hljs-number">3</span>, <span class="hljs-number">28</span>);<br>System.out.println(<span class="hljs-string">&quot;年份: &quot;</span> + date.getYear());<br>System.out.println(<span class="hljs-string">&quot;月份: &quot;</span> + date.getMonth());  <span class="hljs-comment">// MARCH</span><br>System.out.println(<span class="hljs-string">&quot;月份值: &quot;</span> + date.getMonthValue()); <span class="hljs-comment">// 3</span><br>System.out.println(<span class="hljs-string">&quot;日: &quot;</span> + date.getDayOfMonth());<br>System.out.println(<span class="hljs-string">&quot;星期: &quot;</span> + date.getDayOfWeek());  <span class="hljs-comment">// FRIDAY</span><br>System.out.println(<span class="hljs-string">&quot;是否闰年: &quot;</span> + date.isLeapYear());  <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><hr><h2 id="✅3-日期计算"><a href="#✅3-日期计算" class="headerlink" title="✅3. 日期计算"></a><strong>✅3. 日期计算</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">LocalDate</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> LocalDate.of(<span class="hljs-number">2025</span>, <span class="hljs-number">3</span>, <span class="hljs-number">28</span>);<br><br><span class="hljs-comment">// 加/减天数、月数、年数</span><br><span class="hljs-type">LocalDate</span> <span class="hljs-variable">plusDays</span> <span class="hljs-operator">=</span> date.plusDays(<span class="hljs-number">5</span>);<br><span class="hljs-type">LocalDate</span> <span class="hljs-variable">minusMonths</span> <span class="hljs-operator">=</span> date.minusMonths(<span class="hljs-number">2</span>);<br><br>System.out.println(<span class="hljs-string">&quot;加5天: &quot;</span> + plusDays);<br>System.out.println(<span class="hljs-string">&quot;减2个月: &quot;</span> + minusMonths);<br><br><span class="hljs-comment">// 计算两个日期之间的天数</span><br><span class="hljs-type">LocalDate</span> <span class="hljs-variable">anotherDate</span> <span class="hljs-operator">=</span> LocalDate.of(<span class="hljs-number">2025</span>, <span class="hljs-number">4</span>, <span class="hljs-number">10</span>);<br><span class="hljs-type">long</span> <span class="hljs-variable">daysBetween</span> <span class="hljs-operator">=</span> java.time.temporal.ChronoUnit.DAYS.between(date, anotherDate);<br>System.out.println(<span class="hljs-string">&quot;两日期相差天数: &quot;</span> + daysBetween);<br></code></pre></td></tr></table></figure><hr><h2 id="✅4-日期比较"><a href="#✅4-日期比较" class="headerlink" title="✅4. 日期比较"></a><strong>✅4. 日期比较</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">LocalDate</span> <span class="hljs-variable">date1</span> <span class="hljs-operator">=</span> LocalDate.of(<span class="hljs-number">2025</span>, <span class="hljs-number">3</span>, <span class="hljs-number">28</span>);<br><span class="hljs-type">LocalDate</span> <span class="hljs-variable">date2</span> <span class="hljs-operator">=</span> LocalDate.of(<span class="hljs-number">2025</span>, <span class="hljs-number">4</span>, <span class="hljs-number">10</span>);<br><br>System.out.println(date1.isBefore(date2)); <span class="hljs-comment">// true</span><br>System.out.println(date1.isAfter(date2));  <span class="hljs-comment">// false</span><br>System.out.println(date1.equals(date2));   <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><hr><h2 id="✅5-获取本月第一天和最后一天"><a href="#✅5-获取本月第一天和最后一天" class="headerlink" title="✅5. 获取本月第一天和最后一天"></a><strong>✅5. 获取本月第一天和最后一天</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">LocalDate</span> <span class="hljs-variable">today</span> <span class="hljs-operator">=</span> LocalDate.now();<br><span class="hljs-type">LocalDate</span> <span class="hljs-variable">firstDay</span> <span class="hljs-operator">=</span> today.withDayOfMonth(<span class="hljs-number">1</span>);<br><span class="hljs-type">LocalDate</span> <span class="hljs-variable">lastDay</span> <span class="hljs-operator">=</span> today.withDayOfMonth(today.lengthOfMonth());<br><br>System.out.println(<span class="hljs-string">&quot;本月第一天: &quot;</span> + firstDay);<br>System.out.println(<span class="hljs-string">&quot;本月最后一天: &quot;</span> + lastDay);<br></code></pre></td></tr></table></figure><hr><h3 id="✅总结"><a href="#✅总结" class="headerlink" title="✅总结"></a><strong>✅总结</strong></h3><ul><li><code>LocalDate</code> <strong>不包含时间</strong>，只表示日期（年月日）。</li><li><strong>不可变对象</strong>，所有修改都会返回一个新实例。</li><li>使用 <code>now()</code> 获取当前日期，<code>of()</code> 创建指定日期，<code>parse()</code> 解析字符串。</li><li>提供日期计算、比较等操作。</li></ul><p>如果你需要<strong>时间</strong>，可以使用 <code>LocalDateTime</code> 或 <code>ZonedDateTime</code>。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>异常</title>
      <link href="/2025/03/28/11-%E5%BC%82%E5%B8%B8/"/>
      <url>/2025/03/28/11-%E5%BC%82%E5%B8%B8/</url>
      
        <content type="html"><![CDATA[<p>在 <strong>Java</strong> 中，<strong>异常（Exception）</strong> 是指程序在运行过程中发生的错误或意外情况。异常机制提供了一种优雅的方式来处理这些错误，避免程序崩溃。</p><hr><h2 id="✅-1-异常的分类"><a href="#✅-1-异常的分类" class="headerlink" title="✅ 1. 异常的分类"></a>✅ <strong>1. 异常的分类</strong></h2><p>Java 中的异常分为两大类：  </p><h3 id="1-Checked-Exception（受检异常）"><a href="#1-Checked-Exception（受检异常）" class="headerlink" title="(1) Checked Exception（受检异常）"></a><strong>(1) Checked Exception（受检异常）</strong></h3><ul><li>编译期异常，必须处理，否则代码无法编译。  </li><li>例如：<code>IOException</code>、<code>SQLException</code>、<code>FileNotFoundException</code> 等。  </li><li>需要用 <code>try-catch</code> 或 <code>throws</code> 处理。</li></ul><h3 id="2-Unchecked-Exception（非受检异常）"><a href="#2-Unchecked-Exception（非受检异常）" class="headerlink" title="(2) Unchecked Exception（非受检异常）"></a><strong>(2) Unchecked Exception（非受检异常）</strong></h3><ul><li>运行时异常，在程序运行时抛出。  </li><li>例如：<code>NullPointerException</code>、<code>ArrayIndexOutOfBoundsException</code> 等。  </li><li>可以不强制处理，但建议通过代码逻辑避免。</li></ul><hr><h2 id="✅-2-异常的基本语法"><a href="#✅-2-异常的基本语法" class="headerlink" title="✅ 2. 异常的基本语法"></a>✅ <strong>2. 异常的基本语法</strong></h2><h3 id="1-使用-try-catch-处理异常"><a href="#1-使用-try-catch-处理异常" class="headerlink" title="(1) 使用 try-catch 处理异常"></a><strong>(1) 使用 try-catch 处理异常</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span> / <span class="hljs-number">0</span>; <span class="hljs-comment">// 会抛出异常</span><br>        &#125; <span class="hljs-keyword">catch</span> (ArithmeticException e) &#123;<br>            System.out.println(<span class="hljs-string">&quot;捕获异常: &quot;</span> + e.getMessage());<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;执行 finally 语句，无论是否异常都会执行&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>说明：</strong>  </p><ul><li><code>try</code>：放置可能发生异常的代码。  </li><li><code>catch</code>：捕获异常并处理。  </li><li><code>finally</code>：可选，通常用于释放资源。</li></ul><hr><h3 id="2-使用-throws-声明异常"><a href="#2-使用-throws-声明异常" class="headerlink" title="(2) 使用 throws 声明异常"></a><strong>(2) 使用 throws 声明异常</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.File;<br><span class="hljs-keyword">import</span> java.io.FileNotFoundException;<br><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">readFile</span><span class="hljs-params">(String filePath)</span> <span class="hljs-keyword">throws</span> FileNotFoundException &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(filePath));<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            readFile(<span class="hljs-string">&quot;test.txt&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (FileNotFoundException e) &#123;<br>            System.out.println(<span class="hljs-string">&quot;文件未找到: &quot;</span> + e.getMessage());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>说明：</strong>  </p><ul><li><code>throws</code> 用于声明可能抛出的异常。  </li><li>调用方法时，需要使用 <code>try-catch</code> 处理异常。</li></ul><hr><h2 id="✅-3-多异常捕获"><a href="#✅-3-多异常捕获" class="headerlink" title="✅ 3. 多异常捕获"></a>✅ <strong>3. 多异常捕获</strong></h2><p>当可能抛出多种异常时，可以使用多 <code>catch</code> 语句：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>            System.out.println(arr[<span class="hljs-number">5</span>]); <span class="hljs-comment">// 数组越界异常</span><br>        &#125; <span class="hljs-keyword">catch</span> (ArithmeticException e) &#123;<br>            System.out.println(<span class="hljs-string">&quot;算术异常: &quot;</span> + e.getMessage());<br>        &#125; <span class="hljs-keyword">catch</span> (ArrayIndexOutOfBoundsException e) &#123;<br>            System.out.println(<span class="hljs-string">&quot;数组越界异常: &quot;</span> + e.getMessage());<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            System.out.println(<span class="hljs-string">&quot;其他异常: &quot;</span> + e.getMessage());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>说明：</strong>  </p><ul><li>异常应从<strong>具体异常</strong>到<strong>父类异常</strong>依次捕获，避免父类异常拦截所有异常。  </li><li><code>Exception</code> 是所有异常的父类。</li></ul><hr><h2 id="✅-4-自定义异常"><a href="#✅-4-自定义异常" class="headerlink" title="✅ 4. 自定义异常"></a>✅ <strong>4. 自定义异常</strong></h2><p>你可以通过继承 <code>Exception</code> 或 <code>RuntimeException</code> 来创建自定义异常。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 自定义异常类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Exception</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CustomException</span><span class="hljs-params">(String message)</span> &#123;<br>        <span class="hljs-built_in">super</span>(message);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkNumber</span><span class="hljs-params">(<span class="hljs-type">int</span> number)</span> <span class="hljs-keyword">throws</span> CustomException &#123;<br>        <span class="hljs-keyword">if</span> (number &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CustomException</span>(<span class="hljs-string">&quot;数字不能为负数: &quot;</span> + number);<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;数字是: &quot;</span> + number);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            checkNumber(-<span class="hljs-number">5</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (CustomException e) &#123;<br>            System.out.println(<span class="hljs-string">&quot;捕获异常: &quot;</span> + e.getMessage());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>说明：</strong>  </p><ul><li>自定义异常通常用于业务逻辑层中进行异常处理。  </li><li>使用 <code>throw</code> 关键字主动抛出异常。</li></ul><hr><h2 id="✅-5-常见异常类型"><a href="#✅-5-常见异常类型" class="headerlink" title="✅ 5. 常见异常类型"></a>✅ <strong>5. 常见异常类型</strong></h2><table><thead><tr><th><strong>异常类型</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><code>NullPointerException</code></td><td>访问空对象的属性或方法</td></tr><tr><td><code>ArrayIndexOutOfBoundsException</code></td><td>数组索引越界</td></tr><tr><td><code>ArithmeticException</code></td><td>算术运算异常，如除以 0</td></tr><tr><td><code>NumberFormatException</code></td><td>字符串转数字失败</td></tr><tr><td><code>IOException</code></td><td>输入输出异常</td></tr><tr><td><code>FileNotFoundException</code></td><td>文件未找到异常</td></tr><tr><td><code>ClassNotFoundException</code></td><td>找不到指定的类</td></tr></tbody></table><hr><h2 id="✅-总结"><a href="#✅-总结" class="headerlink" title="✅ 总结"></a>✅ <strong>总结</strong></h2><ul><li>使用 <code>try-catch</code> 捕获异常，避免程序崩溃。  </li><li>使用 <code>finally</code> 释放资源。  </li><li>使用 <code>throws</code> 声明异常，让调用者处理。  </li><li>自定义异常可用于业务逻辑校验。  </li><li>合理处理异常，有助于提高程序的健壮性和可维护性。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>泛型</title>
      <link href="/2025/03/28/12-%E6%B3%9B%E5%9E%8B/"/>
      <url>/2025/03/28/12-%E6%B3%9B%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>在 <strong>Java</strong> 中，<strong>泛型（Generics）</strong> 是一种提供<strong>类型安全</strong>和<strong>代码复用</strong>的机制。它允许你在类、接口和方法中定义类型参数，从而编写更加通用和灵活的代码。</p><hr><h2 id="✅-1-为什么需要泛型？"><a href="#✅-1-为什么需要泛型？" class="headerlink" title="✅ 1. 为什么需要泛型？"></a>✅ <strong>1. 为什么需要泛型？</strong></h2><p>在 Java 5 之前，集合类（如 <code>ArrayList</code>）只能存储 <code>Object</code> 类型，这导致了以下问题：  </p><ul><li><strong>类型不安全</strong>：需要强制类型转换，容易出现 <code>ClassCastException</code>。  </li><li><strong>代码不清晰</strong>：无法明确知道集合中存储的具体数据类型。</li></ul><p><strong>没有泛型的代码示例：</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ArrayList</span> <span class="hljs-variable">list</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>(); <span class="hljs-comment">// 使用Object存储</span><br>        list.add(<span class="hljs-string">&quot;Hello&quot;</span>);<br>        list.add(<span class="hljs-number">123</span>); <span class="hljs-comment">// 不同类型的数据</span><br><br>        <span class="hljs-comment">// 需要强制类型转换</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> (String) list.get(<span class="hljs-number">0</span>);<br>        System.out.println(str);<br><br>        <span class="hljs-comment">// 类型转换错误会抛出异常</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> (String) list.get(<span class="hljs-number">1</span>); <span class="hljs-comment">// ClassCastException</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>解决方法：使用泛型</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>list.add(<span class="hljs-string">&quot;Hello&quot;</span>);<br><span class="hljs-comment">// list.add(123); // 编译时报错，避免类型错误</span><br><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> list.get(<span class="hljs-number">0</span>); <span class="hljs-comment">// 不需要强制类型转换</span><br></code></pre></td></tr></table></figure><hr><h2 id="✅-2-泛型的基本语法"><a href="#✅-2-泛型的基本语法" class="headerlink" title="✅ 2. 泛型的基本语法"></a>✅ <strong>2. 泛型的基本语法</strong></h2><p><strong>定义泛型类</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Box</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">private</span> T content;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setContent</span><span class="hljs-params">(T content)</span> &#123;<br>        <span class="hljs-built_in">this</span>.content = content;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getContent</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> content;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Box&lt;String&gt; stringBox = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Box</span>&lt;&gt;();<br>        stringBox.setContent(<span class="hljs-string">&quot;泛型示例&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;内容: &quot;</span> + stringBox.getContent());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>解释：</strong>  </p><ul><li><code>&lt;T&gt;</code>：表示泛型类型，<code>T</code> 是一个占位符，可以用任意字母代替。  </li><li><code>Box&lt;String&gt;</code>：指定泛型类型为 <code>String</code>，确保类型安全。</li></ul><hr><h2 id="✅-3-泛型方法"><a href="#✅-3-泛型方法" class="headerlink" title="✅ 3. 泛型方法"></a>✅ <strong>3. 泛型方法</strong></h2><p>泛型不仅可以用于类，还可以用于方法。  </p><p><strong>泛型方法示例：</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br><br>    <span class="hljs-comment">// 定义一个泛型方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">printArray</span><span class="hljs-params">(T[] array)</span> &#123;<br>        <span class="hljs-keyword">for</span> (T element : array) &#123;<br>            System.out.print(element + <span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br>        System.out.println();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Integer[] intArray = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>        String[] strArray = &#123;<span class="hljs-string">&quot;Java&quot;</span>, <span class="hljs-string">&quot;Python&quot;</span>, <span class="hljs-string">&quot;C++&quot;</span>&#125;;<br><br>        printArray(intArray);<br>        printArray(strArray);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>解释：</strong>  </p><ul><li><code>&lt;T&gt;</code>：在方法返回类型之前声明。  </li><li><code>T[] array</code>：泛型数组参数。  </li><li>方法可以接受任意类型的数组。</li></ul><hr><h2 id="✅-4-泛型的类型边界"><a href="#✅-4-泛型的类型边界" class="headerlink" title="✅ 4. 泛型的类型边界"></a>✅ <strong>4. 泛型的类型边界</strong></h2><p>有时候我们需要对泛型的类型进行限制，Java 提供了两种方式：  </p><h3 id="1-上界通配符："><a href="#1-上界通配符：" class="headerlink" title="(1) 上界通配符： &lt;? extends T&gt;"></a><strong>(1) 上界通配符： <code>&lt;? extends T&gt;</code></strong></h3><ul><li>适用于读取数据。  </li><li>表示类型必须是 <code>T</code> 或 <code>T</code> 的子类。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printNumbers</span><span class="hljs-params">(List&lt;? extends Number&gt; list)</span> &#123;<br>        <span class="hljs-keyword">for</span> (Number num : list) &#123;<br>            System.out.println(num);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;Integer&gt; intList = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br>        List&lt;Double&gt; doubleList = Arrays.asList(<span class="hljs-number">1.1</span>, <span class="hljs-number">2.2</span>, <span class="hljs-number">3.3</span>);<br><br>        printNumbers(intList);<br>        printNumbers(doubleList);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-下界通配符："><a href="#2-下界通配符：" class="headerlink" title="(2) 下界通配符： &lt;? super T&gt;"></a><strong>(2) 下界通配符： <code>&lt;? super T&gt;</code></strong></h3><ul><li>适用于写入数据。  </li><li>表示类型必须是 <code>T</code> 或 <code>T</code> 的父类。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addNumbers</span><span class="hljs-params">(List&lt;? <span class="hljs-built_in">super</span> Integer&gt; list)</span> &#123;<br>        list.add(<span class="hljs-number">100</span>);<br>        list.add(<span class="hljs-number">200</span>);<br>        System.out.println(list);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;Number&gt; numberList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        addNumbers(numberList);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="✅-5-泛型中的通配符"><a href="#✅-5-泛型中的通配符" class="headerlink" title="✅ 5. 泛型中的通配符 &lt;?&gt;"></a>✅ <strong>5. 泛型中的通配符 <code>&lt;?&gt;</code></strong></h2><ul><li><code>&lt;?&gt;</code> 表示<strong>未知类型</strong>，称为<strong>通配符</strong>。  </li><li>常用于方法参数中，表示可以接受任何类型的集合。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printList</span><span class="hljs-params">(List&lt;?&gt; list)</span> &#123;<br>        <span class="hljs-keyword">for</span> (Object obj : list) &#123;<br>            System.out.println(obj);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;String&gt; strList = Arrays.asList(<span class="hljs-string">&quot;Java&quot;</span>, <span class="hljs-string">&quot;Python&quot;</span>);<br>        List&lt;Integer&gt; intList = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br><br>        printList(strList);<br>        printList(intList);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="✅-6-泛型的限制"><a href="#✅-6-泛型的限制" class="headerlink" title="✅ 6. 泛型的限制"></a>✅ <strong>6. 泛型的限制</strong></h2><ol><li><p><strong>基本数据类型不能作为泛型类型</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;<span class="hljs-type">int</span>&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(); <span class="hljs-comment">// 错误</span><br></code></pre></td></tr></table></figure><p><strong>解决方法：</strong> 使用包装类 <code>Integer</code> 替代 <code>int</code>：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br></code></pre></td></tr></table></figure></li><li><p><strong>不能创建泛型数组</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">T[] array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">T</span>[<span class="hljs-number">10</span>]; <span class="hljs-comment">// 错误</span><br></code></pre></td></tr></table></figure><p><strong>解决方法：</strong> 使用 <code>Object</code> 数组并强制转换：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>T[] array = (T[]) <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[<span class="hljs-number">10</span>];<br></code></pre></td></tr></table></figure></li></ol><hr><h2 id="✅-总结"><a href="#✅-总结" class="headerlink" title="✅ 总结"></a>✅ <strong>总结</strong></h2><ul><li><strong>泛型类</strong>：使用 <code>&lt;T&gt;</code> 声明通用类型，使类可以操作不同的数据类型。  </li><li><strong>泛型方法</strong>：在方法中使用 <code>&lt;T&gt;</code> 使其支持不同类型的参数。  </li><li><strong>通配符 <code>&lt;?&gt;</code></strong>：表示未知类型，用于通用代码。  </li><li><strong>上界 <code>&lt;? extends T&gt;</code></strong>：用于读取数据。  </li><li><strong>下界 <code>&lt;? super T&gt;</code></strong>：用于写入数据。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单例类</title>
      <link href="/2025/03/27/02-%E5%8D%95%E4%BE%8B%E7%B1%BB/"/>
      <url>/2025/03/27/02-%E5%8D%95%E4%BE%8B%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="单例类（Singleton）"><a href="#单例类（Singleton）" class="headerlink" title="单例类（Singleton）"></a>单例类（Singleton）</h2><p>单例模式（Singleton Pattern）是一种常见的设计模式，确保一个类在系统中只有一个实例，并提供一个全局访问点。</p><h3 id="单例模式的特点"><a href="#单例模式的特点" class="headerlink" title="单例模式的特点"></a><strong>单例模式的特点</strong></h3><ol><li><strong>唯一性</strong>：整个系统中该类只有一个实例。</li><li><strong>全局访问</strong>：可以在整个程序中访问这个实例。</li><li><strong>延迟初始化（可选）</strong>：只有在真正需要时才创建实例，提高性能。</li></ol><hr><h2 id="单例模式的实现方式"><a href="#单例模式的实现方式" class="headerlink" title="单例模式的实现方式"></a><strong>单例模式的实现方式</strong></h2><h3 id="1-饿汉式（Eager-Singleton）"><a href="#1-饿汉式（Eager-Singleton）" class="headerlink" title="1. 饿汉式（Eager Singleton）"></a><strong>1. 饿汉式（Eager Singleton）</strong></h3><h4 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a><strong>实现方式</strong></h4><ul><li>直接在类加载时创建实例，线程安全。</li><li>缺点是可能会造成资源浪费（如果实例很早创建，但一直未被使用）。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">public class Singleton &#123;<br>    private static final Singleton INSTANCE = new Singleton(); // 直接创建实例<br><br>    private Singleton() &#123;&#125; // 私有构造方法，防止外部创建对象<br><br>    public static Singleton getInstance() &#123;<br>        return INSTANCE;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="2-懒汉式（Lazy-Singleton）"><a href="#2-懒汉式（Lazy-Singleton）" class="headerlink" title="2. 懒汉式（Lazy Singleton）"></a><strong>2. 懒汉式（Lazy Singleton）</strong></h3><h4 id="实现方式-1"><a href="#实现方式-1" class="headerlink" title="实现方式"></a><strong>实现方式</strong></h4><ul><li>只有在第一次调用 <code>getInstance()</code> 时才创建实例，避免资源浪费。</li><li>但<strong>非线程安全</strong>，多个线程可能同时创建多个实例。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">public class Singleton &#123;<br>    private static Singleton instance;<br><br>    private Singleton() &#123;&#125; // 私有构造方法<br><br>    public static Singleton getInstance() &#123;<br>        if (instance == null) &#123; // 只有在需要时才创建实例<br>            instance = new Singleton();<br>        &#125;<br>        return instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>问题</strong>：多线程环境下，可能出现多个实例。</p><hr><h3 id="3-线程安全的懒汉式"><a href="#3-线程安全的懒汉式" class="headerlink" title="3. 线程安全的懒汉式"></a><strong>3. 线程安全的懒汉式</strong></h3><p><strong>方式 1：使用 synchronized</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">public class Singleton &#123;<br>    private static Singleton instance;<br><br>    private Singleton() &#123;&#125;<br><br>    public static synchronized Singleton getInstance() &#123;<br>        if (instance == null) &#123;<br>            instance = new Singleton();<br>        &#125;<br>        return instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>缺点</strong>：<code>synchronized</code> 影响性能，每次访问都需要加锁。</p><hr><p><strong>方式 2：双重检查锁（Double-Check Locking）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">public class Singleton &#123;<br>    private static volatile Singleton instance;<br><br>    private Singleton() &#123;&#125;<br><br>    public static Singleton getInstance() &#123;<br>        if (instance == null) &#123; // 第一次检查<br>            synchronized (Singleton.class) &#123;<br>                if (instance == null) &#123; // 第二次检查<br>                    instance = new Singleton();<br>                &#125;<br>            &#125;<br>        &#125;<br>        return instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong><code>volatile</code> 关键字</strong>：防止指令重排，保证可见性。</li><li><strong>双重检查</strong>：避免不必要的加锁，提高性能。</li></ul><hr><h3 id="4-静态内部类（推荐方式）"><a href="#4-静态内部类（推荐方式）" class="headerlink" title="4. 静态内部类（推荐方式）"></a><strong>4. 静态内部类（推荐方式）</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">public class Singleton &#123;<br>    private Singleton() &#123;&#125;<br><br>    private static class SingletonHolder &#123;<br>        private static final Singleton INSTANCE = new Singleton();<br>    &#125;<br><br>    public static Singleton getInstance() &#123;<br>        return SingletonHolder.INSTANCE;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>优点</strong>：</p><ul><li>线程安全，利用类加载机制确保实例唯一。</li><li><strong>延迟加载</strong>（Lazy Loading），只有 <code>getInstance()</code> 被调用时，才创建实例。</li></ul><hr><h3 id="5-枚举实现单例（最佳方案）"><a href="#5-枚举实现单例（最佳方案）" class="headerlink" title="5. 枚举实现单例（最佳方案）"></a><strong>5. 枚举实现单例（最佳方案）</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">public enum Singleton &#123;<br>    INSTANCE;<br><br>    public void doSomething() &#123;<br>        System.out.println(&quot;Hello Singleton!&quot;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>优点</strong>：</p><ul><li><strong>线程安全</strong>，由 JVM 保证。</li><li><strong>防止反射攻击</strong>（私有构造方法仍可通过反射破坏单例，但枚举不会）。</li><li><strong>防止反序列化创建新实例</strong>。</li></ul><hr><h2 id="防止反射和序列化破坏单例"><a href="#防止反射和序列化破坏单例" class="headerlink" title="防止反射和序列化破坏单例"></a><strong>防止反射和序列化破坏单例</strong></h2><ol><li><p><strong>防止反射破坏单例</strong></p><ul><li>在构造方法中检测实例是否已存在：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">public class Singleton &#123;<br>    private static volatile Singleton instance;<br><br>    private Singleton() &#123;<br>        if (instance != null) &#123;<br>            throw new RuntimeException(&quot;禁止反射创建单例！&quot;);<br>        &#125;<br>    &#125;<br><br>    public static Singleton getInstance() &#123;<br>        if (instance == null) &#123;<br>            synchronized (Singleton.class) &#123;<br>                if (instance == null) &#123;<br>                    instance = new Singleton();<br>                &#125;<br>            &#125;<br>        &#125;<br>        return instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>防止序列化破坏单例</strong></p><ul><li>通过 <code>readResolve()</code> 方法确保反序列化返回同一个实例：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">private Object readResolve() &#123;<br>    return instance;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><table><thead><tr><th>方式</th><th>是否线程安全</th><th>是否延迟加载</th><th>是否推荐</th></tr></thead><tbody><tr><td>饿汉式</td><td>✅</td><td>❌</td><td>❌（可能浪费资源）</td></tr><tr><td>懒汉式</td><td>❌</td><td>✅</td><td>❌（非线程安全）</td></tr><tr><td>synchronized 懒汉式</td><td>✅</td><td>✅</td><td>❌（影响性能）</td></tr><tr><td>双重检查锁</td><td>✅</td><td>✅</td><td>✅</td></tr><tr><td>静态内部类</td><td>✅</td><td>✅</td><td>✅（推荐）</td></tr><tr><td>枚举</td><td>✅</td><td>✅</td><td>⭐（最佳方式）</td></tr></tbody></table><p><strong>最佳实践</strong>：优先使用 <strong>枚举</strong> 或 <strong>静态内部类</strong> 实现单例。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>final关键字</title>
      <link href="/2025/03/27/01-final%E5%85%B3%E9%94%AE%E5%AD%97/"/>
      <url>/2025/03/27/01-final%E5%85%B3%E9%94%AE%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<p><code>final</code> 关键字在 Java 中主要用于修饰<strong>变量、方法和类</strong>，用来表示<strong>不可更改</strong>的特性。具体用法如下：</p><hr><h2 id="1-修饰变量（常量）"><a href="#1-修饰变量（常量）" class="headerlink" title="1. 修饰变量（常量）"></a>1. 修饰变量（常量）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">final int MAX_VALUE = 100;<br>MAX_VALUE = 200; // ❌ 编译错误，不能修改 final 变量<br></code></pre></td></tr></table></figure><ul><li><strong>修饰基本数据类型</strong>：值不能被修改。</li><li><strong>修饰引用类型</strong>：引用地址不能修改，但对象的内容可以更改。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">final List&lt;String&gt; list = new ArrayList&lt;&gt;();<br>list.add(&quot;Hello&quot;);  // ✅ 可以修改内容<br>list = new ArrayList&lt;&gt;();  // ❌ 不能修改引用地址<br></code></pre></td></tr></table></figure><hr><h2 id="2-修饰方法（防止方法被重写）"><a href="#2-修饰方法（防止方法被重写）" class="headerlink" title="2. 修饰方法（防止方法被重写）"></a>2. 修饰方法（防止方法被重写）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class Parent &#123;<br>    final void show() &#123;<br>        System.out.println(&quot;Parent show&quot;);<br>    &#125;<br>&#125;<br><br>class Child extends Parent &#123;<br>    // ❌ 编译错误，不能重写 final 方法<br>    void show() &#123; <br>        System.out.println(&quot;Child show&quot;); <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="3-修饰类（防止类被继承）"><a href="#3-修饰类（防止类被继承）" class="headerlink" title="3. 修饰类（防止类被继承）"></a>3. 修饰类（防止类被继承）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">final class Animal &#123;<br>    void speak() &#123;<br>        System.out.println(&quot;Animal speaks&quot;);<br>    &#125;<br>&#125;<br><br>// ❌ 编译错误，不能继承 final 类<br>class Dog extends Animal &#123; <br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="4-final-关键字的特殊用法"><a href="#4-final-关键字的特殊用法" class="headerlink" title="4. final 关键字的特殊用法"></a>4. final 关键字的特殊用法</h2><h3 id="（1）修饰成员变量（必须初始化）"><a href="#（1）修饰成员变量（必须初始化）" class="headerlink" title="（1）修饰成员变量（必须初始化）"></a>（1）修饰成员变量（必须初始化）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class Test &#123;<br>    final int num; // 必须在构造器或代码块中初始化<br><br>    Test(int num) &#123;<br>        this.num = num;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="（2）修饰方法参数（参数值不能被修改）"><a href="#（2）修饰方法参数（参数值不能被修改）" class="headerlink" title="（2）修饰方法参数（参数值不能被修改）"></a>（2）修饰方法参数（参数值不能被修改）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">void print(final int x) &#123;<br>    x = 20; // ❌ 编译错误<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="（3）配合-static-final（常量）"><a href="#（3）配合-static-final（常量）" class="headerlink" title="（3）配合 static final（常量）"></a>（3）配合 <code>static final</code>（常量）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">static final double PI = 3.14159;<br></code></pre></td></tr></table></figure><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>修饰变量</strong>：变量值不可变（基本类型值不可变，引用类型地址不可变）。</li><li><strong>修饰方法</strong>：防止子类重写方法。</li><li><strong>修饰类</strong>：防止类被继承。</li></ul><p>这样使用 <code>final</code> 主要是为了<strong>保证安全性</strong>、<strong>提高程序的可读性</strong>，并且在某些情况下还能<strong>优化性能</strong>（JVM 可进行编译优化）。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>枚举类</title>
      <link href="/2025/03/27/03-%E6%9E%9A%E4%B8%BE%E7%B1%BB/"/>
      <url>/2025/03/27/03-%E6%9E%9A%E4%B8%BE%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="枚举类（Enum）"><a href="#枚举类（Enum）" class="headerlink" title="枚举类（Enum）"></a><strong>枚举类（Enum）</strong></h2><h3 id="1-什么是枚举类？"><a href="#1-什么是枚举类？" class="headerlink" title="1. 什么是枚举类？"></a><strong>1. 什么是枚举类？</strong></h3><p>枚举（<code>enum</code>）是一种特殊的类，表示一组固定的常量。它在 Java、C++、Python 等编程语言中广泛应用，通常用于定义状态、类型、方向等不可变值。</p><hr><h3 id="2-Java-枚举的基本使用"><a href="#2-Java-枚举的基本使用" class="headerlink" title="2. Java 枚举的基本使用"></a><strong>2. Java 枚举的基本使用</strong></h3><p>Java 枚举使用 <code>enum</code> 关键字定义，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">public enum Color &#123;<br>    RED, GREEN, BLUE;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>特点</strong>：</p><ul><li><code>enum</code> 实际上是一个类，继承自 <code>java.lang.Enum</code>。</li><li>枚举的实例是<strong>固定的、有限的</strong>，不能通过 <code>new</code> 创建新实例。</li><li>每个枚举值本质上是 <code>Color</code> 类的一个静态实例。</li></ul><p><strong>使用示例</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">Color c = Color.RED;<br>System.out.println(c); // 输出：RED<br></code></pre></td></tr></table></figure><hr><h3 id="3-枚举类的常见用法"><a href="#3-枚举类的常见用法" class="headerlink" title="3. 枚举类的常见用法"></a><strong>3. 枚举类的常见用法</strong></h3><h4 id="（1）枚举类中定义属性和方法"><a href="#（1）枚举类中定义属性和方法" class="headerlink" title="（1）枚举类中定义属性和方法"></a><strong>（1）枚举类中定义属性和方法</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">public enum Status &#123;<br>    SUCCESS(200, &quot;OK&quot;),<br>    ERROR(500, &quot;Server Error&quot;),<br>    NOT_FOUND(404, &quot;Not Found&quot;);<br><br>    private final int code;<br>    private final String message;<br><br>    // 构造方法（必须是 private）<br>    private Status(int code, String message) &#123;<br>        this.code = code;<br>        this.message = message;<br>    &#125;<br><br>    public int getCode() &#123;<br>        return code;<br>    &#125;<br><br>    public String getMessage() &#123;<br>        return message;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>使用：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">System.out.println(Status.SUCCESS.getCode());    // 输出：200<br>System.out.println(Status.SUCCESS.getMessage()); // 输出：&quot;OK&quot;<br></code></pre></td></tr></table></figure><hr><h4 id="（2）枚举类中的抽象方法"><a href="#（2）枚举类中的抽象方法" class="headerlink" title="（2）枚举类中的抽象方法"></a><strong>（2）枚举类中的抽象方法</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">public enum Operation &#123;<br>    ADD &#123;<br>        @Override<br>        public int apply(int a, int b) &#123;<br>            return a + b;<br>        &#125;<br>    &#125;,<br>    SUBTRACT &#123;<br>        @Override<br>        public int apply(int a, int b) &#123;<br>            return a - b;<br>        &#125;<br>    &#125;;<br><br>    public abstract int apply(int a, int b);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>使用：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">int result = Operation.ADD.apply(5, 3); // 5 + 3 = 8<br>System.out.println(result);<br></code></pre></td></tr></table></figure><hr><h4 id="（3）遍历枚举值"><a href="#（3）遍历枚举值" class="headerlink" title="（3）遍历枚举值"></a><strong>（3）遍历枚举值</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">(Color c : Color.values()) &#123;<br>    System.out.println(c);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">RED<br>GREEN<br>BLUE<br></code></pre></td></tr></table></figure><hr><h4 id="（4）枚举类的-valueOf-方法"><a href="#（4）枚举类的-valueOf-方法" class="headerlink" title="（4）枚举类的 valueOf 方法"></a><strong>（4）枚举类的 <code>valueOf</code> 方法</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">Color c = Color.valueOf(&quot;RED&quot;);<br>System.out.println(c); // 输出：RED<br></code></pre></td></tr></table></figure><ul><li><code>valueOf(&quot;RED&quot;)</code> 必须匹配 <code>enum</code> 中的名称（区分大小写）。</li><li>如果传入 <code>&quot;red&quot;</code>，会抛出 <code>IllegalArgumentException</code>。</li></ul><hr><h3 id="4-枚举实现单例模式（推荐）"><a href="#4-枚举实现单例模式（推荐）" class="headerlink" title="4. 枚举实现单例模式（推荐）"></a><strong>4. 枚举实现单例模式（推荐）</strong></h3><p>枚举是实现单例模式的最佳方式，<strong>线程安全</strong>、<strong>防止反射破坏</strong>、<strong>防止序列化破坏</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">public enum Singleton &#123;<br>    INSTANCE;<br><br>    public void doSomething() &#123;<br>        System.out.println(&quot;Hello, Singleton!&quot;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>使用：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">Singleton.INSTANCE.doSomething();<br></code></pre></td></tr></table></figure><hr><h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a><strong>5. 总结</strong></h3><table><thead><tr><th>特性</th><th>描述</th></tr></thead><tbody><tr><td>继承</td><td><code>enum</code> 默认继承 <code>java.lang.Enum</code>，不能再继承其他类</td></tr><tr><td>线程安全</td><td><code>enum</code> 本质上是 <code>final</code>，且实例是静态的，天然线程安全</td></tr><tr><td>构造方法</td><td>必须是 <code>private</code>，外部不能 <code>new</code> 构造</td></tr><tr><td>反射安全</td><td>反射无法创建新的 <code>enum</code> 实例</td></tr><tr><td>序列化安全</td><td><code>enum</code> 反序列化时不会创建新对象，保证单例</td></tr></tbody></table><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a><strong>适用场景</strong></h3><ul><li><strong>定义常量集合</strong>（如 HTTP 状态码、星期、颜色等）</li><li><strong>替代 <code>switch-case</code> 语句中的字符串或整数</strong></li><li><strong>实现策略模式</strong></li><li><strong>单例模式（推荐使用）</strong></li></ul><p>枚举不仅仅是常量的集合，它可以包含方法、构造函数，甚至实现接口，使其更加强大和灵活。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>抽象类与接口</title>
      <link href="/2025/03/27/04-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3/"/>
      <url>/2025/03/27/04-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<ul><li><p>在面向对象编程（OOP）中，<strong>抽象类（Abstract Class）</strong> 和 <strong>接口（Interface）</strong> 是两种定义类的方式，它们都可以用于定义规范，但它们有一些重要的区别。</p><hr><h2 id="1-抽象类（Abstract-Class）"><a href="#1-抽象类（Abstract-Class）" class="headerlink" title="1. 抽象类（Abstract Class）"></a><strong>1. 抽象类（Abstract Class）</strong></h2><p><strong>定义</strong>：</p><ul><li>抽象类是不能被实例化的类，通常包含至少一个<strong>抽象方法</strong>（没有方法体的函数）。</li><li>主要用于提供基本实现，并允许子类继承。</li><li>既可以包含普通方法（有方法体），也可以包含抽象方法（只有方法声明，没有方法体）。</li></ul><p><strong>特点</strong>：</p><ol><li><strong>不能实例化</strong>，只能被继承。</li><li>可以包含<strong>普通方法</strong>和<strong>抽象方法</strong>。</li><li><strong>可以</strong>有成员变量（字段），可以定义构造函数。</li><li><strong>可以</strong>有访问修饰符（public、protected、private）。</li></ol><p><strong>示例（Java）：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">abstract class Animal &#123;<br>    String name;<br><br>    // 构造方法<br>    Animal(String name) &#123;<br>        this.name = name;<br>    &#125;<br><br>    // 具体方法<br>    void eat() &#123;<br>        System.out.println(name + &quot; is eating.&quot;);<br>    &#125;<br><br>    // 抽象方法（子类必须实现）<br>    abstract void makeSound();<br>&#125;<br><br>class Dog extends Animal &#123;<br>    Dog(String name) &#123;<br>        super(name);<br>    &#125;<br><br>    @Override<br>    void makeSound() &#123;<br>        System.out.println(&quot;Woof Woof!&quot;);<br>    &#125;<br>&#125;<br><br>public class Main &#123;<br>    public static void main(String[] args) &#123;<br>        Dog dog = new Dog(&quot;Buddy&quot;);<br>        dog.eat();      // 继承的普通方法<br>        dog.makeSound(); // 实现的抽象方法<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="2-接口（Interface）"><a href="#2-接口（Interface）" class="headerlink" title="2. 接口（Interface）"></a><strong>2. 接口（Interface）</strong></h2><p><strong>定义</strong>：</p><ul><li>接口是一个完全抽象的类，所有方法<strong>默认都是抽象的</strong>（Java 8 之后支持默认方法）。</li><li>主要用于定义行为规范，而<strong>不提供实现</strong>，由实现接口的类提供具体实现。</li></ul><p><strong>特点</strong>：</p><ol><li><strong>不能实例化</strong>，只能被类实现（<code>implements</code>）。</li><li><strong>所有方法默认是 <code>public abstract</code></strong>（即使不写 <code>public abstract</code> 关键字）。</li><li><strong>不能</strong>包含普通方法（Java 8 之后可以有默认方法 <code>default</code>）。</li><li><strong>不能</strong>有成员变量，但可以有 <code>public static final</code> 常量。</li><li><strong>一个类可以实现多个接口</strong>（支持多继承）。</li></ol><p><strong>示例（Java）：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">interface Animal &#123;<br>    // 默认是 public abstract<br>    void makeSound();<br>&#125;<br><br>// 接口实现<br>class Cat implements Animal &#123;<br>    @Override<br>    public void makeSound() &#123;<br>        System.out.println(&quot;Meow Meow!&quot;);<br>    &#125;<br>&#125;<br><br>public class Main &#123;<br>    public static void main(String[] args) &#123;<br>        Cat cat = new Cat();<br>        cat.makeSound();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="3-主要区别"><a href="#3-主要区别" class="headerlink" title="3. 主要区别"></a><strong>3. 主要区别</strong></h2><table><thead><tr><th><strong>对比项</strong></th><th><strong>抽象类</strong></th><th><strong>接口</strong></th></tr></thead><tbody><tr><td><strong>实例化</strong></td><td>不能被实例化</td><td>不能被实例化</td></tr><tr><td><strong>方法</strong></td><td>可以有普通方法和抽象方法</td><td>只能有抽象方法（Java 8+ 允许默认方法）</td></tr><tr><td><strong>成员变量</strong></td><td>可以有变量（实例变量、静态变量）</td><td>只能有 <code>public static final</code> 常量</td></tr><tr><td><strong>构造函数</strong></td><td>可以有构造函数</td><td>不能有构造函数</td></tr><tr><td><strong>继承关系</strong></td><td>只能单继承（<code>extends</code>）</td><td>可以多实现（<code>implements</code>）</td></tr><tr><td><strong>使用场景</strong></td><td>用于<strong>共享代码</strong>和定义行为</td><td>用于<strong>定义规范</strong>，让不同类实现相同行为</td></tr></tbody></table><hr><h2 id="4-什么时候用？"><a href="#4-什么时候用？" class="headerlink" title="4. 什么时候用？"></a><strong>4. 什么时候用？</strong></h2><p>✅ <strong>用抽象类</strong>：</p><ul><li>当多个类有<strong>共同的部分实现</strong>（代码复用），但仍然需要在子类中提供具体实现时。</li><li>当希望<strong>限制继承</strong>，只允许单一继承时。</li></ul><p>✅ <strong>用接口</strong>：</p><ul><li>当需要<strong>多个类具有相同行为</strong>，但它们本身可能没有共同的父类。</li><li>当需要<strong>多继承</strong>时（Java 不支持类的多继承，但支持接口的多实现）。</li><li>当需要定义一个<strong>严格的行为规范</strong>时。</li></ul><hr><h3 id="5-结合使用"><a href="#5-结合使用" class="headerlink" title="5. 结合使用"></a><strong>5. 结合使用</strong></h3><p>有时候，可以结合 <strong>抽象类</strong> 和 <strong>接口</strong>，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">interface Flyable &#123;<br>    void fly();<br>&#125;<br><br>abstract class Bird &#123;<br>    void eat() &#123;<br>        System.out.println(&quot;Bird is eating.&quot;);<br>    &#125;<br><br>    abstract void makeSound();<br>&#125;<br><br>// 继承抽象类 &amp; 实现接口<br>class Sparrow extends Bird implements Flyable &#123;<br>    @Override<br>    void makeSound() &#123;<br>        System.out.println(&quot;Chirp Chirp!&quot;);<br>    &#125;<br><br>    @Override<br>    public void fly() &#123;<br>        System.out.println(&quot;Sparrow is flying.&quot;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里 <code>Sparrow</code> 继承 <code>Bird</code>（因为所有鸟都可以吃东西），但也实现了 <code>Flyable</code> 接口，因为不是所有鸟都会飞（如企鹅）。</p><hr><h2 id="6-结论"><a href="#6-结论" class="headerlink" title="6. 结论"></a><strong>6. 结论</strong></h2><ul><li><strong>抽象类</strong> 适用于<strong>父类提供部分实现</strong>，子类扩展功能的情况。</li><li><strong>接口</strong> 适用于<strong>定义行为规范</strong>，让多个不相关的类实现相同方法的情况。</li><li><strong>接口比抽象类更灵活</strong>，因为它允许<strong>多实现</strong>。</li></ul><p>💡 <strong>记住</strong>：如果是**“是什么”<strong>（继承关系），用</strong>抽象类**；如果是**“能做什么”<strong>（行为规范），用</strong>接口**。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown语法</title>
      <link href="/2025/03/25/Markdown%E8%AF%AD%E6%B3%95/"/>
      <url>/2025/03/25/Markdown%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="1-0标题"><a href="#1-0标题" class="headerlink" title="1.0标题"></a>1.0标题</h2><p>语法展示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plaintext"># 一级标题<br>## 二级标题<br>### 三级标题<br>#### 四级标题<br>##### 五级标题<br>###### 六级标题<br></code></pre></td></tr></table></figure><hr><h2 id="2-0字体"><a href="#2-0字体" class="headerlink" title="2.0字体"></a>2.0字体</h2><p>语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">*斜体文本*<br>**粗体文本**<br>***粗斜体文本***<br></code></pre></td></tr></table></figure><p><em>斜体</em></p><p><strong>粗体</strong></p><p><em><strong>粗斜体</strong></em></p><hr><h2 id="3-0分割线"><a href="#3-0分割线" class="headerlink" title="3.0分割线"></a>3.0分割线</h2><p>分割线可以让文章变得更加有层次感，语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">***<br>----------<br>_ _ _<br></code></pre></td></tr></table></figure><hr><h2 id="4-0删除线"><a href="#4-0删除线" class="headerlink" title="4.0删除线"></a>4.0删除线</h2><p>给文本加上删除线，在文本两端使用两个波浪线<code>~</code>，语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">~~文本~~<br></code></pre></td></tr></table></figure><p>例如：<del>文本</del></p><hr><h2 id="5-0列表"><a href="#5-0列表" class="headerlink" title="5.0列表"></a>5.0列表</h2><p>列表分为无序和有序</p><hr><h3 id="5-1无序列表"><a href="#5-1无序列表" class="headerlink" title="5.1无序列表"></a>5.1无序列表</h3><p>无序列表使用星号<code>*</code>、加号 <code>+</code>、减号 <code>-</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">* 第一项<br>* 第二项<br>* 第三项<br><br>+ 第一项<br>+ 第二项<br>+ 第三项<br><br><br>- 第一项<br>- 第二项<br>- 第三项<br></code></pre></td></tr></table></figure><p>例如：</p><ul><li>第一项</li><li>第二项</li><li>第三项</li></ul><hr><h3 id="5-2有序列表"><a href="#5-2有序列表" class="headerlink" title="5.2有序列表"></a>5.2有序列表</h3><p>有序列表很简单，就是数字加上<code>.</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">1. 第一项<br>2. 第二项<br>3. 第三项<br></code></pre></td></tr></table></figure><p>例如：</p><ol><li>第一项</li><li>第二项</li><li>第三项</li></ol><hr><h3 id="5-3列表嵌套"><a href="#5-3列表嵌套" class="headerlink" title="5.3列表嵌套"></a>5.3列表嵌套</h3><p>无序和有序可以一起使用，只需要在子列表的选项添加四个空格</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">1. 第一项：<br>    - 子列表1<br>    - 子列表2<br>2. 第二项：<br>    - 子列表1<br>    - 子列表2<br></code></pre></td></tr></table></figure><hr><h2 id="6-0区块"><a href="#6-0区块" class="headerlink" title="6.0区块"></a>6.0区块</h2><p>区块是用来引用的，比如链接或者一段文本</p><p>在段落的开头使用<code>&gt;</code>符号，使用空格，隔开文本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&gt; 引用的内容<br>&gt;<br>&gt; 第二段引用的内容<br></code></pre></td></tr></table></figure><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">https://source.fomal.cc/img/default_cover_1.webp<br></code></pre></td></tr></table></figure></blockquote><p>在引用里面也是分段落的，我们不是使用回车，而是使用<code>&gt;</code>成单个一行</p><hr><h3 id="6-1区块嵌套"><a href="#6-1区块嵌套" class="headerlink" title="6.1区块嵌套"></a>6.1区块嵌套</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&gt; 引用<br>&gt;&gt; 2<br>&gt;&gt;<br>&gt;&gt;&gt;3<br></code></pre></td></tr></table></figure><hr><h2 id="7-0代码块"><a href="#7-0代码块" class="headerlink" title="7.0代码块"></a>7.0代码块</h2><p>这是一个程序员专用的语法，代码块可以展示不同语言的代码，代码块语法如下:上下使用三个点进行包裹，最顶上的可以写上代码的类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">```javascript<br>$(document).ready(function () &#123;<br>    alert(&#x27;RUNOOB&#x27;);<br>&#125;);<br>```<br></code></pre></td></tr></table></figure><hr><h2 id="8-0链接"><a href="#8-0链接" class="headerlink" title="8.0链接"></a>8.0链接</h2><p>插入链接有两种方式：</p><ul><li>第一种：直接插入</li></ul><p><a href="https://selimn0802.github.io/">https://selimn0802.github.io/</a></p><p>这种方式适用于短的链接，但是过长的链接可能会看起来不得当</p><ul><li>第二种：使用markdown语法插入</li></ul><p>其实就是让一段文本，拥有跳转功能</p><p>语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">[链接名称](链接地址)<br><br>或者<br><br>&lt;链接地址&gt;<br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">[Firefly](https://selimn0802.github.io/)<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;https://selimn0802.github.io/&gt;<br></code></pre></td></tr></table></figure><p><a href="https://selimn0802.github.io/">Firefly</a></p><p><a href="https://selimn0802.github.io/">https://selimn0802.github.io/</a></p><hr><h2 id="9-0图片"><a href="#9-0图片" class="headerlink" title="9.0图片"></a>9.0图片</h2><p>语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">![图片描述](图片的链接)<br></code></pre></td></tr></table></figure><p><img src="https://source.fomal.cc/img/default_cover_1.webp" alt="原神"></p><hr><h2 id="10-0表格"><a href="#10-0表格" class="headerlink" title="10.0表格"></a>10.0表格</h2><p>在markdown里面是可以插入表格的，可以体现一些数据</p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">|  表头   | 表头  |<br>|  ----  | ----  |<br>| 单元格  | 单元格 |<br>| 单元格  | 单元格 |<br></code></pre></td></tr></table></figure><hr><h3 id="10-1表格对齐"><a href="#10-1表格对齐" class="headerlink" title="10.1表格对齐"></a>10.1表格对齐</h3><ul><li>居右<code>-:</code></li><li>居左<code>:-</code></li><li>居中<code>:-:</code></li></ul><p>语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">| 左对齐 | 右对齐 | 居中对齐 |<br>| :-----| ----: | :----: |<br>| 单元格 | 单元格 | 单元格 |<br>| 单元格 | 单元格 | 单元格 |<br></code></pre></td></tr></table></figure><hr><h2 id="11-0转义字符"><a href="#11-0转义字符" class="headerlink" title="11.0转义字符"></a>11.0转义字符</h2><p>因为在markdown的语法里面，用了一些特定的符号作为语法，如果我们想输出符号，而不是被识别成语法，就需要使转义字符，只需要使用反斜杠，然后加上下面的某个符号即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">\   反斜线<br>`   反引号<br>*   星号<br>_   下划线<br>&#123;&#125;  花括号<br>[]  方括号<br>()  小括号<br>#   井字号<br>+   加号<br>-   减号<br>.   英文句点<br>!   感叹号<br></code></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2025/03/23/hello-world/"/>
      <url>/2025/03/23/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>关于</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>友链</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>音乐</title>
      <link href="/music/index.html"/>
      <url>/music/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>标签</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>电影</title>
      <link href="/movies/index.html"/>
      <url>/movies/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
